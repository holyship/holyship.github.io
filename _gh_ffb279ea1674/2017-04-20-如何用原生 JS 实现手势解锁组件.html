---
title: 如何用原生 JS 实现手势解锁组件
author: 月影
date: '2017-04-20 00:00:00 +0000'

---

{% raw  %}
<p style="margin: 0px 0px 1.2em !important;">这是<a>第三届 360 前端星计划</a>的选拔<a>作业题</a>。600多名学生参与了解答，最后通过了60人。这60名同学完成的不错，思路、代码风格、功能完成度颇有可取之处，不过也有一些欠考虑的地方，比如发现很多同学能按照需求实现完整的功能，但是不知道应当如何<strong>设计开放的 API</strong>，或者说，如何分析和预判产品需求和未来的变化，从而决定什么应当开放，什么应当封装。这无关于答案正确与否，还是和经验有关。</p><p style="margin: 0px 0px 1.2em !important;">在这里，我提供一个<a>参考的版本</a>，并不是说这一版就最好，而是说，通过这一版，分析当我们遇到这样的比较复杂的 UI 需求的时候，我们应该怎样思考和实现。</p><p><img src="/gh_ffb279ea1674/images/ac32237a8fe78d73e5e442fb8d4c59f9e564192c.png" style="width: 640px !important; height: 1120px !important; visibility: visible !important;"></p><h2 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.4em; border-bottom: 1px solid rgb(238, 238, 238);">组件设计的一般步骤</h2><p style="margin: 0px 0px 1.2em !important;">组件设计一般来说包括如下一些过程：</p><ol style="margin: 1.2em 0px;padding-left: 2em;" class="list-paddingleft-2"><li><p>理解需求</p></li><li><p>技术选型</p></li><li><p>结构（UI）设计</p></li><li><p>数据和API设计</p></li><li><p>流程设计</p></li><li><p>兼容性和细节优化</p></li><li><p>工具 &amp; 工程化</p></li></ol><p style="margin: 0px 0px 1.2em !important;">这些过程并不是每个组件设计的时候都会遇到，但是通常来说一个项目总会在其中一些过程里遇到问题需要解决。下面我们来简单分析一下。</p><h3 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.3em;">理解需求</h3><p style="margin: 0px 0px 1.2em !important;">作业本身只是说设计一个常见的手势密码的 UI 交互，可以通过选择验证密码和设置密码来切换两种状态，每种状态有自己的流程。因此大部分同学就照着需求把整个组件的状态切换和流程封装了起来，有的同学提供了一定的 UI 样式配置能力，但是基本上没有同学能将流程和状态切换过程中的节点给开放出来。实际上这个组件如果要给用户使用，显然需要将过程节点开放出来，也就是说，<strong>需要由使用者决定设置密码的过程里执行什么操作、验证密码的过程和密码验证成功后执行什么操作</strong>，这些是组件开发者无法代替使用者来决定的。</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none; display: block !important;"><span class="" style="color: rgb(227, 206, 171);">var</span> password = <span class="" style="color: rgb(204, 147, 147);">'11121323'</span>;<br><br><span class="" style="color: rgb(227, 206, 171);">var</span> locker = <span class="" style="color: rgb(227, 206, 171);">new</span> HandLock.Locker({
 &nbsp;container: <span class="" style="color: rgb(204, 147, 147);">document</span>.querySelector(<span class="" style="color: rgb(204, 147, 147);">'#handlock'</span>),
 &nbsp;check: {
 &nbsp; &nbsp;checked: <span class=""><span class="" style="color: rgb(227, 206, 171);">function</span><span class="">(res)</span></span>{ &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(res.err){ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">console</span>.error(res.err); <span class="" style="color: rgb(127, 159, 127);">//密码错误或长度太短</span>
 &nbsp; &nbsp; &nbsp; &nbsp;[执行操作...]
 &nbsp; &nbsp; &nbsp;}<span class="" style="color: rgb(227, 206, 171);">else</span>{ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">console</span>.log(`正确，密码是：${res.records}`);
 &nbsp; &nbsp; &nbsp; &nbsp;[执行操作...]
 &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;},
 &nbsp;},
 &nbsp;update:{
 &nbsp; &nbsp;beforeRepeat: <span class=""><span class="" style="color: rgb(227, 206, 171);">function</span><span class="">(res)</span></span>{ &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(res.err){ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">console</span>.error(res.err); <span class="" style="color: rgb(127, 159, 127);">//密码长度太短</span>
 &nbsp; &nbsp; &nbsp; &nbsp;[执行操作...]
 &nbsp; &nbsp; &nbsp;}<span class="" style="color: rgb(227, 206, 171);">else</span>{ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">console</span>.log(`密码初次输入完成，等待重复输入`);
 &nbsp; &nbsp; &nbsp; &nbsp;[执行操作...]
 &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;},
 &nbsp; &nbsp;afterRepeat: <span class=""><span class="" style="color: rgb(227, 206, 171);">function</span><span class="">(res)</span></span>{ &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(res.err){ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">console</span>.error(res.err); <span class="" style="color: rgb(127, 159, 127);">//密码长度太短或者两次密码输入不一致</span>
 &nbsp; &nbsp; &nbsp; &nbsp;[执行操作...]
 &nbsp; &nbsp; &nbsp;}<span class="" style="color: rgb(227, 206, 171);">else</span>{ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">console</span>.log(`密码更新完成，新密码是：${res.records}`);
 &nbsp; &nbsp; &nbsp; &nbsp;[执行操作...]
 &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;},
 &nbsp;}
});

locker.check(password);</code></pre><h3 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.3em;">技术选型</h3><p style="margin: 0px 0px 1.2em !important;">这个问题的 UI 展现的核心是九宫格和选中的小圆点，从技术上来讲，我们有三种可选方案： DOM/Canvas/SVG，三者都是可以实现主体 UI 的。</p><p style="margin: 0px 0px 1.2em !important;">如果使用 DOM，最简单的方式是使用 flex 布局，这样能够做成响应式的。</p><p style="margin: 0px 0px 1.2em !important;"><a class="">DOM 实现绘制</a></p><p style="margin: 0px 0px 1.2em !important;">使用 DOM 的优点是容易实现响应式，事件处理简单，布局也不复杂（但是和 Canvas 比起来略微复杂），但是斜线（demo 里没有画）的长度和斜率需要计算。</p><p style="margin: 0px 0px 1.2em !important;">除了使用 DOM 外，使用 Canvas 绘制也很方便：</p><p style="margin: 0px 0px 1.2em !important;"><a class="">Canvas 实现绘制</a> </p><p style="margin: 0px 0px 1.2em !important;">用 Canvas 实现有两个小细节，第一是要实现响应式，可以用 DOM 构造一个正方形的容器：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none; display: block !important;"><span class="">#container</span> <span class="">{ &nbsp;<br><span class=""><span class=""> &nbsp;position</span>:<span class=""> relative</span></span>; &nbsp;<br><span class=""><span class=""> &nbsp;overflow</span>:<span class=""> hidden</span></span>; &nbsp;<br><span class=""><span class=""> &nbsp;width</span>:<span class=""> <span class="" style="color: rgb(140, 208, 211);">100%</span></span></span>; &nbsp;<br><span class=""><span class=""> &nbsp;padding-top</span>:<span class=""> <span class="" style="color: rgb(140, 208, 211);">100%</span></span></span>; &nbsp;<br><span class=""><span class=""> &nbsp;height</span>:<span class=""> <span class="" style="color: rgb(140, 208, 211);">0px</span></span></span>; &nbsp;<br><span class=""><span class=""> &nbsp;background-color</span>:<span class=""> white</span></span>;<br><span class="">}</span></span></code></pre><p style="margin: 0px 0px 1.2em !important;">在这里我们使用 <code style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border-width: 1px; border-style: solid; border-color: rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;">padding-top:100%</code> 撑开容器高度使它等于容器宽度。</p><p style="margin: 0px 0px 1.2em !important;">第二个细节是为了在 retina 屏上获得清晰的显示效果，我们将 Canvas 的宽高增加一倍，然后通过 <code style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border-width: 1px; border-style: solid; border-color: rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;">transform: scale(0.5)</code> 来缩小到匹配容器宽高。</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none; display: block !important;"><span class="">#container</span> <span class="" style="color: rgb(227, 206, 171);">canvas</span><span class="">{ &nbsp;<br><span class=""><span class=""> &nbsp;position</span>:<span class=""> absolute</span></span>; &nbsp;<br><span class=""><span class=""> &nbsp;left</span>:<span class=""> <span class="" style="color: rgb(140, 208, 211);">50%</span></span></span>; &nbsp;<br><span class=""><span class=""> &nbsp;top</span>:<span class=""> <span class="" style="color: rgb(140, 208, 211);">50%</span></span></span>; &nbsp;<br><span class=""><span class=""> &nbsp;transform</span>:<span class=""> <span class="">translate</span>(-<span class="" style="color: rgb(140, 208, 211);">50%</span>, -<span class="" style="color: rgb(140, 208, 211);">50%</span>) <span class="">scale</span>(<span class="" style="color: rgb(140, 208, 211);">0.5</span>)</span></span>;<br><span class="">}</span></span></code></pre><p style="margin: 0px 0px 1.2em !important;">由于 Canvas 的定位是 absolute，它本身的默认宽高并不等于容器的宽高，需要通过 JS 设置：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none; display: block !important;"><span class="" style="color: rgb(227, 206, 171);">let</span> width = <span class="" style="color: rgb(140, 208, 211);">2</span> * container.getBoundingClientRect().width;
canvas.width = canvas.height = width;</code></pre><p style="margin: 0px 0px 1.2em !important;">这样我们就可以通过在 Canvas 上绘制实心圆和连线来实现 UI 了。具体的方法在后续的内容里有更详细的讲解。</p><p style="margin: 0px 0px 1.2em !important;">最后我们来看一下用 SVG 绘制：</p><p style="margin: 0px 0px 1.2em !important;"><a class="">SVG 实现绘制</a></p><p style="margin: 0px 0px 1.2em !important;">由于 SVG 原生操作的 API 不是很方便，这里使用了 <a>Snap.svg 库</a>，实现起来和使用 Canvas 大同小异，这里就不赘述了。</p><p style="margin: 0px 0px 1.2em !important;">SVG 的问题是移动端兼容性不如 DOM 和 Canvas 好。</p><p style="margin: 0px 0px 1.2em !important;">综合上面三者的情况，最终我选择使用 Canvas 来实现。</p><h3 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.3em;">结构设计</h3><p style="margin: 0px 0px 1.2em !important;">使用 Canvas 实现的话 DOM 结构就比较简单。为了响应式，我们需要实现一个自适应宽度的正方形容器，方法前面已经介绍过。接着在容器中创建 Canvas。这里需要注意的一点是，我们应当把 Canvas 分层。这是因为 Canvas 的渲染机制里，要更新画布的内容，需要刷新要更新的区域重新绘制。因为我们有必要把频繁变化的内容和基本不变的内容分层管理，这样能显著提升性能。</p><h4 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.2em;">分成 3 个图层</h4><p><img src="/gh_ffb279ea1674/images/e078f47549887f88a72ca02629839f265636cc19.png" style="width: 748px !important; height: 708px !important;"></p><p style="margin: 0px 0px 1.2em !important;">在这里我把 UI 分别绘制在 3 个图层里，对应 3 个 Canvas。最上层只有随着手指头移动的那个线段，中间是九个点，最下层是已经绘制好的线。之所以这样分，是因为随手指头移动的那条线需要不断刷新，底下两层都不用频繁更新，但是把连好的线放在最底层是因为我要做出圆点把线的一部分遮挡住的效果。</p><h4 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.2em;">确定圆点的位置</h4><p><img src="/gh_ffb279ea1674/images/da39a0e8465678c4a5dd437b79a2a05f5ddb2c5e.png" style="width: 770px !important; height: 403.176px !important;"></p><p style="margin: 0px 0px 1.2em !important;">圆点的位置有两种定位法，第一种是九个九宫格，圆点在小九宫格的中心位置。如果认真的同学，已经发现在前面 DOM 方案里，我们就是采用这样的方式，圆点的直径为 11.1%。第二种方式是用横竖三条线把宽高四等分，圆点在这些线的交点处。</p><p style="margin: 0px 0px 1.2em !important;">在 Canvas 里我们采用第二种方法来确定圆点（代码里的 n = 3）。</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none; display: block !important;"><span class="" style="color: rgb(227, 206, 171);">let</span> range = <span class="" style="color: rgb(204, 147, 147);">Math</span>.round(width / (n + <span class="" style="color: rgb(140, 208, 211);">1</span>));<br><span class="" style="color: rgb(227, 206, 171);">let</span> circles = [];<span class="" style="color: rgb(127, 159, 127);">//drawCircleCenters<br><br></span><span class="" style="color: rgb(227, 206, 171);">for</span>(<span class="" style="color: rgb(227, 206, 171);">let</span> i = <span class="" style="color: rgb(140, 208, 211);">1</span>; i &lt;= n; i++){ &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;for</span>(<span class="" style="color: rgb(227, 206, 171);">let</span> j = <span class="" style="color: rgb(140, 208, 211);">1</span>; j &lt;= n; j++){ &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;let</span> y = range * i, x = range * j;
 &nbsp; &nbsp;drawSolidCircle(circleCtx, fgColor, x, y, innerRadius); &nbsp; &nbsp;<br><br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;let</span> circlePoint = {x, y};
 &nbsp; &nbsp;circlePoint.pos = [i, j];
 &nbsp; &nbsp;circles.push(circlePoint);
 &nbsp;}
}</code></pre><p style="margin: 0px 0px 1.2em !important;">最后一点，严格说不属于结构设计，但是因为我们的 UI 是通过触屏操作，我们需要考虑 Touch 事件处理和坐标的转换。</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none; display: block !important;"><span class=""><span class="" style="color: rgb(227, 206, 171);">function</span> <span class="" style="color: rgb(239, 239, 143);">getCanvasPoint</span><span class="">(canvas, x, y)</span></span>{ &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;let</span> rect = canvas.getBoundingClientRect(); &nbsp;<span class="" style="color: rgb(227, 206, 171);"><br> &nbsp;return</span> {
 &nbsp; &nbsp;x: <span class="" style="color: rgb(140, 208, 211);">2</span> * (x - rect.left), 
 &nbsp; &nbsp;y: <span class="" style="color: rgb(140, 208, 211);">2</span> * (y - rect.top),
 &nbsp;};
}</code></pre><p style="margin: 0px 0px 1.2em !important;">我们将 Touch 相对于屏幕的坐标转换为 Canvas 相对于画布的坐标。代码里的 2 倍是因为我们前面说了要让 retina 屏下清晰，我们将 Canvas 放大为原来的 2 倍。</p><h3 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.3em;">API 设计</h3><p style="margin: 0px 0px 1.2em !important;">接下来我们需要设计给使用者使用的 API 了。在这里，我们将组件功能分解一下，独立出一个单纯记录手势的 Recorder。将组件功能分解为更加底层的组件，是一种简化组件设计的常用模式。</p><p><img src="/gh_ffb279ea1674/images/05799d8fb583b26a9942ab4faa14ab7611946ffc.png" style="width: 548px !important; height: 750px !important;"></p><p style="margin: 0px 0px 1.2em !important;">我们抽取出底层的 Recorder，让 Locker 继承 Recorder，Recorder 负责记录，Locker 管理实际的设置和验证密码的过程。</p><p style="margin: 0px 0px 1.2em !important;">我们的 Recorder 只负责记录用户行为，由于用户操作是异步操作，我们将它设计为 Promise 规范的 API，它可以以如下方式使用：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none; display: block !important;"><span class="" style="color: rgb(227, 206, 171);">var</span> recorder = <span class="" style="color: rgb(227, 206, 171);">new</span> HandLock.Recorder({
 &nbsp;container: <span class="" style="color: rgb(204, 147, 147);">document</span>.querySelector(<span class="" style="color: rgb(204, 147, 147);">'#main'</span>)
});<br><span class=""><span class="" style="color: rgb(227, 206, 171);">function</span> <span class="" style="color: rgb(239, 239, 143);">recorded</span><span class="">(res)</span></span>{ &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;if</span>(res.err){ &nbsp; &nbsp;<br><span class="" style="color: rgb(204, 147, 147);"> &nbsp; &nbsp;console</span>.error(res.err);
 &nbsp; &nbsp;recorder.clearPath(); &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;if</span>(res.err.message !== HandLock.Recorder.ERR_USER_CANCELED){
 &nbsp; &nbsp; &nbsp;recorder.record().then(recorded);
 &nbsp; &nbsp;}
 &nbsp;}<span class="" style="color: rgb(227, 206, 171);">else</span>{ &nbsp; &nbsp;<br><span class="" style="color: rgb(204, 147, 147);"> &nbsp; &nbsp;console</span>.log(res.records);
 &nbsp; &nbsp;recorder.record().then(recorded);
 &nbsp;} &nbsp; &nbsp; &nbsp;
}

recorder.record().then(recorded);</code></pre><p style="margin: 0px 0px 1.2em !important;">对于输出结果，我们简单用选中圆点的行列坐标拼接起来得到一个唯一的序列。例如 “11121323” 就是如下选择图形：</p><p><img src="/gh_ffb279ea1674/images/7cf8c32af3c136766de8563da178eebae64dab39.png" style="width: 626px !important; height: 576px !important;"></p><p style="margin: 0px 0px 1.2em !important;">为了让 UI 显示具有灵活性，我们还可以将外观配置抽取出来。</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none; display: block !important;"><span class="" style="color: rgb(227, 206, 171);">const</span> defaultOptions = {
 &nbsp;container: <span class="" style="color: rgb(239, 239, 175);">null</span>, <span class="" style="color: rgb(127, 159, 127);">//创建canvas的容器，如果不填，自动在 body 上创建覆盖全屏的层</span>
 &nbsp;focusColor: <span class="" style="color: rgb(204, 147, 147);">'#e06555'</span>, &nbsp;<span class="" style="color: rgb(127, 159, 127);">//当前选中的圆的颜色</span>
 &nbsp;fgColor: <span class="" style="color: rgb(204, 147, 147);">'#d6dae5'</span>, &nbsp; &nbsp; <span class="" style="color: rgb(127, 159, 127);">//未选中的圆的颜色</span>
 &nbsp;bgColor: <span class="" style="color: rgb(204, 147, 147);">'#fff'</span>, &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//canvas背景颜色</span>
 &nbsp;n: <span class="" style="color: rgb(140, 208, 211);">3</span>, <span class="" style="color: rgb(127, 159, 127);">//圆点的数量： n x n</span>
 &nbsp;innerRadius: <span class="" style="color: rgb(140, 208, 211);">20</span>, &nbsp;<span class="" style="color: rgb(127, 159, 127);">//圆点的内半径</span>
 &nbsp;outerRadius: <span class="" style="color: rgb(140, 208, 211);">50</span>, &nbsp;<span class="" style="color: rgb(127, 159, 127);">//圆点的外半径，focus 的时候显示</span>
 &nbsp;touchRadius: <span class="" style="color: rgb(140, 208, 211);">70</span>, &nbsp;<span class="" style="color: rgb(127, 159, 127);">//判定touch事件的圆半径</span>
 &nbsp;render: <span class="" style="color: rgb(239, 239, 175);">true</span>, &nbsp; &nbsp; <span class="" style="color: rgb(127, 159, 127);">//自动渲染</span>
 &nbsp;customStyle: <span class="" style="color: rgb(239, 239, 175);">false</span>, <span class="" style="color: rgb(127, 159, 127);">//自定义样式</span>
 &nbsp;minPoints: <span class="" style="color: rgb(140, 208, 211);">4</span>, &nbsp; &nbsp; <span class="" style="color: rgb(127, 159, 127);">//最小允许的点数<br></span>};</code></pre><p style="margin: 0px 0px 1.2em !important;">这样我们实现完整的 Recorder 对象，核心代码如下：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none; display: block !important;">[...] <span class="" style="color: rgb(127, 159, 127);">//定义一些私有方法<br><br></span><span class="" style="color: rgb(227, 206, 171);">const</span> defaultOptions = {
 &nbsp;container: <span class="" style="color: rgb(239, 239, 175);">null</span>, <span class="" style="color: rgb(127, 159, 127);">//创建canvas的容器，如果不填，自动在 body 上创建覆盖全屏的层</span>
 &nbsp;focusColor: <span class="" style="color: rgb(204, 147, 147);">'#e06555'</span>, &nbsp;<span class="" style="color: rgb(127, 159, 127);">//当前选中的圆的颜色</span>
 &nbsp;fgColor: <span class="" style="color: rgb(204, 147, 147);">'#d6dae5'</span>, &nbsp; &nbsp; <span class="" style="color: rgb(127, 159, 127);">//未选中的圆的颜色</span>
 &nbsp;bgColor: <span class="" style="color: rgb(204, 147, 147);">'#fff'</span>, &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//canvas背景颜色</span>
 &nbsp;n: <span class="" style="color: rgb(140, 208, 211);">3</span>, <span class="" style="color: rgb(127, 159, 127);">//圆点的数量： n x n</span>
 &nbsp;innerRadius: <span class="" style="color: rgb(140, 208, 211);">20</span>, &nbsp;<span class="" style="color: rgb(127, 159, 127);">//圆点的内半径</span>
 &nbsp;outerRadius: <span class="" style="color: rgb(140, 208, 211);">50</span>, &nbsp;<span class="" style="color: rgb(127, 159, 127);">//圆点的外半径，focus 的时候显示</span>
 &nbsp;touchRadius: <span class="" style="color: rgb(140, 208, 211);">70</span>, &nbsp;<span class="" style="color: rgb(127, 159, 127);">//判定touch事件的圆半径</span>
 &nbsp;render: <span class="" style="color: rgb(239, 239, 175);">true</span>, &nbsp; &nbsp; <span class="" style="color: rgb(127, 159, 127);">//自动渲染</span>
 &nbsp;customStyle: <span class="" style="color: rgb(239, 239, 175);">false</span>, <span class="" style="color: rgb(127, 159, 127);">//自定义样式</span>
 &nbsp;minPoints: <span class="" style="color: rgb(140, 208, 211);">4</span>, &nbsp; &nbsp; <span class="" style="color: rgb(127, 159, 127);">//最小允许的点数<br></span>};

export <span class="" style="color: rgb(227, 206, 171);">default</span> <span class="" style="color: rgb(227, 206, 171);">class</span> Recorder{
 &nbsp;static get ERR_NOT_ENOUGH_POINTS(){ &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;return</span> <span class="" style="color: rgb(204, 147, 147);">'not enough points'</span>;
 &nbsp;}
 &nbsp;static get ERR_USER_CANCELED(){ &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;return</span> <span class="" style="color: rgb(204, 147, 147);">'user canceled'</span>;
 &nbsp;}
 &nbsp;static get ERR_NO_TASK(){ &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;return</span> <span class="" style="color: rgb(204, 147, 147);">'no task'</span>;
 &nbsp;}
 &nbsp;constructor(options){
 &nbsp; &nbsp;options = <span class="" style="color: rgb(204, 147, 147);">Object</span>.assign({}, defaultOptions, options); &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;this</span>.options = options; &nbsp; <br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.path = []; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(options.render){ &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.render();
 &nbsp; &nbsp;}
 &nbsp;}
 &nbsp;render(){ &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(<span class="" style="color: rgb(227, 206, 171);">this</span>.circleCanvas) <span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(239, 239, 175);">false</span>; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> options = <span class="" style="color: rgb(227, 206, 171);">this</span>.options; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> container = options.container || <span class="" style="color: rgb(204, 147, 147);">document</span>.createElement(<span class="" style="color: rgb(204, 147, 147);">'div'</span>); &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(!options.container &amp;&amp; !options.customStyle){ &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">Object</span>.assign(container.style, {
 &nbsp; &nbsp; &nbsp; &nbsp;position: <span class="" style="color: rgb(204, 147, 147);">'absolute'</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;top: <span class="" style="color: rgb(140, 208, 211);">0</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;left: <span class="" style="color: rgb(140, 208, 211);">0</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;width: <span class="" style="color: rgb(204, 147, 147);">'100%'</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;height: <span class="" style="color: rgb(204, 147, 147);">'100%'</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;lineHeight: <span class="" style="color: rgb(204, 147, 147);">'100%'</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;overflow: <span class="" style="color: rgb(204, 147, 147);">'hidden'</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;backgroundColor: options.bgColor
 &nbsp; &nbsp; &nbsp;}); &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">document</span>.body.appendChild(container); 
 &nbsp; &nbsp;} &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.container = container; &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> {width, height} = container.getBoundingClientRect(); &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//画圆的 canvas，也是最外层监听事件的 canvas</span>
 &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> circleCanvas = <span class="" style="color: rgb(204, 147, 147);">document</span>.createElement(<span class="" style="color: rgb(204, 147, 147);">'canvas'</span>); 

 &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//2 倍大小，为了支持 retina 屏</span>
 &nbsp; &nbsp;circleCanvas.width = circleCanvas.height = <span class="" style="color: rgb(140, 208, 211);">2</span> * <span class="" style="color: rgb(204, 147, 147);">Math</span>.min(width, height); &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(!options.customStyle){ &nbsp; &nbsp; <br> &nbsp; &nbsp;&nbsp; <span class="" style="color: rgb(204, 147, 147);">Object</span>.assign(circleCanvas.style, {
 &nbsp; &nbsp; &nbsp; &nbsp;position: <span class="" style="color: rgb(204, 147, 147);">'absolute'</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;top: <span class="" style="color: rgb(204, 147, 147);">'50%'</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;left: <span class="" style="color: rgb(204, 147, 147);">'50%'</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;transform: <span class="" style="color: rgb(204, 147, 147);">'translate(-50%, -50%) scale(0.5)'</span>, 
 &nbsp; &nbsp; &nbsp;});
 &nbsp; &nbsp;} &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//画固定线条的 canvas</span>
 &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> lineCanvas = circleCanvas.cloneNode(<span class="" style="color: rgb(239, 239, 175);">true</span>); &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//画不固定线条的 canvas</span>
 &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> moveCanvas = circleCanvas.cloneNode(<span class="" style="color: rgb(239, 239, 175);">true</span>);

 &nbsp; &nbsp;container.appendChild(lineCanvas);
 &nbsp; &nbsp;container.appendChild(moveCanvas);
 &nbsp; &nbsp;container.appendChild(circleCanvas); &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.lineCanvas = lineCanvas; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.moveCanvas = moveCanvas; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.circleCanvas = circleCanvas; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.container.addEventListener(<span class="" style="color: rgb(204, 147, 147);">'touchmove'</span>, 
 &nbsp; &nbsp; &nbsp;evt =&gt; evt.preventDefault(), {passive: <span class="" style="color: rgb(239, 239, 175);">false</span>}); &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.clearPath(); &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(239, 239, 175);">true</span>;
 &nbsp;}
 &nbsp;clearPath(){ &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(!<span class="" style="color: rgb(227, 206, 171);">this</span>.circleCanvas) <span class="" style="color: rgb(227, 206, 171);">this</span>.render(); &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> {circleCanvas, lineCanvas, moveCanvas} = <span class="" style="color: rgb(227, 206, 171);">this</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;circleCtx = circleCanvas.getContext(<span class="" style="color: rgb(204, 147, 147);">'2d'</span>),
 &nbsp; &nbsp; &nbsp; &nbsp;lineCtx = lineCanvas.getContext(<span class="" style="color: rgb(204, 147, 147);">'2d'</span>),
 &nbsp; &nbsp; &nbsp; &nbsp;moveCtx = moveCanvas.getContext(<span class="" style="color: rgb(204, 147, 147);">'2d'</span>),
 &nbsp; &nbsp; &nbsp; &nbsp;width = circleCanvas.width,
 &nbsp; &nbsp; &nbsp; &nbsp;{n, fgColor, innerRadius} = <span class="" style="color: rgb(227, 206, 171);">this</span>.options;

 &nbsp; &nbsp;circleCtx.clearRect(<span class="" style="color: rgb(140, 208, 211);">0</span>, <span class="" style="color: rgb(140, 208, 211);">0</span>, width, width);
 &nbsp; &nbsp;lineCtx.clearRect(<span class="" style="color: rgb(140, 208, 211);">0</span>, <span class="" style="color: rgb(140, 208, 211);">0</span>, width, width);
 &nbsp; &nbsp;moveCtx.clearRect(<span class="" style="color: rgb(140, 208, 211);">0</span>, <span class="" style="color: rgb(140, 208, 211);">0</span>, width, width); &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> range = <span class="" style="color: rgb(204, 147, 147);">Math</span>.round(width / (n + <span class="" style="color: rgb(140, 208, 211);">1</span>)); &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> circles = []; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//drawCircleCenters<br></span>
 &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">for</span>(<span class="" style="color: rgb(227, 206, 171);">let</span> i = <span class="" style="color: rgb(140, 208, 211);">1</span>; i &lt;= n; i++){ &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">for</span>(<span class="" style="color: rgb(227, 206, 171);">let</span> j = <span class="" style="color: rgb(140, 208, 211);">1</span>; j &lt;= n; j++){ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> y = range * i, x = range * j;
 &nbsp; &nbsp; &nbsp; &nbsp;drawSolidCircle(circleCtx, fgColor, x, y, innerRadius); &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> circlePoint = {x, y};
 &nbsp; &nbsp; &nbsp; &nbsp;circlePoint.pos = [i, j];
 &nbsp; &nbsp; &nbsp; &nbsp;circles.push(circlePoint);
 &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.circles = circles;
 &nbsp;}
 &nbsp;async cancel(){ &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(<span class="" style="color: rgb(227, 206, 171);">this</span>.recordingTask){ &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(227, 206, 171);">this</span>.recordingTask.cancel();
 &nbsp; &nbsp;} &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> Promise.resolve({err: <span class="" style="color: rgb(227, 206, 171);">new</span> <span class="" style="color: rgb(204, 147, 147);">Error</span>(Recorder.ERR_NO_TASK)});
 &nbsp;}
 &nbsp;async record(){ &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(<span class="" style="color: rgb(227, 206, 171);">this</span>.recordingTask) <span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(227, 206, 171);">this</span>.recordingTask.promise; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> {circleCanvas, lineCanvas, moveCanvas, options} = <span class="" style="color: rgb(227, 206, 171);">this</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;circleCtx = circleCanvas.getContext(<span class="" style="color: rgb(204, 147, 147);">'2d'</span>),
 &nbsp; &nbsp; &nbsp; &nbsp;lineCtx = lineCanvas.getContext(<span class="" style="color: rgb(204, 147, 147);">'2d'</span>),
 &nbsp; &nbsp; &nbsp; &nbsp;moveCtx = moveCanvas.getContext(<span class="" style="color: rgb(204, 147, 147);">'2d'</span>);

 &nbsp; &nbsp;circleCanvas.addEventListener(<span class="" style="color: rgb(204, 147, 147);">'touchstart'</span>, ()=&gt;{ &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.clearPath();
 &nbsp; &nbsp;}); &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> records = []; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> handler = evt =&gt; { &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> {clientX, clientY} = evt.changedTouches[<span class="" style="color: rgb(140, 208, 211);">0</span>],
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{bgColor, focusColor, innerRadius, outerRadius, touchRadius} = options,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;touchPoint = getCanvasPoint(moveCanvas, clientX, clientY); &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">for</span>(<span class="" style="color: rgb(227, 206, 171);">let</span> i = <span class="" style="color: rgb(140, 208, 211);">0</span>; i &lt; <span class="" style="color: rgb(227, 206, 171);">this</span>.circles.length; i++){ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> point = <span class="" style="color: rgb(227, 206, 171);">this</span>.circles[i],
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x0 = point.x,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y0 = point.y; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(distance(point, touchPoint) &lt; touchRadius){
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;drawSolidCircle(circleCtx, bgColor, x0, y0, outerRadius);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;drawSolidCircle(circleCtx, focusColor, x0, y0, innerRadius);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;drawHollowCircle(circleCtx, focusColor, x0, y0, outerRadius); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(records.length){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> p2 = records[records.length - <span class="" style="color: rgb(140, 208, 211);">1</span>],
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x1 = p2.x,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y1 = p2.y;

 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;drawLine(lineCtx, focusColor, x0, y0, x1, y1);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> circle = <span class="" style="color: rgb(227, 206, 171);">this</span>.circles.splice(i, <span class="" style="color: rgb(140, 208, 211);">1</span>);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;records.push(circle[<span class="" style="color: rgb(140, 208, 211);">0</span>]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">break</span>;
 &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(records.length){ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> point = records[records.length - <span class="" style="color: rgb(140, 208, 211);">1</span>],
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x0 = point.x,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y0 = point.y,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x1 = touchPoint.x,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y1 = touchPoint.y;

 &nbsp; &nbsp; &nbsp; &nbsp;moveCtx.clearRect(<span class="" style="color: rgb(140, 208, 211);">0</span>, <span class="" style="color: rgb(140, 208, 211);">0</span>, moveCanvas.width, moveCanvas.height);
 &nbsp; &nbsp; &nbsp; &nbsp;drawLine(moveCtx, focusColor, x0, y0, x1, y1); &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;};

 &nbsp; &nbsp;circleCanvas.addEventListener(<span class="" style="color: rgb(204, 147, 147);">'touchstart'</span>, handler);
 &nbsp; &nbsp;circleCanvas.addEventListener(<span class="" style="color: rgb(204, 147, 147);">'touchmove'</span>, handler); &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> recordingTask = {}; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> promise = <span class="" style="color: rgb(227, 206, 171);">new</span> Promise((resolve, reject) =&gt; {
 &nbsp; &nbsp; &nbsp;recordingTask.cancel = (res = {}) =&gt; { &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> promise = <span class="" style="color: rgb(227, 206, 171);">this</span>.recordingTask.promise;

 &nbsp; &nbsp; &nbsp; &nbsp;res.err = res.err || <span class="" style="color: rgb(227, 206, 171);">new</span> <span class="" style="color: rgb(204, 147, 147);">Error</span>(Recorder.ERR_USER_CANCELED);
 &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;circleCanvas.removeEventListener(<span class="" style="color: rgb(204, 147, 147);">'touchstart'</span>, handler);
 &nbsp; &nbsp; &nbsp; &nbsp;circleCanvas.removeEventListener(<span class="" style="color: rgb(204, 147, 147);">'touchmove'</span>, handler); &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">document</span>.removeEventListener(<span class="" style="color: rgb(204, 147, 147);">'touchend'</span>, done);<br> &nbsp; &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp; &nbsp;resolve(res); &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.recordingTask = <span class="" style="color: rgb(239, 239, 175);">null</span>; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> promise;
 &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> done = evt =&gt; {
 &nbsp; &nbsp; &nbsp; &nbsp;moveCtx.clearRect(<span class="" style="color: rgb(140, 208, 211);">0</span>, <span class="" style="color: rgb(140, 208, 211);">0</span>, moveCanvas.width, moveCanvas.height); &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(!records.length) <span class="" style="color: rgb(227, 206, 171);">return</span>;

 &nbsp; &nbsp; &nbsp; &nbsp;circleCanvas.removeEventListener(<span class="" style="color: rgb(204, 147, 147);">'touchstart'</span>, handler);
 &nbsp; &nbsp; &nbsp; &nbsp;circleCanvas.removeEventListener(<span class="" style="color: rgb(204, 147, 147);">'touchmove'</span>, handler); &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">document</span>.removeEventListener(<span class="" style="color: rgb(204, 147, 147);">'touchend'</span>, done); &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> err = <span class="" style="color: rgb(239, 239, 175);">null</span>; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(records.length &lt; options.minPoints){
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;err = <span class="" style="color: rgb(227, 206, 171);">new</span> <span class="" style="color: rgb(204, 147, 147);">Error</span>(Recorder.ERR_NOT_ENOUGH_POINTS);
 &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//这里可以选择一些复杂的编码方式，本例子用最简单的直接把坐标转成字符串</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> res = {err, records: records.map(o =&gt; o.pos.join(<span class="" style="color: rgb(204, 147, 147);">''</span>)).join(<span class="" style="color: rgb(204, 147, 147);">''</span>)};

 &nbsp; &nbsp; &nbsp; &nbsp;resolve(res); &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.recordingTask = <span class="" style="color: rgb(239, 239, 175);">null</span>;
 &nbsp; &nbsp; &nbsp;}; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">document</span>.addEventListener(<span class="" style="color: rgb(204, 147, 147);">'touchend'</span>, done);
 &nbsp; &nbsp;});

 &nbsp; &nbsp;recordingTask.promise = promise; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>.recordingTask = recordingTask; &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> promise;
 &nbsp;}
}</code></pre><p style="margin: 0px 0px 1.2em !important;">它的几个公开的方法，recorder 负责记录绘制结果， clearPath 负责在画布上清除上一次记录的结果，cancel 负责终止记录过程，这是为后续流程准备的。</p><h3 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.3em;">流程设计</h3><p style="margin: 0px 0px 1.2em !important;">接下来我们基于 Recorder 来设计设置和验证密码的流程：</p><h4 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.2em;">验证密码</h4><p><img src="/gh_ffb279ea1674/images/fa994e86ef548766d19913390d22547dba9972b8.png" style="width: 770px !important; height: 316.694px !important;"></p><h4 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.2em;">设置密码</h4><p><img src="/gh_ffb279ea1674/images/c3a626488da3e98b0f603b3c671fd915dbf42242.png" style="width: 770px !important; height: 431.2px !important;"></p><p style="margin: 0px 0px 1.2em !important;">有了前面异步 Promise API 的 Recorder，我们不难实现上面的两个流程。</p><p style="margin: 0px 0px 1.2em !important;"><strong>验证密码的内部流程</strong></p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none; display: block !important;">async check(password){ &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;if</span>(<span class="" style="color: rgb(227, 206, 171);">this</span>.mode !== Locker.MODE_CHECK){
 &nbsp; &nbsp;await <span class="" style="color: rgb(227, 206, 171);">this</span>.cancel(); &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;this</span>.mode = Locker.MODE_CHECK;
 &nbsp;} &nbsp;

 &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> checked = <span class="" style="color: rgb(227, 206, 171);">this</span>.options.check.checked; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;let</span> res = await <span class="" style="color: rgb(227, 206, 171);">this</span>.record(); &nbsp;<br><br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;if</span>(res.err &amp;&amp; res.err.message === Locker.ERR_USER_CANCELED){ &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;return</span> Promise.resolve(res);
 &nbsp;} &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(!res.err &amp;&amp; password !== res.records){
 &nbsp; &nbsp;res.err = <span class="" style="color: rgb(227, 206, 171);">new</span> <span class="" style="color: rgb(204, 147, 147);">Error</span>(Locker.ERR_PASSWORD_MISMATCH)
 &nbsp;}

 &nbsp;checked.call(<span class="" style="color: rgb(227, 206, 171);">this</span>, res); &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;this</span>.check(password); &nbsp;<br><br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;return</span> Promise.resolve(res);
}</code></pre><p style="margin: 0px 0px 1.2em !important;"><strong>设置密码的内部流程</strong></p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none; display: block !important;">async update(){ &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;if</span>(<span class="" style="color: rgb(227, 206, 171);">this</span>.mode !== Locker.MODE_UPDATE){
 &nbsp; &nbsp;await <span class="" style="color: rgb(227, 206, 171);">this</span>.cancel(); &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;this</span>.mode = Locker.MODE_UPDATE;
 &nbsp;} &nbsp;<br><br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;let</span> beforeRepeat = <span class="" style="color: rgb(227, 206, 171);">this</span>.options.update.beforeRepeat, 
 &nbsp; &nbsp; &nbsp;afterRepeat = <span class="" style="color: rgb(227, 206, 171);">this</span>.options.update.afterRepeat; &nbsp;<br><br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;let</span> first = await <span class="" style="color: rgb(227, 206, 171);">this</span>.record(); &nbsp;<br><br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;if</span>(first.err &amp;&amp; first.err.message === Locker.ERR_USER_CANCELED){ &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;return</span> Promise.resolve(first);
 &nbsp;} &nbsp;<br><br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;if</span>(first.err){ &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;this</span>.update();
 &nbsp; &nbsp;beforeRepeat.call(<span class="" style="color: rgb(227, 206, 171);">this</span>, first); &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;return</span> Promise.resolve(first); &nbsp; 
 &nbsp;}

 &nbsp;beforeRepeat.call(<span class="" style="color: rgb(227, 206, 171);">this</span>, first); &nbsp;<br><br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;let</span> second = await <span class="" style="color: rgb(227, 206, 171);">this</span>.record(); &nbsp; &nbsp; &nbsp;

 &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(second.err &amp;&amp; second.err.message === Locker.ERR_USER_CANCELED){ &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp;return</span> Promise.resolve(second);
 &nbsp;} &nbsp;<br><br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;if</span>(!second.err &amp;&amp; first.records !== second.records){
 &nbsp; &nbsp;second.err = <span class="" style="color: rgb(227, 206, 171);">new</span> <span class="" style="color: rgb(204, 147, 147);">Error</span>(Locker.ERR_PASSWORD_MISMATCH);
 &nbsp;} &nbsp;<br><br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;this</span>.update();
 &nbsp;afterRepeat.call(<span class="" style="color: rgb(227, 206, 171);">this</span>, second); &nbsp;<br><br><span class="" style="color: rgb(227, 206, 171);"> &nbsp;return</span> Promise.resolve(second);
}</code></pre><p style="margin: 0px 0px 1.2em !important;">可以看到，有了 Recorder 之后，Locker 的验证和设置密码基本上就是顺着流程用 async/await 写下来就行了。</p><h3 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.3em;">细节问题</h3><p style="margin: 0px 0px 1.2em !important;">实际手机触屏时，如果上下拖动，浏览器有默认行为，会导致页面上下移动，需要阻止 touchmove 的默认事件。</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none; display: block !important;"><span class="" style="color: rgb(227, 206, 171);">this</span>.container.addEventListener(<span class="" style="color: rgb(204, 147, 147);">'touchmove'</span>, 
 &nbsp; &nbsp; &nbsp;evt =&gt; evt.preventDefault(), {passive: <span class="" style="color: rgb(239, 239, 175);">false</span>});</code></pre><p style="margin: 0px 0px 1.2em !important;">这里仍然需要注意的一点是， touchmove 事件在 chrome 下默认是一个 <a>Passive Event</a>，因此 addEventListener 的时候需要传参 {passive: false}，否则的话不能 preventDefault。</p><h3 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.3em;">工具 &amp; 工程化</h3><p style="margin: 0px 0px 1.2em !important;">因为我们的代码使用了 ES6+，所以需要引入 babel 编译，我们的组件也使用 webpack 进行打包，以便于使用者在浏览器中直接引入。</p><p style="margin: 0px 0px 1.2em !important;">这方面的内容，在之前的博客里<a>有介绍</a>，这里就不再一一说明。</p><p style="margin: 0px 0px 1.2em !important;">最后，具体的代码可以直接查看 <a>GitHub 工程</a>。</p><h2 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.4em; border-bottom: 1px solid rgb(238, 238, 238);">总结</h2><p style="margin: 0px 0px 1.2em !important;">以上就是今天要讲的全部内容，这里面有几个点我想再强调一下：</p><ol style="margin: 1.2em 0px;padding-left: 2em;" class="list-paddingleft-2"><li><p>在设计 API 的时候思考真正的需求，判断什么该开放、什么该封装</p></li><li><p>做好技术调研和核心方案研究，选择合适的方案</p></li><li><p>优化和解决细节问题</p></li></ol><p style="margin: 0px 0px 1.2em !important;">最后，如有任何问题，欢迎大家在下方评论区探讨。</p>
{% endraw  %}

