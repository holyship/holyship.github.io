---
title: 要成为高级前端工程师，你需要掌握10种设计模式
author: 奇舞小编
date: '2017-03-22 00:00:00 +0000'

---

{% raw  %}
<p>上周末月影大大给奇舞特训营的学生们进行了培训，总结了使用原生 JavaScript 写常用 UI 组件时的 10 种设计模式。分别是：<br></p><p><strong><br></strong></p><p></p><p><img src="/gh_ffb279ea1674/images/5166a193d86b5b6d9ae51be102573ce6d41e4dde.png" style="width: 770px !important; height: 402.967px !important; visibility: visible !important;"></p><p><strong>模式1：Behavior</strong><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p>从交互需求出发设计一组“动作行为”<br></p></li><li><p>在主体对象上应用和扩展这些行为</p></li></ul><p>这是用来抽象页面上多个元素实例的共同行为的常用模式。</p><p><img src="/gh_ffb279ea1674/images/a7e09cf38a3403ab771f26b9702657c4dbfaaaab.jpeg" style="width: 504px !important; height: 281px !important; visibility: visible !important;"></p><p><strong>模式2：Adapter</strong></p><p></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p>针对不同底层实现提供统一的外部接口</p></li><li><p>让业务层面的代码可以适应不同的底层实现</p></li></ul><p>这是实现适配和兼容性时常用的模式。</p><p><img src="/gh_ffb279ea1674/images/a93780a3256d8aff21cbe13d6bfdaeb4e6349cfc.png" style="width: 512px !important; height: 512px !important;"></p><p><strong>模式3：Observer</strong></p><p></p><ul class="list-paddingleft-2"><li><p>同步多个对象的状态变化</p></li><li><p>解耦各个对象之间的依赖</p></li></ul><p>这是让各个组件之间进行通讯的设计模式</p><p><img src="/gh_ffb279ea1674/images/52778bac3651218af84d76697e053d5708e228d0.png" style="width: 700px !important; height: 526px !important;"></p><p><strong>模式4：Mediator</strong></p><p></p><ul class="list-paddingleft-2"><li><p>将命令传递给所有订阅者</p></li><li><p>与所有订阅者之间维持依赖关系</p></li><li><p>从而让订阅者彼此之间相互独立</p></li></ul><p>这是让各个组件保持解耦又能够彼此通信的设计模式</p><p></p><p><img src="/gh_ffb279ea1674/images/a62eb77e2016aa79c0823e64cb8b89dd805f9d8f.png" style="width: 441px !important; height: 345px !important;"></p><p><strong>模式5：Composit</strong><br></p><p></p><ul class="list-paddingleft-2"><li><p>对已有组件/库/功能的组合使用</p></li><li><p>提升代码复用性的最常用手段</p></li></ul><p>这是通过使用模式3、4以及其他方式将各个组件组合成新的高级组件的模式</p><p><img src="/gh_ffb279ea1674/images/6e66bff8f3b37c988e4fb6d20dc7ba60a469795c.png" style="width: 308px !important; height: 204px !important;"></p><p><strong>模式6：Partial Application</strong><br></p><p></p><ul class="list-paddingleft-2"><li><p>Function.prototype.bind</p></li><li><p>部分应用/固化参数</p></li></ul><p>这是一种简化组件接口API的设计模式</p><p><img src="/gh_ffb279ea1674/images/1fe5f4cb9919f01484e77bae09ba8c1579840aa0.jpeg" style="width: 225px !important; height: 225px !important;"></p><p><strong>模式7：Decorate</strong><br></p><p></p><ul class="list-paddingleft-2"><li><p>在原有 API 基础上增加额外的功能</p></li><li><p>不改变底层库的基础上扩展功能的一种模式</p></li></ul><p>使用装饰器模式在不修改核心代码的基础上扩展库的功能</p><p><img src="/gh_ffb279ea1674/images/9f9e0b8a8d242ad6f99a7216ffb28678e3aa0cd0.png" style="width: 578px !important; height: 205px !important;"></p><p><strong>模式8：Proxy</strong></p><ul class="list-paddingleft-2"><li><p>保持原有 API 功能不变，改变执行过程和结果</p></li><li><p>不改变底层库的基础上获得不同执行结果的手段</p></li></ul><p>在模拟后端服务和PC模拟touch事件等等常见场合，这一模式相当有用</p><p><img src="/gh_ffb279ea1674/images/26fd7ab3aa193e7227d9d42c61fe47c952cb3c9d.png" style="width: 674px !important; height: 391px !important;"></p><p><strong>模式9：Aspect</strong></p><ul class="list-paddingleft-2"><li><p>对代码执行的过程进行监测和修改</p></li><li><p>不改变代码主体执行流程的基础上控制执行过程</p></li></ul><p>这个模式构造切面和面向切面编程。</p><p><img src="/gh_ffb279ea1674/images/57a9d87fde5c180aa476177ada4c3af761a26973.jpeg" style="width: 303px !important; height: 166px !important;"></p><p><strong>模式10：Lazyload</strong></p><p></p><ul class="list-paddingleft-2"><li><p>一些加载耗时的资源进行分段、异步加载</p></li><li><p>前端提升性能，减少响应用户的时间</p></li><li><p>某些情况下减少网页流量和带宽消耗</p></li></ul><p>通过懒加载的方式减少用户响应时间。</p><p><br></p><p><span style="font-size: 18px;">以上 10 种设计模式的更详细讲解请点击下方<span style="font-size: 18px; color: rgb(0, 82, 255);">【阅读原文】<span style="font-size: 18px; color: rgb(0, 0, 0);">查看详细内容</span></span></span></p>
{% endraw  %}

