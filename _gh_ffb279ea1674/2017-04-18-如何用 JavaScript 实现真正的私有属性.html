---
title: 如何用 JavaScript 实现真正的私有属性
author: 月影
date: '2017-04-18 00:00:00 +0000'

---

{% raw  %}
<p><img src="/gh_ffb279ea1674/images/ac023e54459ca1fba8d48074047def5914e0e873.jpeg" style="width: auto !important; height: auto !important; visibility: visible !important;"></p><p style="margin: 0px 0px 1.2em !important;">大家都知道 JavaScript 的对象属性默认是可以被从外部访问和修改的，也就是说，JavaScript 本身不存在完全“私有”的对象属性。例如：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;"><span class="" style="color: rgb(227, 206, 171);">class</span> Point{
 &nbsp; &nbsp;constructor(x, y){<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>._x = x;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>._y = y;
 &nbsp; &nbsp;}
 &nbsp; &nbsp;get length(){<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">const</span> {_x, _y} = <span class="" style="color: rgb(227, 206, 171);">this</span>;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(204, 147, 147);">Math</span>.sqrt(_x * _x + _y * _y);
 &nbsp; &nbsp;}
}<br><span class="" style="color: rgb(227, 206, 171);"><br>let</span> p = <span class="" style="color: rgb(227, 206, 171);">new</span> Point(<span class="" style="color: rgb(140, 208, 211);">3</span>, <span class="" style="color: rgb(140, 208, 211);">4</span>);<br><span class="" style="color: rgb(204, 147, 147);">console</span>.log(p._x, p._y, p.length); <span class="" style="color: rgb(127, 159, 127);">//3, 4, 5</span></code></pre><p style="margin: 0px 0px 1.2em !important;">在上面的代码里，我们<strong>约定俗成</strong>地用下划线开头来表示私有变量。我们希望 _x、_y 不被外部访问，然而，这只是我们一厢情愿，使用者还是可以访问到这两个变量。</p><p style="margin: 0px 0px 1.2em !important;">在这里，我们不讨论 ES 的 <a>private 标准提案</a>，而是讨论如何使用工具来将约定变成真正的私有。</p><h2 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.4em; border-bottom: 1px solid rgb(238, 238, 238);">使用 Symbol 来构造私有数据</h2><p style="margin: 0px 0px 1.2em !important;">ES6 提供了一个新的数据类型叫做 <a>Symbol</a>，Symbol 有<a>许多用途</a>，其中一个用途是可以用来生成唯一 key，用作属性标识，我们利用它可以实现真正的私有属性：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;"><span class="" style="color: rgb(227, 206, 171);">const</span> [_x, _y] = [Symbol(<span class="" style="color: rgb(204, 147, 147);">'_x'</span>), Symbol(<span class="" style="color: rgb(204, 147, 147);">'_y'</span>)];<br><span class="" style="color: rgb(227, 206, 171);">class</span> Point{
 &nbsp; &nbsp;constructor(x, y){<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp; &nbsp; &nbsp;this</span>[_x] = x;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>[_y] = y;
 &nbsp; &nbsp;}
 &nbsp; &nbsp;get length(){<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">const</span> x = <span class="" style="color: rgb(227, 206, 171);">this</span>[_x], <br> &nbsp; &nbsp; &nbsp; &nbsp;y = <span class="" style="color: rgb(227, 206, 171);">this</span>[_y];<br> &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(204, 147, 147);">Math</span>.sqrt(x * x + y * y);
 &nbsp; &nbsp;}
}<br><span class="" style="color: rgb(227, 206, 171);"><br>let</span> p = <span class="" style="color: rgb(227, 206, 171);">new</span> Point(<span class="" style="color: rgb(140, 208, 211);">3</span>, <span class="" style="color: rgb(140, 208, 211);">4</span>);<br><span class="" style="color: rgb(204, 147, 147);">console</span>.log(p._x, p._y, p.length); <span class="" style="color: rgb(127, 159, 127);">//undefined, undefined, 5</span></code></pre><p style="margin: 0px 0px 1.2em !important;">我们改写上一版的代码，用 Symbol 的 _x、_y 代替字符串来作为 key，这样，外部 p 访问 _x、_y 属性就访问不到了，这样我们就真正实现了对象数据的私有。</p><p style="margin: 0px 0px 1.2em !important;">上面这种用法并不复杂，但是，如果我们每次定义对象都这么去写还是显得麻烦。因此，我们可以考虑让编译器去做这件事情，自动将下划线开头的属性编译成私有属性。</p><h2 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.4em; border-bottom: 1px solid rgb(238, 238, 238);">使用 Babel 插件来实现属性的默认私有</h2><p style="margin: 0px 0px 1.2em !important;">在这里，我们可以开发 <a>Babel 的插件</a>来实现。Babel 的原理在博客之前的文章中有<a>介绍</a>。还有使用 Babel 插件来进行测试覆盖度检查的<a>例子</a>。如果对于 Babel 不熟悉的同学，可以回顾一下之前的文章。</p><p style="margin: 0px 0px 1.2em !important;">首先，我们分析一下要处理的 AST 部分。ES6 的 class 有两种 node 类型，一种是 ClassDeclaration，另一种是 ClassExpression。它们比较类似，但是在一些细节上又有区别。比如 ReturnStatement 之后可以跟 ClassExpression 但是不能跟 ClassDeclaration。</p><p style="margin: 0px 0px 1.2em !important;"><em>ClassDeclaration 与 ClassExpression</em></p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;"><span class="" style="color: rgb(127, 159, 127);">//ClassDeclaration<br></span><span class="" style="color: rgb(227, 206, 171);">class</span> Foo{<br> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//...<br></span>}<br><br><span class="" style="color: rgb(127, 159, 127);">//classExpression<br></span><span class="" style="color: rgb(227, 206, 171);">const</span> Bar = <span class="" style="color: rgb(227, 206, 171);">class</span> MyClass{<br> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//...<br></span>}</code></pre><p style="margin: 0px 0px 1.2em !important;">对这两种 node，如果其中有下划线开头的属性，可以分别编译成如下形式：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;">const Foo = function(){
 &nbsp;[...fields] = [...Symbol(...)]
 &nbsp;class Foo {
 &nbsp; &nbsp;//...
 &nbsp;}
 &nbsp;return Foo;
}();

const Bar = function(){
 &nbsp;[...fields] = [...Symbol(...)]
 &nbsp;return class MyClass{
 &nbsp; &nbsp;//...
 &nbsp;}
}();</code></pre><p style="margin: 0px 0px 1.2em !important;">此外，还需要考虑 ES Modules 的情况：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;">export <span class="" style="color: rgb(227, 206, 171);">class</span> Foo{ &nbsp;<br><span class="" style="color: rgb(127, 159, 127);"> &nbsp; &nbsp;//...<br></span>}</code></pre><p style="margin: 0px 0px 1.2em !important;">对应为：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;">export <span class="" style="color: rgb(227, 206, 171);">const</span> Foo = <span class=""><span class="" style="color: rgb(227, 206, 171);">function</span><span class="">()</span></span>{ &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//...<br></span>}();</code></pre><p style="margin: 0px 0px 1.2em !important;">上面的形式没有问题。但是如果：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;">export <span class="" style="color: rgb(227, 206, 171);">default</span> <span class="" style="color: rgb(227, 206, 171);">class</span> Foo{<br> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//...<br></span>}</code></pre><p style="margin: 0px 0px 1.2em !important;">对应为：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;">export <span class="" style="color: rgb(227, 206, 171);">default</span> <span class="" style="color: rgb(227, 206, 171);">const</span> Foo = <span class=""><span class="" style="color: rgb(227, 206, 171);">function</span><span class="">()</span></span>{<br> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//...<br></span>}();</code></pre><p style="margin: 0px 0px 1.2em !important;">编译会报错。因此要进行修改，对应成：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;"><span class="" style="color: rgb(227, 206, 171);">const</span> Foo = <span class=""><span class="" style="color: rgb(227, 206, 171);">function</span><span class="">()</span></span>{<br> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//...<br></span>}();<br>export <span class="" style="color: rgb(227, 206, 171);">default</span> Foo;</code></pre><p style="margin: 0px 0px 1.2em !important;">由于 Class 允许存在嵌套，因此，我们需要使用堆栈结构，在 AST 的 enter 的时候创建存放当前 Class 的 scope 下的私有属性列表。堆栈还有一个作用，就是如果堆栈为空，那么当前作用域不在 Class 内部，不用进行编译转换。</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;"> &nbsp; &nbsp;ClassDeclaration: {
 &nbsp; &nbsp; &nbsp;exit(path){ &nbsp; &nbsp; &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);"> &nbsp; &nbsp; &nbsp; &nbsp;let</span> expr = transformWrapClass(path.node); &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(!expr) <span class="" style="color: rgb(227, 206, 171);">return</span>; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(path.parentPath.node.type === <span class="" style="color: rgb(204, 147, 147);">'ExportDefaultDeclaration'</span>){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//处理 export default 的特殊情况</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;path.parentPath.insertAfter(t.exportDefaultDeclaration(
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t.identifier(path.node.id.name)
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;));
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;path.parentPath.replaceWith(expr);
 &nbsp; &nbsp; &nbsp; &nbsp;}<span class="" style="color: rgb(227, 206, 171);">else</span>{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//替换掉当前 path</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;path.replaceWith(expr);
 &nbsp; &nbsp; &nbsp; &nbsp;}

 &nbsp; &nbsp; &nbsp; &nbsp;path.skip();
 &nbsp; &nbsp; &nbsp;},
 &nbsp; &nbsp; &nbsp;enter(path, state){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(127, 159, 127);">//创建存放私有变量标识符的堆栈</span>
 &nbsp; &nbsp; &nbsp; &nbsp;stack.push({
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;variables: <span class="" style="color: rgb(227, 206, 171);">new</span> Set()
 &nbsp; &nbsp; &nbsp; &nbsp;});
 &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;},
 &nbsp; &nbsp;ClassExpression: {
 &nbsp; &nbsp; &nbsp;exit(path){ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> expr = transformWrapClass(path.node); &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(!expr) <span class="" style="color: rgb(227, 206, 171);">return</span>; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//ClassExpression 可以直接 export default</span>
 &nbsp; &nbsp; &nbsp; &nbsp;path.replaceWith(expr);

 &nbsp; &nbsp; &nbsp; &nbsp;path.skip();
 &nbsp; &nbsp; &nbsp;}, &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp; &nbsp;enter(path, state){
 &nbsp; &nbsp; &nbsp; &nbsp;stack.push({
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;variables: <span class="" style="color: rgb(227, 206, 171);">new</span> Set()
 &nbsp; &nbsp; &nbsp; &nbsp;});
 &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp;
 &nbsp; &nbsp;}</code></pre><p style="margin: 0px 0px 1.2em !important;">接下来，我们处理具体的 Identifier：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;"> &nbsp; &nbsp;Identifier(path, state) { &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(stack.length &lt;= <span class="" style="color: rgb(140, 208, 211);">0</span>) <span class="" style="color: rgb(227, 206, 171);">return</span>; <span class="" style="color: rgb(127, 159, 127);">//不在 class 作用域内，直接返回 </span>
 &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(<span class="">/^__.*__$/</span>.test(path.node.name)) <span class="" style="color: rgb(227, 206, 171);">return</span>; <span class="" style="color: rgb(127, 159, 127);">//系统保留属性，比如 __proto__</span>

 &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> node = path.node,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;parentNode = path.parentPath.node,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;meta = stack[stack.length - <span class="" style="color: rgb(140, 208, 211);">1</span>]; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> regExp = <span class="" style="color: rgb(227, 206, 171);">new</span> <span class="" style="color: rgb(204, 147, 147);">RegExp</span>(state.opts.pattern || <span class="" style="color: rgb(204, 147, 147);">'^_'</span>); &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//给属性名增加前缀后缀，避免内部使用时出现重名</span>
 &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//比如应当允许 let _x = this._x;</span>
 &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> symbolName = <span class="" style="color: rgb(204, 147, 147);">'$'</span> + node.name + <span class="" style="color: rgb(204, 147, 147);">'$'</span>; 

 &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(parentNode 
 &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; parentNode.type === <span class="" style="color: rgb(204, 147, 147);">'MemberExpression'</span> 
 &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; parentNode.object.type === <span class="" style="color: rgb(204, 147, 147);">'ThisExpression'</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !parentNode.computed
 &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; regExp.test(node.name)){ <span class="" style="color: rgb(127, 159, 127);">//private</span>

 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//对于私有属性的读写 this._x，直接替换成 this[_x]</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//并且记录下当前变量标识符，添加到栈顶的 Set 中去</span>
 &nbsp; &nbsp; &nbsp; &nbsp;node.name = symbolName;
 &nbsp; &nbsp; &nbsp; &nbsp;meta.variables.add(node.name);
 &nbsp; &nbsp; &nbsp; &nbsp;parentNode.computed = <span class="" style="color: rgb(239, 239, 175);">true</span>;
 &nbsp; &nbsp; &nbsp;}<span class="" style="color: rgb(227, 206, 171);">else</span> <span class="" style="color: rgb(227, 206, 171);">if</span>(parentNode 
 &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; parentNode.type === <span class="" style="color: rgb(204, 147, 147);">'MemberExpression'</span> 
 &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; parentNode.object.type === <span class="" style="color: rgb(204, 147, 147);">'Super'</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !parentNode.computed
 &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; regExp.test(node.name)){ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//使用 super._x 访问父元素的属性，进行一个变换</span>
 &nbsp; &nbsp; &nbsp; &nbsp;node.name = symbolName;
 &nbsp; &nbsp; &nbsp; &nbsp;parentNode.computed = <span class="" style="color: rgb(239, 239, 175);">true</span>; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> expr = transformPropertyToSymbol(node.name);
 &nbsp; &nbsp; &nbsp; &nbsp;path.replaceWith(expr);
 &nbsp; &nbsp; &nbsp; &nbsp;path.skip();
 &nbsp; &nbsp; &nbsp;}<span class="" style="color: rgb(227, 206, 171);">else</span> <span class="" style="color: rgb(227, 206, 171);">if</span>(parentNode 
 &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; parentNode.type === <span class="" style="color: rgb(204, 147, 147);">'ClassMethod'</span> 
 &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; regExp.test(node.name)){ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//处理 class 的方法和 getter、setter 名带下划线的情况。</span>
 &nbsp; &nbsp; &nbsp; &nbsp;node.name = symbolName;
 &nbsp; &nbsp; &nbsp; &nbsp;meta.variables.add(node.name);
 &nbsp; &nbsp; &nbsp; &nbsp;parentNode.computed = <span class="" style="color: rgb(239, 239, 175);">true</span>;
 &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;},</code></pre><h3 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.3em;">Protected 的属性和 super._x 操作</h3><p style="margin: 0px 0px 1.2em !important;">对于对象方法带下划线的情况，和 this 带下划线不同，我们是可以使用 super.属性名 来访问的。比如：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;"><span class="" style="color: rgb(227, 206, 171);">class</span> Foo{
 &nbsp; &nbsp;constructor(x) { &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>._x = x;
 &nbsp; &nbsp;} &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//这是一个 protected 的属性，在派生类中可以通过 super._X 访问</span>
 &nbsp; &nbsp;get _X(){ &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(227, 206, 171);">this</span>._x;
 &nbsp; &nbsp;}
}<br><span class="" style="color: rgb(227, 206, 171);">class</span> Bar extends Foo{
 &nbsp;constructor(x, y){
 &nbsp; &nbsp; &nbsp;super(x); &nbsp; &nbsp; <br> &nbsp; &nbsp;&nbsp; <span class="" style="color: rgb(227, 206, 171);">this</span>._y = y;
 &nbsp;}
 &nbsp;get XY(){ &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp;&nbsp; <span class="" style="color: rgb(227, 206, 171);">return</span> [super._X, <span class="" style="color: rgb(227, 206, 171);">this</span>._y];
 &nbsp;}
}<br><span class="" style="color: rgb(227, 206, 171);">let</span> bar = <span class="" style="color: rgb(227, 206, 171);">new</span> Bar(<span class="" style="color: rgb(140, 208, 211);">3</span>, <span class="" style="color: rgb(140, 208, 211);">4</span>);<br><span class="" style="color: rgb(204, 147, 147);">console</span>.log(bar.XY); <span class="" style="color: rgb(127, 159, 127);">//[3, 4]</span></code></pre><p style="margin: 0px 0px 1.2em !important;">在这里，我们需要对 super._X 进行处理，如果直接编译：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;"><span class="" style="color: rgb(227, 206, 171);">const</span> Foo = <span class=""><span class="" style="color: rgb(227, 206, 171);">function</span><span class="">()</span></span>{ &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">const</span> [$_x$, $_X$] = [Symbol(<span class="" style="color: rgb(204, 147, 147);">'$_x$'</span>), Symbol(<span class="" style="color: rgb(204, 147, 147);">'$_X$'</span>)]; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">class</span> Foo{
 &nbsp; &nbsp; &nbsp; &nbsp;constructor(x) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>[$_x$] = x;
 &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//这是一个 protected 的属性，在派生类中可以通过 super._X 访问</span>
 &nbsp; &nbsp; &nbsp; &nbsp;get [$_X$](){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(227, 206, 171);">this</span>[$_x$];
 &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;} &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> Foo;
}();<br><span class="" style="color: rgb(227, 206, 171);">const</span> Bar = <span class=""><span class="" style="color: rgb(227, 206, 171);">function</span><span class="">()</span></span>{ &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">const</span> [$_y$, $_X$] = [Symbol(<span class="" style="color: rgb(204, 147, 147);">'$_y$'</span>), Symbol(<span class="" style="color: rgb(204, 147, 147);">'$_X$'</span>)]; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">class</span> Bar extends Foo{
 &nbsp; &nbsp; &nbsp;constructor(x, y){
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;super(x); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>[$_y$] = y;
 &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp; &nbsp;get XY(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> [super[$_X$], <span class="" style="color: rgb(227, 206, 171);">this</span>[$_y$]];
 &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;} &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> Bar;
}();<br><span class="" style="color: rgb(227, 206, 171);"><br>let</span> bar = <span class="" style="color: rgb(227, 206, 171);">new</span> Bar(<span class="" style="color: rgb(140, 208, 211);">3</span>, <span class="" style="color: rgb(140, 208, 211);">4</span>);<br><span class="" style="color: rgb(204, 147, 147);">console</span>.log(bar.XY); <span class="" style="color: rgb(127, 159, 127);">//[undefined, 4]</span></code></pre><p style="margin: 0px 0px 1.2em !important;">由于每个 Symbol 都是唯一的，所以 Bar 的 Symbol('$_X$') 和 Foo 的并不相同，这样也就获取不到 super['$_X$'] 实际的值了。</p><p style="margin: 0px 0px 1.2em !important;">因此，在这里，我们编译的时候不能直接这样转成 Symbol，而是要通过反射机制去处理：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;"><span class="" style="color: rgb(227, 206, 171);">const</span> Foo = <span class=""><span class="" style="color: rgb(227, 206, 171);">function</span><span class="">()</span></span>{ &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">const</span> [$_x$, $_X$] = [Symbol(<span class="" style="color: rgb(204, 147, 147);">'$_x$'</span>), Symbol(<span class="" style="color: rgb(204, 147, 147);">'$_X$'</span>)]; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">class</span> Foo{
 &nbsp; &nbsp; &nbsp; &nbsp;constructor(x) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>[$_x$] = x;
 &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//这是一个 protected 的属性，在派生类中可以通过 super._X 访问</span>
 &nbsp; &nbsp; &nbsp; &nbsp;get [$_X$](){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(227, 206, 171);">this</span>[$_x$];
 &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;} &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> Foo;
}();<br><span class="" style="color: rgb(227, 206, 171);"><br>const</span> Bar = <span class=""><span class="" style="color: rgb(227, 206, 171);">function</span><span class="">()</span></span>{ &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">const</span> [$_y$] = [Symbol(<span class="" style="color: rgb(204, 147, 147);">'$_y$'</span>)]; &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">class</span> Bar extends Foo{
 &nbsp; &nbsp; &nbsp;constructor(x, y){
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;super(x); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">this</span>[$_y$] = y;
 &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp; &nbsp;get XY(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> [super[<span class="" style="color: rgb(204, 147, 147);">Object</span>.getOwnPropertySymbols(<span class="" style="color: rgb(227, 206, 171);">this</span>.__proto__.__proto__).filter(s =&gt; <span class="" style="color: rgb(204, 147, 147);">String</span>(s) === <span class="" style="color: rgb(204, 147, 147);">"Symbol($_X$)"</span>)[<span class="" style="color: rgb(140, 208, 211);">0</span>]], <span class="" style="color: rgb(227, 206, 171);">this</span>[$_y$]];
 &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;} &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> Bar;
}();<br> &nbsp; &nbsp;<br><span class="" style="color: rgb(227, 206, 171);">let</span> bar = <span class="" style="color: rgb(227, 206, 171);">new</span> Bar(<span class="" style="color: rgb(140, 208, 211);">3</span>, <span class="" style="color: rgb(140, 208, 211);">4</span>);<br><span class="" style="color: rgb(204, 147, 147);">console</span>.log(bar.XY); <span class="" style="color: rgb(127, 159, 127);">//[3, 4]</span></code></pre><p style="margin: 0px 0px 1.2em !important;">上面的 super 里的 key 有一大串，是：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;"><span class="" style="color: rgb(204, 147, 147);">Object</span>.getOwnPropertySymbols(<span class="" style="color: rgb(227, 206, 171);">this</span>.__proto__.__proto__)
 &nbsp; &nbsp;.filter(s =&gt; <span class="" style="color: rgb(204, 147, 147);">String</span>(s) === <span class="" style="color: rgb(204, 147, 147);">"Symbol($_X$)"</span>)[<span class="" style="color: rgb(140, 208, 211);">0</span>]</code></pre><p style="margin: 0px 0px 1.2em !important;">这里通过 <code style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;">Object.getOwnPropertySymbols(this.__proto__.__proto__)</code> 反射出父类的 Symbol，然后通过字符串匹配到对应的 key。</p><p style="margin: 0px 0px 1.2em !important;">于是，我们确定了转换方法，那么接下来就只是实现具体的转换细节了：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;"> &nbsp;<span class=""><span class="" style="color: rgb(227, 206, 171);">function</span> <span class="" style="color: rgb(239, 239, 143);">transformCreateSymbols</span><span class="">()</span></span>{ &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> meta = stack.pop(),
 &nbsp; &nbsp; &nbsp; &nbsp;variableNames = <span class="" style="color: rgb(204, 147, 147);">Array</span>.from(meta.variables); &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">//no private variables</span>
 &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(variableNames.length &lt;= <span class="" style="color: rgb(140, 208, 211);">0</span>) <span class="" style="color: rgb(227, 206, 171);">return</span>; &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> identifiers = variableNames.map(id =&gt; t.identifier(id)); &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> pattern = t.arrayPattern(identifiers); &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> symbols = variableNames.map(id =&gt; &nbsp;
 &nbsp; &nbsp; &nbsp;t.callExpression(t.identifier(<span class="" style="color: rgb(204, 147, 147);">'Symbol'</span>), [t.stringLiteral(id)]));

 &nbsp; &nbsp;symbols = t.arrayExpression(symbols); &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> t.variableDeclaration( &nbsp; &nbsp; <br> &nbsp; &nbsp;&nbsp; <span class="" style="color: rgb(204, 147, 147);">'const'</span>,
 &nbsp; &nbsp; &nbsp;[t.variableDeclarator(pattern, symbols)]
 &nbsp; &nbsp;); &nbsp;
 &nbsp;} &nbsp;<br> &nbsp;<br> &nbsp;<span class=""><span class="" style="color: rgb(227, 206, 171);">function</span> <span class="" style="color: rgb(239, 239, 143);">transformWrapClass</span><span class="">(cls)</span></span>{ &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> symbols = transformCreateSymbols(); &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(!symbols) <span class="" style="color: rgb(227, 206, 171);">return</span>; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span>(cls.type === <span class="" style="color: rgb(204, 147, 147);">'ClassDeclaration'</span>){ &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(227, 206, 171);">let</span> expr = t.callExpression(
 &nbsp; &nbsp; &nbsp; &nbsp;t.functionExpression(<span class="" style="color: rgb(239, 239, 175);">null</span>, [], 
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t.blockStatement(
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[symbols,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cls,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t.returnStatement(
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t.identifier(cls.id.name)
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )]
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)
 &nbsp; &nbsp; &nbsp; &nbsp;), []
 &nbsp; &nbsp; &nbsp;); &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(227, 206, 171);">return</span> t.variableDeclaration( &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">'const'</span>,
 &nbsp; &nbsp; &nbsp; &nbsp;[t.variableDeclarator(
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t.identifier(cls.id.name),
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;expr
 &nbsp; &nbsp; &nbsp; &nbsp;)]
 &nbsp; &nbsp; &nbsp;);
 &nbsp; &nbsp;}<span class="" style="color: rgb(227, 206, 171);">else</span> <span class="" style="color: rgb(227, 206, 171);">if</span>(cls.type === <span class="" style="color: rgb(204, 147, 147);">'ClassExpression'</span>){ &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> t.callExpression(
 &nbsp; &nbsp; &nbsp; &nbsp;t.functionExpression(<span class="" style="color: rgb(239, 239, 175);">null</span>, [], 
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t.blockStatement(
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[symbols,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t.returnStatement(
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cls
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )]
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)
 &nbsp; &nbsp; &nbsp; &nbsp;), []
 &nbsp; &nbsp; &nbsp;);
 &nbsp; &nbsp;}
 &nbsp;}</code></pre><p style="margin: 0px 0px 1.2em !important;">上面的方法将 ClassDeclaration 和 ClassExpression 处理完成。接下来是处理 super 属性的部分：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;"> &nbsp;<span class=""><span class="" style="color: rgb(227, 206, 171);">function</span> <span class="" style="color: rgb(239, 239, 143);">transformPropertyToSymbol</span><span class="">(name)</span></span>{ &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">let</span> expr = t.callExpression(
 &nbsp; &nbsp; &nbsp;t.memberExpression(
 &nbsp; &nbsp; &nbsp; &nbsp;t.identifier(<span class="" style="color: rgb(204, 147, 147);">'Object'</span>),
 &nbsp; &nbsp; &nbsp; &nbsp;t.identifier(<span class="" style="color: rgb(204, 147, 147);">'getOwnPropertySymbols'</span>)
 &nbsp; &nbsp; &nbsp;), [
 &nbsp; &nbsp; &nbsp; &nbsp;t.memberExpression(
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t.memberExpression(
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t.thisExpression(),
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t.identifier(<span class="" style="color: rgb(204, 147, 147);">'__proto__'</span>)
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;),
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t.identifier(<span class="" style="color: rgb(204, 147, 147);">'__proto__'</span>)
 &nbsp; &nbsp; &nbsp; &nbsp;)
 &nbsp; &nbsp; &nbsp;]
 &nbsp; &nbsp;);

 &nbsp; &nbsp;expr = t.callExpression(
 &nbsp; &nbsp; &nbsp;t.memberExpression(
 &nbsp; &nbsp; &nbsp; &nbsp;expr,
 &nbsp; &nbsp; &nbsp; &nbsp;t.identifier(<span class="" style="color: rgb(204, 147, 147);">'filter'</span>)
 &nbsp; &nbsp; &nbsp;),
 &nbsp; &nbsp; &nbsp;[
 &nbsp; &nbsp; &nbsp; &nbsp;t.arrowFunctionExpression(
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[t.identifier(<span class="" style="color: rgb(204, 147, 147);">'s'</span>)],
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t.binaryExpression( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">'==='</span>,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t.callExpression(
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t.identifier(<span class="" style="color: rgb(204, 147, 147);">'String'</span>),
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[t.identifier(<span class="" style="color: rgb(204, 147, 147);">'s'</span>)]
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;),
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t.stringLiteral(`Symbol(${name})`)
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)
 &nbsp; &nbsp; &nbsp; &nbsp;)
 &nbsp; &nbsp; &nbsp;]
 &nbsp; &nbsp;);

 &nbsp; &nbsp;expr = t.memberExpression(
 &nbsp; &nbsp; &nbsp;expr,
 &nbsp; &nbsp; &nbsp;t.numericLiteral(<span class="" style="color: rgb(140, 208, 211);">0</span>), &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(239, 239, 175);">true</span>
 &nbsp; &nbsp;); &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> expr;
 &nbsp;}</code></pre><p style="margin: 0px 0px 1.2em !important;">上面代码虽然繁琐，但都并不复杂，只是 AST 树的构建而已。最终，我们形成完整的<a>插件代码</a>。有兴趣的同学可以关注这个 <a>GitHub repo</a>。</p><p style="margin: 0px 0px 1.2em !important;">要使用的话，直接安装：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;">npm i babel-plugin-transform-private --save-dev</code></pre><p style="margin: 0px 0px 1.2em !important;">然后配置一下：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em; padding: 0px 0.3em; white-space: pre-wrap; border: 1px solid rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-radius: 3px; display: inline;white-space: pre; overflow: auto; border-radius: 3px; border: 1px solid rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;display: block; overflow-x: auto; padding: 0.5em; background: rgb(63, 63, 63); color: rgb(220, 220, 220); text-size-adjust: none;">{
 &nbsp;"<span class="">plugins</span>": <span class="">[
 &nbsp; &nbsp;[<span class="" style="color: rgb(204, 147, 147);">"../src/transform-private.js"</span>, {
 &nbsp; &nbsp; &nbsp;"<span class="">pattern</span>": <span class=""><span class="" style="color: rgb(204, 147, 147);">"^_"</span>
 &nbsp; &nbsp;</span>}],
 &nbsp;]</span>}</code></pre><p style="margin: 0px 0px 1.2em !important;">其中配置的 pattern 参数可以修改私有变量的匹配正则表达式，默认是 `”^_” 也就是以下划线开头，可以改成别的模式。</p><p style="margin: 0px 0px 1.2em !important;">以上就是今天的全部内容，代码比较多，但是关键点就这些，其他就是构建 AST 树的过程。如有任何问题，欢迎讨论。<br></p>
{% endraw  %}

