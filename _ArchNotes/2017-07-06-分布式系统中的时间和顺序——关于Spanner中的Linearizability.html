---
title: 分布式系统中的时间和顺序——关于Spanner中的Linearizability
author: 赵百忠
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1500385126&src=3&ver=1&signature=FkzcjJJ48va4gLuFLNnuhrUEkcDVQxsvdMhDib6hug*L6zXWakj3KKeOxgIzKNdiOz2nD4vBEhiPOv4Yl8-g0aYx5Uc0d*dKkRTAh28Nb4jLxp13LbhXicvYVHI3ZTkaE4B-s3EugWCJBhvyyNZXM4Si*D9X15HgVK9YwCVcAS4=
date: '2017-07-06 00:00:00 +0000'

---

{% raw  %}
<p><strong><span style="font-size: 18px;">引言</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">随着信息科技的在人类生活中的不断渗透，数据规模和计算规模也与日俱增<span style="font-size: 15px; text-align: justify;">，某些</span>问题已经无法在单机系统上进行处理<span style="font-size: 15px; text-align: justify;">，</span>只能寻求分布式系统的解决方案。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">分布式系统用多个设备来处理特定问题<span style="font-size: 15px; text-align: justify;">，</span>但是如何保证这样的处理结果像单机系统那样<strong>正确？</strong>这里的</span><strong style="font-size: 15px;">正确</strong><span style="font-size: 15px;">指的是：以相同的顺序进行相同的一系列操作，分布式系统能得到和单机系统相同的结果。</span></p><p>&nbsp;</p><p><strong><span style="font-size: 18px;">概要</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">本文主要介绍了分布式系统中 Linearizability 概念<span style="font-size: 15px; text-align: justify;">，</span>以及它与 Serializability 的区别<span style="font-size: 15px; text-align: justify;">，</span>并介绍了 Spanner 中是如何通过 TrueTime 来实现 Linearizability。</span></p><p><br></p><p><strong><span style="font-size: 18px;">Linearizability 的概念</span></strong></p><p><br></p><blockquote><p style="text-align: justify;"><strong><span style="font-size: 15px;">如果一系列的操作并发交叉进行，最终形成的 history（可以理解为运行记录）与顺序执行这些操作形成的 sequential history 相同，而且这些操作的先后顺序仍然得到保留，那么这个 history 我们就称之为是 Linearizability 的 [1]。</span></strong></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">我们假设现在有一个寄存器，具有 W 和 R 两个操作，比如 W(0)A 表示进程 A 往寄存器写入 0 这个值，R(0)B 表示进程 B 从寄存器读到 0 这个值。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">现实中，操作从开始到结束是具有时延的，我们用 start[W(0)] 表示发起操作，end[W(0)] 表示请求结束。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">假设现在有如下图所示的场景一：</span></p><p style="text-align: justify;"><span style="font-size: 15px;"></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHA5eicV93PAMwic5ug0sarXbYWKhmCEDQf30XI80YltQujyZ0bup8I5NVA/0?wx_fmt=png" style="width: 306px !important; height: 100px !important;"></p><p style="text-align: justify;"><span style="font-size: 15px;"></span><br></p><p style="text-align: justify;"><span style="font-size: 15px;">&nbsp;该场景共有三个操作:</span></p><p><br></p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p style="text-align: justify;"><span style="font-size: 15px;">A 进程执行 W(1)；</span></p></li><li><p style="text-align: justify;"><span style="font-size: 15px;">操作 1 进行的过程中, B 读取到 0 这个值, 用 R(0) 表示；</span></p></li><li><p style="text-align: justify;"><span style="font-size: 15px;">操作 1 和操作 2 都结束后, B 进程再次读取, 得到了 1 这个值, 用 R(1) 表示。</span></p></li></ol><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">注意这三个操作中隐含的先后顺序：操作 1 先于操作 3，操作 2 先于操作 3。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">这个并发执行的场景对应的 history 如下:</span></p><p><br></p><blockquote><p><span style="font-size: 14px;">start[W(1)]A<br></span></p><p><span style="font-size: 14px;">start[R(0)]B</span></p><p><span style="font-size: 14px;">end[W(1)]A</span></p><p><span style="font-size: 14px;">end[R(0)]B</span></p><p><span style="font-size: 14px;">start[R(1)]B</span></p><p><span style="font-size: 14px;">end[R(1)]B</span></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">这个 history 可以找到一个等价的 sequential history:</span></p><p><br></p><blockquote><p><span style="font-size: 14px;">start[R(0)]B<br></span></p><p><span style="font-size: 14px;">end[R(0)]B</span></p><p><span style="font-size: 14px;">start[W(1)]A</span></p><p><span style="font-size: 14px;">end[W(1)]A</span></p><p><span style="font-size: 14px;">start[R(1)]B</span></p><p><span style="font-size: 14px;">end[R(1)]B</span></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">而且这个 sequential history 中仍然保持了操作 1 与操作 3，操作 2 与操作 3 的先后顺序。</span><strong><span style="font-size: 15px;">因此场景一可以认为是 Linearizability 的。</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">再看如下的场景二，该场景并不满足 linearizable 的限制:</span></p><p><br></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHAjkW4jURkmzIfQZMKVbTkWicRa0MNwIw3IcoexHOvYAFJjh0yzKVPS4Q/0?wx_fmt=png" style="width: 513px !important; height: 94px !important;"></p><p style="text-align: justify;"><br></p><p style="text-align: justify;"><span style="font-size: 15px;">在这个场景中，当 B 执行 W(1) 的同时，A 已经读取到了 1 这个值，之后 C 执行 W(0)，再之后 B 读取这个值，竟然还读取到 1 这个值。</span></p><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 15px;">分布式系统中，如果可以按照操作发生的先后顺序，构造一个 Linearizability 的运行记录，那么这个特性就称之为的 Linearizability。&nbsp;</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">举例来说，假设现在有一个全球部署的分布式存储系统，<strong>先后</strong>发生以下 4 个操作：</span></p><p><br></p><blockquote><p><span style="font-size: 14px;">a. x = 1, 在中国发生<br></span></p><p><span style="font-size: 14px;">b. read x, 在美国发生</span></p><p><span style="font-size: 14px;">c. x = 2, 在日本发生</span></p><p><span style="font-size: 14px;">d. read x, 在美国发生</span></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">按照直觉来想, 操作 b 读取到的 x 值肯定是 1, 操作 d 读取到的 x 值肯定是 2。但这一切都是建立在系统能够感知这些操作的先后顺序之上, 比如在操作 b 中, 坐落于美国的 server 可以意识到操作 a 已经先发生。<br></span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">但是在现实的分布式场景中, 我们的系统并不能像上帝一样, 可以清楚的知道世界各角落中, 每个操作的先后顺序, 除非我们为每一个操作都标记上统一的单调递增的 id, 这个 id 的功能一般由 timestamp 来充当。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">但是对于 Spanner[2] 这样全球部署或者跨地域部署的系统, 如何来为事务分配 timestamp, 才能保证系统的响应时间在可接受的范围内? 如果整个系统采用一个中心节点来分配 timestamp, 那么系统的响应时间就变得非常不可控, 对于离中心节点隔了半圈地球的用户来说, 响应时间估计会是 100ms 级别。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">所以, 本文会着重介绍 Spanner 分配 timestamp 的原理, 也即是 TrueTime API。</span></p><p><br></p><p><strong>Linearizability 与 Serializability</strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">需要注意的是 Linearizability 其实是无关于并发控制的, 它只是关于操作顺序的一种限制。与 Linearizability&nbsp;很容易混淆的一个术语是 Serializability, 这个特性才是关于并发控制的一个限制。</span></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><blockquote><p style="text-align: justify;"><span style="font-size: 15px;">如果一个系统可以将并发的<strong>事务</strong>按照某种调度，达到的效果和某种串行执行的效果一样（也就是各事务的操作不会相互交错），那么这个特性就叫 Serializability。</span></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">Serializability 着重于保证编程模型中的一些约束, 这些约束大部分是人为规定的. MySQL 的默认 RR 隔离级别是没有保证 Serializability, 因为 RR 并不能防止 Lost Update 和 Write Skew 的发生, 这两种情况都会破坏一些约束, 具体请参考 Weak Isolation in Relational Databases[4]。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">对于单机数据库系统，单机数据库系统维持一个统一的、递增的事务 id 是轻而易举的事情, 所以可以认为它们天生就是具有 Linearizability 特性。另外有些数据库系统, 比如 MySQL 所支持的 Serializable 隔离级别便是本文所说的 Serializability 的特性。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">所以, 我们可以看到所谓的 Serializability 便是 ACID 中的 I, 至于 Linearizability, 是针对于分布式系统而言的一个难点。</span></p><p><br></p><p><strong><span style="font-size: 18px;">Linearizability 的意义</span></strong><br></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">现在的数据库系统, 都具有 Snapshot read 的概念, 所谓 Snapshot read 指的是对于系统的读操作, 只是过去某一时刻的一个快照, 也就是对应于该事务 id 所能看到的一份历史数据, 在 Spanner 的场景来说, 也就一个指定的 timestamp 所能看到的一份历史数据。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">如果一个分布式系统能够对"历史"有所感知的话, 也就意味着能够感知操作的前后顺序, 也就是说这个系统支持 Linearizability。</span></p><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 15px;">如果一个分布式系统无法支持 Linearizability, 那么对于指定一个 timestamp 所能看到的历史数据, 每次可能是不一样。</span></strong></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;"><span style="font-size: 15px;">举例来说, 假设现在有一个全球部署的分布式存储系统, <strong>先后</strong>发生以下3个操作:</span></p><p><br></p><blockquote><p><span style="font-size: 14px;">a. x = 1, 分配的 timestamp 为 s1<br></span></p><p><span style="font-size: 14px;">b. 指定 timestamp s2 执行 read x</span></p><p><span style="font-size: 14px;">c. x = 2, 分配的 timestamp 为 s3</span></p><p><span style="font-size: 14px;">d. 指定同一个 timestamp s2 执行 read x</span></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">假设 s2 &gt; tabs(a)，意思是 s2 是在操作 a 之后一个 timestamp，按照直觉来想, 肯定满足 s2 &gt; s1 的关系式, 但是对于不支持 Linearizability 的系统来说, 可能存在 s2 &lt; s1, 导致操作 b 这个 Snapshot read 无法看到 a 操作的结果。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">类似, 还假设 s2 &lt; tabs(c), 但是可能存在 s2 &gt; s3, 导致操作 d 这个 Snapshot read 看到了 c 操作的结果。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">注意, 操作 b 和 d 的都指定同一个 timestamp = s2 进行 Snapshot read，但是 b 和 d 看到的历史数据却是不一样的, 也就是说, 对于同一个 timestamp 对应的快照竟然不一样。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">到这里可以看出来, 不支持 Linearizability 的分布式系统, Snapshot read 便无从谈起, Snapshot Isolation 也就是不可能的事情。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px; color: rgb(136, 136, 136);">有些系统实现了"部分顺序", 也就是在单个节点（或者说单个分区）内的 Linearizability, 也就是能做到单机 Snapshot, 但是没有全局的 Snapshot。</span><br></p><p><br></p><p><strong><span style="font-size: 18px;">实现 Linearizability 的难点</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">从上述描述中, 可以看到, 实现 Linearizability 首先需要对系统中每个事务分配一个统一的、单调递增的 id, 一般来说是 timestamp。那么, 在分布式系统中, 如何协调这个 timestamp 呢?</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">对于这个问题, 我们可能会很迅速的想到一个方案：引入一个专门生成 timestamp 的中心节点, 每次事务提交时, 访问该中心节点来获得 timestamp。TiDB 使用的便是这种方案, 它利用 TimeStamp Oracle 模块来提供授时服务。</span></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;"><strong><span style="font-size: 15px;">但是这种方案引入了中心节点, 也意味着整套系统的部署不可能在地理位置上过于分散, 否则事务延时将会令人难以忍受。</span></strong></p><p><br></p><blockquote><p style="text-align: justify;"><span style="font-size: 15px;">需要指出的是，逻辑时钟（比如 Lamport 时钟和 Vector 时钟）无法实现 Linearizability, 因为它只能区分有"因果关系（也就是有通信）"的事件间的顺序。所以, 类似于" 事务 T2 在事务 T1 提交后才开始提交"这样的场景, 当节点间没有发生通信时，逻辑时钟无法区分这两个事务的顺序。</span></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">本文着重讲解 Spanner 是如何在这种全球部署的分布式系统中, 保证 Linearizability 的。在全球分布式系统中，真实世界里两个事务, 先后在不同的地方 commit, 系统怎样去如实反映事务的 commit 顺序?</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">首先我们先了解下 Spanner 的特性和它的整体架构。</span></p><p><br></p><p><strong><span style="font-size: 18px;">Spanner 简介</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">Spanner 是由 Google 公司设计开发的一套可扩展、高可用、可全球部署的分布式数据库系统，具有如下特性:</span></p><p><br></p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p style="text-align: justify;"><span style="font-size: 15px;">提供了基于 SQL 的查询接口, 使用强类型的 schema, 提供了类型 RDS 的体验；</span></p></li><li><p style="text-align: justify;"><span style="font-size: 15px;">一定程度上支持垂直 sharding, 用户可以通过 INTERLEAVE 语法定义相关的两个 table 的记录存放在同一个 spanserver，带来的好处是形成了数据的 Locality, 对于查询中的一些操作（比如 join, group by）可以进行下推[3]；</span></p></li><li><p style="text-align: justify;"><span style="font-size: 15px;">可以自动对数据进行水平 sharding, 并对每个 shard 维护一定的数量的副本, 通过 Multi-Paxos 保证一致性, 这些副本可以分散在全球不同地域；</span></p></li><li><p style="text-align: justify;"><span style="font-size: 15px;">支持 Snapshot Isolation, 通过 2PL 保证多个并发事务的 Serializability。另外, 对于涉及多个 shard 的 xa 事务, 通过 2PC 保证 Serializability；</span></p></li><li><p style="text-align: justify;"><span style="font-size: 15px;">保证 External Consistency（等价于 Linearizability, 下文不再区分）, 也就是说如果事务 T1 提交后, 事务 T2 才开始提交, 那么 T2 的 timestamp 一定大于 T1 的 timestamp。</span></p></li></ol><p><br></p><p><strong><span style="font-size: 18px;">整体架构</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">Spanner 是由一系列的 zone 组成, zone 是 Spanner 中的部署的单元, 一般会在某 datacenter 部署一个 zone, 但是也可以有多个 zone。数据副本就是存放在这一系列的 zone 中, zone 之间的物理距离越大, 数据的安全性越高。</span></p><p><br></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHALRxD7I0E1ZxhcGuef7wr6785nWibXOiaG09azmfjNo87Sw2D7FHayBPQ/0?wx_fmt=png" style="width: 476px !important; height: 296px !important;"></p><p><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;"><span style="font-size: 15px;"><strong>universemaster：</strong>是一个控制台, 监控universe里所有zone状态信息, 用于debug；</span></p></li><li><p style="text-align: justify;"><span style="font-size: 15px;"><strong>placement driver：</strong>帮助维持特定副本数量，自动搬迁数据，实现负载均衡；</span></p></li><li><p style="text-align: justify;"><span style="font-size: 15px;"><strong>zonemaster：</strong>管理 spanserver 上的数据；</span></p></li><li><p style="text-align: justify;"><span style="font-size: 15px;"><strong>location proxy：</strong>作用不详, 可能是为 client 提供数据的位置信息, client 要先访问它来定位需要访问的 spanserver；</span></p></li><li><p style="text-align: justify;"><span style="font-size: 15px;"><strong>spanserver：</strong>对 client 提供服务, 包括读写数据。</span></p></li></ul><p><br></p><p><span style="font-size: 18px;"><strong>Spanserver 架构</strong></span></p><p><br></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHA4lia1a4fibcu7CKwbW8OMfphaa1v7AsZOkGl3vl8EiaDoWchgluCZvZQw/0?wx_fmt=png" style="width: 596px !important; height: 432px !important;"></p><p style="text-align: justify;"><br></p><p style="text-align: justify;"><span style="font-size: 15px;">每个 spanserver 负责管理 100 ~ 1000 个 tablet。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">一个 tablet 是维护某个表的一部分数据, 比如一个表有 10,000 行数据, 分成 100 个 tablet, 那么第 1 个 tablet 维护第 1 ~ 100 行数据, 第 2 个 tablet 维护第 101 ~ 200 行数据。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">tablet 维护的数据是一系列的 KV:</span><span style="font-size: 15px; background-color: rgb(214, 214, 214);">&nbsp;(key, timestamp) ---&gt; value 。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">可以看出, Spanner 的 KV 数据是和 timestamp 绑定的, 所以自然就是支持 multi-version。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">为了支持数据复制, spanserver 在每个 tablet 上层实现了 paxos group, 这个 group 中 replica 分布在不同的 zone 中。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">每个 leader replica 还维护了一个 lock table, 也就是一系列的 KV: <span style="font-size: 15px; background-color: rgb(214, 214, 214);">key---&gt;lock-states。</span></span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">lock-states 指的是对应的数据在2PL过程中的锁状态。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">spanserver 在每个 leader replica 上都实现了 transaction manager, 这个模块是用来支持分布式事务的。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">如果事务涉及到多个 paxos group, 那么每个 leader replica 此时就是 participant leader 的身份, 其中一个 participant group 会被 client 选作 coordinator, 通过 2PC 的方式来实现 Serializability。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">如果事务只涉及一个 paxos group, 那么 transaction manager 的功能可以被忽略, 只依赖 lock table 就可以实现 Serializability。</span></p><p><br></p><p><strong><span style="font-size: 18px;">事务 commit 的过程</span></strong></p><p><br></p><p><span style="font-size: 15px;"><strong>简单的实现（但是有问题）</strong></span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">现在假设让我们来实现事务的 commit 过程, 有一种简单的方法如下图所示, 这种方法简单的从 local clock 分配 timestamp 给事务:</span></p><p><br></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHATCphtW7ic1226GvQIT8IN7OnTCSD317ws0x9bKge5yO6JUZnlgVL9Lw/0?wx_fmt=png" style="width: 224px !important; height: 444px !important;"></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">假设现在有先后两个事务 T1 和 T2, 分别在不同的 spanserver 上执行, T2 在 T1 提交后, 才开始提交, 使用这个方法会导致真实世界中后提交的 trx 反而具有较小的 timestamp。</span></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;"><span style="font-size: 15px;">这个问题出现的原因是, 两个事务所使用的 local clock 没有可比性, 无法真实反映两个 trx 的先后顺序：</span></p><p><br></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHAJYiaZL4icAdhWvo8eTVFMK3wCwIwuLZtRoeJpwSbibe6icOO1CXKDGJnkQ/0?wx_fmt=png" style="width: 591px !important; height: 410px !important;"></p><p><span style="font-size: 15px; text-align: justify;"><br></span></p><p><span style="font-size: 15px; text-align: justify;">上图表明, T2 的 timestamp 是 8, T1 的 timestamp 是 10, 这个和真实世界的先后顺序是相反的，原因在于不同设备上的 clock 是没有可比性。</span><br></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">为了解决这个问题, 我们可能会很迅速的想到一个解决方案：引入一个专门生成 timestamp 的中心节点, 每次事务提交时, 访问该中心节点来获得 timestamp。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">TiDB 使用的便是这种方案，但是这种方案引入了中心节点, 也意味着整套系统的部署不可能在地理位置上过于分散, 否则事务延时将会令人难以忍受。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">Spanner 采用了另外一种方案：TrueTime。TrueTime 不但可以分配统一的具有可比性 timestamp 范围, 还支持系统的全球范围部署。</span></p><p><br></p><p><strong><span style="font-size: 15px;">TrueTime</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">Spanner 的 TrueTime 是利用 GPS 时钟和原子钟实现的, 可以提供非常精确的时钟, 误差在 1ms~7ms 之间。</span></p><p><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;"><span style="font-size: 15px;">TT.now() 返回一个区间[earlist, latest], 保证 abs time(绝对时间)是在区间以内；</span></p></li><li><p style="text-align: justify;"><span style="font-size: 15px;">TT.after(t) 判断一个时间是否已经成为过去时, 是对 TT.now() 的简单封装：</span></p></li></ul><p><br></p><blockquote><p><span style="font-size: 14px;">return TT.now().earlist &gt; t</span><br></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">TT.before(t) 和前者类似,判断时间是否是未来时。</span><br></p><p><br></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHAJYiaZL4icAdhWvo8eTVFMK3wCwIwuLZtRoeJpwSbibe6icOO1CXKDGJnkQ/0?wx_fmt=png" style="width: 591px !important; height: 410px !important;"></p><p><br></p><p>&nbsp;</p><p><span style="font-size: 15px;"><strong>TrueTime 实现</strong></span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">TrueTime 是通过以下架构实现的:</span></p><p><br></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHAbJNkxIiaYOh9JKf66w8uDiaH3ISS2U0XsyZs7QhSg0YlcnAlXOvWRIGA/0?wx_fmt=png" style="width: 437px !important; height: 215px !important;"></p><p><span style="font-size: 15px; text-align: justify;"><br></span></p><p><span style="font-size: 15px; text-align: justify;">每个 datacenter 具有若干个 time master, 另外每台设备上运行有 timeslave 进程。前者是 Spanner 的时钟来源, 大部分是配备 GPS 接收器,剩下一小部分配备原子钟(防止 GPS 的天线故障或者频率干扰, 所以也叫"末日时钟")。</span><br></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">timeslave 以 30s 的间隔从 time master 同步时间。当 timeslave 需要校准 local clock 时, 从就近的 datacenter 和较远的 datacenter 的 time master 拉取时间信息, 并通过 Marzullo 算法[5]识别并丢弃异常的时间来源, 并将多个时间信息归并到一个统一的时间。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">TrueTime API 的直接数据来源是设备上的 local clock，所以 TrueTime 的误差来源有:</span></p><p><br></p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p style="text-align: justify;"><span style="font-size: 15px;">从 time master 同步时的网络延迟, 导致的误差大概是 1ms；</span></p></li><li><p style="text-align: justify;"><span style="font-size: 15px;">local clock 的漂移, 这个误差是时间的锯齿函数, 校准后的一瞬间是 0, 校准前的一瞬间是最大值, 范围在 0~6ms。</span></p></li></ol><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">所以 TrueTime 总的误差是 1~7ms, OSID12 论文表示平均是 4ms 左右。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">网络延迟导致的误差如下图所示:</span></p><p><br></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHAXibAYKzysJOrWjTwBNalau112a6pYoYhjia8picCPnzmLvpibTjIbs4xEA/0?wx_fmt=png" style="width: 358px !important; height: 327px !important;"></p><p><span style="font-size: 15px; text-align: justify;">&nbsp;</span></p><p style="text-align: justify;"><span style="font-size: 15px;">local clock 漂移导致的误差, 是因为环境温度,工作电压等因素导致的。Spanner 计算这个误差时, 已经按照最坏的漂移速度(200us/s)来计算的, 真实的差距可能是 local clock 提前了, 或者是 local clock 电压不够导致落后了。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">为了保证 local clock 的漂移在 0 ~ 6ms 之内, 也就是漂移频率在 200us/s 之内, Spanner 实现了漂移频率异常的设备从集群中剔除的功能。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;"><strong>Commit Wait</strong></span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">利用 TrueTime, Spanner 可以保证整个分布式系统中,所有事务分配到的 timestamp 都是具有可比性的, 基于同一个参考系的。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">Spanner 在 TureTime 的基础上,还引入一个 Commit Wait 的限制，保证了 <span style="font-size: 15px; background-color: rgb(214, 214, 214);">External Consistency</span>, 也就是保证了如下规律:</span></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;"><strong><span style="font-size: 15px;">如果事务 T2 在事务 T1 提交后, 才开始提交, 那么 T2 的 commit timestamp 肯定大于 T1 的 commit timestamp。</span></strong></p><p><br></p><p><span style="font-size: 15px; text-align: justify;">这个限制是一个很关键的地方是, Commit Wait:</span><br></p><p><span style="font-size: 15px; text-align: justify;"><br></span></p><p style="text-align: justify;"><span style="font-size: 15px;">等待 T1 的 timestamp <strong>s&nbsp;</strong>成为过去时, 才提交事务(也就是通知其他replica进行重放,回复ack给用户), 也就是保证事务 commit 的绝对时间大于 <strong>s</strong>, 有了 Commit Wait 之后就可以保证了 External Consistency, 证明如下:</span></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;"><span style="font-size: 15px;"></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHA0tRzeDKyJ2vdpMIHlCseGpq7ibfibaQByic39OicB141YBt1GUHbQVXIpw/0?wx_fmt=png" style="width: 483px !important; height: 212px !important;"></p><p style="text-align: justify;"><br></p><p style="text-align: justify;"><span style="font-size: 15px;">因此, Spanner 的 read-write 事务提交时的步骤如下:</span></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHAv33MMJDeczzF6u9bicZnqz7Le1ATEuKxGbNGIxicaicHujS8IYWwFU06A/0?wx_fmt=png" style="width: 317px !important; height: 424px !important;"></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">首先, replica leader 接受收到 client 的 commit request 后, 会锁住相应的 key, 然后分配 TT.now().latest 作为事务的 timestamp <strong>s。</strong></span></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;"><span style="font-size: 15px;">因为 TT.now() 保证了 abs time 是在区间内的, 所以这个&nbsp;<strong style="font-size: 15px; text-align: justify; white-space: normal;">s&nbsp;</strong>是未来时, 需要进行 Commit Wait, 等待<span style="font-size: 15px; text-align: justify;">&nbsp;</span><strong style="font-size: 15px; text-align: justify; white-space: normal;">s&nbsp;</strong>成为过去时后, 再进行提交, 用于保证 External Consistentency。</span></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;"><span style="font-size: 15px;">假设 s = t1 + ε1, 进行 Commit Wait 之后是 Now() = t2 ± ε2。</span></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;"><span style="font-size: 15px;">由于 t2 - ε2 &gt;= t1 + ε1, 所以 Commit Wait 所消耗的时间等于 t2 - t1 &gt;= ε1 + ε2, 也就是等待时间至少是平均误差的 2 倍, 约 8ms（OSDI12 的论文中表示 Commit Wait 的时间大多数情况和 Paxos write 的时间是重叠的）。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">关于 External Consistency 的示例如下, 假设图中事务 T1 所在的 spanserver 的误差是 1, 事务 T2 所在的 spanserver 误差是 2:</span></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHAIfq1hFWSq9jF36XkBNUekiboGj2f2Bq3EKmvFgPFrjw64MIqxwr6gyw/0?wx_fmt=png" style="width: 666px !important; height: 481px !important;"></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;"><span style="font-size: 15px;">Spanner 保证了 T1 的 timestamp = 11 小于 T2 的 timestamp = 14。</span></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;"><span style="font-size: 15px;">注意图中纵坐标不是随意标注的, 而是注入了一定的限制在这里：刻度11 &gt;= T1 的 timestamp, 而且 T2 的 timestamp &gt;= 13。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">Spanner 巧妙的通过 Truetime 和 Commit Wait, 保证了 T1 的 timestamp &lt; T2 的 timestamp。</span></p><p>&nbsp;</p><p><strong><span style="font-size: 18px;">Snapshot read</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">Snapshot read 指的是读取过去时间的某个快照, 无需加锁。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">client可以指定一个 timestamp t, 或者时间范围，Spanner 会寻找一个数据充分更新好的 replica 来提供读服务。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">所谓数据充分更新好, 是指 t &lt;= tsafe，其中 tsafe 定义如下:</span></p><p><br></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONrxdkA215D4QeLaWgtYzHAWMRl5ge0dcmgI8ZzD4icdH8nJxErZmyWBpuYia0oPsdD61PF4Lv7bibtA/0?wx_fmt=png" style="width: 210px !important; height: 35px !important;"></p><p style="text-align: justify;"><br></p><p style="text-align: justify;"><span style="font-size: 15px;">前者指的已经提交的事务 timestamp, 后者指的是正在 2PC 过程中未决的事务 timestamp - 1。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">如果 t &gt; tsafe，Spanner 需要等待 replica 一段时间, 待 tsafe 推进后再进行读操作。</span></p><p style="text-align: justify;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;"><span style="font-size: 15px;">基于 External Consistency 特性，Spanner 可以感知操作的先后顺序, 给定一个时间戳 t, Spanner 能够明确哪些是历史数据, 并提供一致的快照。</span></p><p><br></p><p><strong><span style="font-size: 18px;">总结</span></strong></p><p><strong><span style="font-size: 18px;"><br></span></strong></p><p style="text-align: justify;"><strong><span style="font-size: 15px;">Spanner 的 TureTime API 设计非常巧妙, 保证了绝对时间一定是落在 TT.now() 返回的区间之中。基于这个保证, 使得分布在全球的 spanserver 分配的 timestamp 都是基于同一参考系, 具有可比性。</span></strong><span style="font-size: 15px;">进而让 Spanner 能够感知分布式系统中的事件的先后顺序, 保证了 External Consistency。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">但是 TureTime API 要求对误差的测量具有非常高的要求, 如果实际误差 &gt; 预计的误差, 那么绝对时间很可能就飘到了区间之外, 后续的操作都无法保证宣称的 External Consistency。另外, Spanener 的大部分响应时间与误差的大小是正相关的。</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 15px;">自 Spanner 在 OSDI12 发表论文后, Spanner 一直在努力减少误差, 并提高测量误差的技术[3], 但是并没有透露更多细节。</span></p><p><br></p><p><strong><span style="font-size: 18px;">参考</span></strong></p><p><br></p><p><span style="font-size: 12px;">[1] &nbsp;Linearizability: acorrectness condition for concurrent objects(ACM TOPLAS 1990)</span></p><p><span style="font-size: 12px;">[2] &nbsp;Spanner: Google’s Globally-Distributed Database (OSDI12)</span></p><p><span style="font-size: 12px;">[3] &nbsp;Spanner: Becoming a SQL System (SIGMOD17)</span></p><p><span style="font-size: 12px;">[4] &nbsp;Weak Isolation in Relational Databases, http://www.evanjones.ca/db-isolation-semantics.html</span></p><p><span style="font-size: 12px;">[5] &nbsp;Marzullo's algorithm, https://en.wikipedia.org/wiki/Marzullo%27s_algorithm</span></p><p><br></p><p class="" style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">作者介绍</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><p><span style="font-size: 15px; color: rgb(136, 136, 136);">赵百忠，腾讯云数据库工程师，从事于高可用云数据库服务的构建和管控平台开发，关注 RDS, NoSql, NewSql 等技术发展。</span></p></blockquote><p class=""><br></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 18px;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">推荐阅读</span></strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; width: 728.641px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=404242829&amp;idx=1&amp;sn=aacddf1c2c828281e6202eff8cd374f5&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline; font-size: 15px; color: rgb(0, 82, 255);"><span style="font-size: 15px; color: rgb(0, 82, 255);">并发之痛 Thread，Goroutine，Actor</span></a></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547753&amp;idx=1&amp;sn=291a647c6bac804f2877f2216a97e5dc&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline; font-size: 15px; color: rgb(0, 82, 255);"><span style="font-size: 15px; color: rgb(0, 82, 255);">有关并行化——你知道的可能是错的</span></a><br></p></li></ul><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">本文作者赵百忠，转载请注明出处，技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。</span><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">高可用架构</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">改变互联网的构建方式</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOPOK9rQud9XibGhPOPsA3gA8Wr4CEnzmhfZQzSGu0Q09GOuk18S9icZtuVnQewvyqZtOWyDnJPBDn1A/640?wx_fmt=jpeg" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 200px !important; height: 200px !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></strong></span><span style="max-width: 100%; font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">长按二维码 关注「高可用架构」公众号</span></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1500385126&src=3&ver=1&signature=FkzcjJJ48va4gLuFLNnuhrUEkcDVQxsvdMhDib6hug*L6zXWakj3KKeOxgIzKNdiOz2nD4vBEhiPOv4Yl8-g0aYx5Uc0d*dKkRTAh28Nb4jLxp13LbhXicvYVHI3ZTkaE4B-s3EugWCJBhvyyNZXM4Si*D9X15HgVK9YwCVcAS4=">微信地址</a>
{% endraw  %}

