---
title: '容器与持久化存储:容器的开源分布式存储方案选型'
author: 张朝潞
date: '2017-03-29 00:00:00 +0000'

---

{% raw  %}
<p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">导读：容器得到了越来越广泛的使用，以下问题困扰架构师：</span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"><br></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">容器正逐渐成为云上应用的标准部署单元，容器该如何解决持久化存储的需求？</span></p></li><li><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">容器编排系统已成当红炸子鸡，在无状态的容器中，存储系统面临哪些新的挑战？</span></p></li><li><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">容器与持久化存储系统是融合架构还是分离架构？</span></p></li></ul><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">本文探讨了容器和持久化存储相关知识，由张朝潞在高可用架构群分享，转载请注明来自高可用架构公众号 ArchNotes。</span></p><p><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"><br></span></p><p><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><section style="max-width: 100%; box-sizing: border-box; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%; box-sizing: border-box; word-wrap: break-word !important;"><section class="" style="max-width: 100%; box-sizing: border-box; font-size: 57.6px; text-align: center; word-wrap: break-word !important;"><section class="" style="margin: auto; max-width: 100%; box-sizing: border-box; display: inline-block; vertical-align: bottom; width: 3em; height: 3em; border-radius: 100%; background-position: center center; background-repeat: no-repeat; background-size: cover; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_jpg/0CV4T1f8CZ5k9AjMGk4kABLdY7HWwBuwn0zMZevQiaQ97sBHwBcc2bOcTknlOTwB2vtHhTkiabgXqFbzW3R7eSvg/0?wx_fmt=jpeg&quot;); word-wrap: break-word !important;"><section class="" style="max-width: 100%; box-sizing: border-box; width: 172.797px; height: 172.797px; overflow: hidden; word-wrap: break-word !important;"><img src="/ArchNotes/images/a4ce4b3b7c2b7628ab690db8a95dd17296e03286.jpeg" style="box-sizing: border-box; opacity: 0; word-wrap: break-word !important; visibility: visible !important; width: 172.797px !important; height: 198.604px !important;"></section></section></section></section></section><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 14px; color: rgb(51, 51, 51); box-sizing: border-box !important; word-wrap: break-word !important;">张朝潞<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 14px; color: rgb(51, 51, 51); box-sizing: border-box !important; word-wrap: break-word !important;">有容云平台存储架构师</span></p><p><br></p><blockquote><p>张朝潞，有容云平台存储架构师。曾工作于UIT、华三、腾讯、专注分布式存储的研究和开发，对云计算存储解决方案方面有很深的技术造诣和行业理解。</p></blockquote><p><br></p><p class=""><strong><span style="font-size: 20px;">一．容器对存储插件的定义</span></strong></p><p class=""><br></p><p class="">以 Docker 为例， Docker 对存储卷定义了一组简单的接口，外部存储只要实现简单的接口便可以和外部存储对接。</p><p class=""><br></p><p><img src="/ArchNotes/images/c27ddb29155cac4f148054f2b8fc1b6c4f647ea6.png" style="width: 689px !important; height: 503px !important;"></p><p class=""><br></p><p class="">Docker daemon 和 plugin daemon 基于 UNIX 域套接字，使用 RESTful API 进行通信，下面是详细的 API：</p><p class=""><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p class=""><span style="font-size: 14px;">Plugin.Activate : 握手。</span></p></li><li><p class=""><span style="font-size: 14px;">VolumeDriver.Create : 创建卷。<br></span></p></li><li><p class=""><span style="font-size: 14px;">VolumeDriver.Mount : 挂载卷。<br></span></p></li><li><p class=""><span style="font-size: 14px;">VolumeDriver.Path : 获取卷的路径。<br></span></p></li><li><p class=""><span style="font-size: 14px;">VolumeDriver.Unmount : 卸载卷。<br></span></p></li><li><p class=""><span style="font-size: 14px;">VolumeDriver.Remove : 删除卷。<br></span></p></li><li><p class=""><span style="font-size: 14px;">VolumeDriver.List : 获取 volume 列表。<br></span></p></li><li><p class=""><span style="font-size: 14px;">VolumeDriver.Get : 获取 volume 信息。<br></span></p></li><li><p class=""><span style="font-size: 14px;">VolumeDriver.Capabilities : 获取 volume 属性<br></span></p></li></ul><p class=""><br></p><p class="">从上面这组接口可以看出， Docker 容器是通过 mount 的方式将外部存储挂载到本地目录，尽量使内部应用程序对存储是无感知的，应用程序就像使用本地目录一样使用外部存储卷，而将外部存储的管理交给存储 Plugin 负责（如 Flocker、Rancher Convoy，REX-Ray 等）。</p><p class=""><br></p><p class="">容器正逐渐成为云计算平台应用程序的标准部署单元，容器能轻易的将各式各样的应用程序及其 runtime 打包成统一的对象，于是编排调度系统能把各种应用程序当成统一的容器进行处理，大大简化编排调度系统的复杂度。结合 Docker 对存储插件的定义，不难看出 <strong>Docker 希望容器的运行环境独立而纯粹，不希望引入有状态和复杂的存储系统。</strong></p><p class=""><br></p><p class=""><span style="font-size: 20px;"><strong>二、存储插件</strong></span></p><p class=""><br></p><p class="">Convoy 作为一个 Docker volume plugin，支持不同的后端存储，为 Docker 提供 MountPoint，也就是一个的目录，可能是挂载了后端存储、本地块设备或者就是本地目录。</p><p class=""><br></p><p class="">Convoy 的代码从结构、风格和使用的库，都与 Docker 十分相似，并且比 Docker 简单很多。</p><p class=""><br></p><p class=""><strong style="white-space: normal;"><span style="color: rgb(136, 136, 136); font-size: 14px;">（小编：下面展开介绍一下 convoy 源代码的部分模块，不需要了解细节的读者可以直接跳到第三部分：容器、应用程序、持久化存储。）</span></strong></p><p class=""><br></p><p class=""><strong>Convoy 在源码级别上值得留意的点，我认为有两点：①插件式结构与 interface 的运用。② 作者对事物的抽象能力与方法。</strong></p><p class=""><br></p><p class=""><strong>1、convoy daemon (convoy / daemon)&nbsp;</strong></p><p class=""><br></p><p class="">图 1 中黑色部分</p><p class=""><br></p><p class="">daemon 是主要的功能模块，可以接收来自 convoy client 和 Docker 的命令，对 backend 存储进行了抽象，以便统一管理。下面先从 daemon 的启动开始。</p><p class=""><br></p><p class=""><strong>1.1、daemon 进程启动<br></strong></p><p class=""><br></p><p class="">1）执行命令：&nbsp;</p><p class=""><br></p><blockquote><p class=""><span style="font-size: 14px;">convoy daemon --drivers glusterfs --driver-opts glusterfs.servers=192.168.0.3 --driver-opts glusterfs.defaultvolumepool=vol2</span></p></blockquote><p class=""><br></p><p class="">2） convoy 程序解析参数，获得 daemon 子命令，调用到 daemon.Start 函数（convoy/daemon/daemon.go)， Start 函数中主要围绕 daemon struct 建立所需要环境和配置。</p><p class=""><br></p><p><img src="/ArchNotes/images/862bedd349cc25e03a81181b898a1a71bcf79616.png" style="width: 770px !important; height: 328.648px !important;"></p><p class=""><br></p><p class="">3） Driver 初始化，优先从配置文件读取信息忽略命令行输入的参数，如果配置文件不存在则根据命令行参数初始化。</p><p class=""><br></p><p><img src="/ArchNotes/images/786aab3aad09f6fbe47d8adec6a00748d917b920.png" style="width: 770px !important; height: 81.4964px !important;"></p><p class="" style="text-align: center;">图 2. convoy 配置文件内容</p><p class=""><br></p><p class="">遍历 DriverList，找到配置文件或命令行指定的 Driver，执行初始化函数 Init，并添加到 daemon.ConvoyDrivers 中。</p><p class=""><br></p><p class="">4）根据 convoy 的工作目录的内容，更新管理元数据，图 1 中也有相应的模块。</p><p class=""><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p class=""><span style="font-size: 14px;">NameUUIDIndex： volume name : volume UUID</span></p></li><li><p class=""><span style="font-size: 14px;">SnapshotVolumeIndex : snapshot UUID : volume UUID</span></p></li></ul><p class=""><br></p><p><img src="/ArchNotes/images/e37141468fba130c266ef29b4433827575f7cd06.png" style="width: 705px !important; height: 296px !important;"></p><p class="" style="text-align: center;">图 3.convoy 工作目录和 volume 配置文件</p><p class=""><br></p><p class="">5） Router 注册： Router 提供两部分的路由，并将 daemon 的 Router 指向该 Router。</p><p class=""><br></p><p class="">(1) 处理 convoy client 的命令 Client Request Router，处理客户端发送的 HTTP request。</p><p><img src="/ArchNotes/images/7cce5a9b386db61b178b16cd54bc6840e2a0e3a7.png" style="width: 454px !important; height: 217px !important;"></p><p class="">(2) 处理来自 Docker 的请求 Docker Volume Plugin Router， convoy 本身就是 Docker 的 volume plugin，提供了如下的接口。</p><p><img src="/ArchNotes/images/063400d7a577e4942fb67550e41683650a5e5f64.png" style="width: 433px !important; height: 383px !important;"></p><p class=""><br></p><p class="">6） HTTP server 启动，根据 sockFile = /var/run/convoy/convoy.sock 和 上一步骤的 Router，启动 HTTP server。<br></p><p class=""><br></p><p class=""><strong>2.2、daemon 的请求处理逻辑<br></strong></p><p class=""><br></p><p class="">Daemon 启动后便可以处理请求（ convoy client 或 Docker），主要处理逻辑 Router 收到 HTTP 请求，将请求分发给各个模块： Docker、 volume、 snapshot、 backup。这个 4 个逻辑模块根据 driver name( 指定的或者默认的 ) 从 daemon.ConvoyDrivers 中获取对应的 Driver。 ConvoyDrivers 中的 Driver 是实现了 ConvoyDriver interface 的结构。</p><p class=""><br></p><p><img src="/ArchNotes/images/5a723ed3079f27039e645671ea146381d2fb80db.png" style="width: 770px !important; height: 435.936px !important;"></p><p class="" style="text-align: center;">图 4.convoy daemon 请求处理逻辑</p><p class=""><br></p><p class="">从图 4 中可以看出 ConvoyDriver 接口规定了 3 组接口对应 volume， snapshot， backup 的操作，用于操作 backend storage。逻辑处理最终调用这些接口访问 Backend Storage。</p><p class=""><br></p><p class=""><strong>2.3、ConvoyDriver implement<br></strong></p><p class=""><br></p><p class="">截止到 0.4.3 版本， convoy 支持 4 种后端存储（实现了 ConvoyDriver 接口），如下表。</p><p class=""><br></p><p><img src="/ArchNotes/images/4c0a5a22ac5b6b0694102cec748a1ef6c08c1104.png" style="width: 770px !important; height: 438.497px !important;"></p><p class=""><br></p><p class=""><br></p><p class="">下面来说说，convoy 是如何对后端存储进行抽象和管理，它使用了 4 种结构 Driver， Volume， Snapshot， Device。<br></p><p class=""><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p class=""><span style="font-size: 14px;">Driver：主要实现了 ConvoyDriver 接口，提供对 Volume， Snapshot， Backup 等功能。</span></p></li><li><p class=""><span style="font-size: 14px;">Volume：管理提供到 Docker 或者 convoy client 的 Volume。</span></p></li><li><p class=""><span style="font-size: 14px;">Snapshot：用于管理 Volume 的快照。</span></p></li><li><p class=""><span style="font-size: 14px;">Device：管理后端存储提供的存储空间，如： devicemapper 的 device ； glusterfs 的 volume ； vfs 的目录等。</span></p></li></ul><p class=""><br></p><p><img src="/ArchNotes/images/e51d17078d88a2eddb89970a71ca886f3eba4641.png" style="width: 664px !important; height: 761px !important;"></p><p class="" style="text-align: center;">图 5.ConvoyDriver 的实现</p><p class=""><br></p><p class="">图 5 Device 结构内容，记录了该 Driver 的后端存储的信息。</p><p><img src="/ArchNotes/images/1ba1099da14308619bec5a9d1dab12b3dbc79f21.png" style="width: 770px !important; height: 150.009px !important;"></p><p class=""><br></p><p class=""><strong>2.4、objectstore 提供实现备份的框架</strong></p><p class=""><br></p><p class="">Objectstore 模块是实现 BackupOperations 接口所需要的基本功能，目前实现了两种备份后端： S3 和 VFS。</p><p class=""><br></p><p class="">它提供了两种备份方案： DeltaBlockBackup（增量块）和 BackupFile（备份文件）。</p><p class=""><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p class=""><span style="font-size: 14px;">devicemapper 使用 DeltaBlockBackup 方式备份，实现了 DeltaBlockBackupOperations 接口。</span></p></li><li><p class=""><span style="font-size: 14px;">vfs 使用 BackFile 方式备份。</span></p></li><li><p class=""><span style="font-size: 14px;">Volume， Snapshot， Backup 用于管理备份存储的数据。</span></p></li><li><p class=""><span style="font-size: 14px;">ObjectStoreDriver 后端备份存储需要实现的接口。</span></p></li><li><p class=""><span style="font-size: 14px;">S3ObjectStoreDriver， VfsObjectStoreDriver 实现 ObjectStoreDriver。</span></p></li></ul><p class=""><br></p><p class="">Ebs 在实现 BackupOperations 接口时，使用 ebs 自身的 client 来实现 Backup。 ebs 本身就是一个分布式存储系统，不再需要额外的 objectstore 对其进行备份。</p><p class=""><br></p><p><img src="/ArchNotes/images/e3bb49620eac4c0be0c7b5b926e311d402f760d5.png" style="width: 770px !important; height: 578.912px !important;"></p><p class="" style="text-align: center;">图 6. objectstore 框架</p><p class=""><br></p><p class="">通过 vfs 备份的目录结构：</p><p><img src="/ArchNotes/images/d126d8921c0f1fb434e5c31145545ec3bb1afa7f.png" style="width: 770px !important; height: 191.866px !important;"></p><p class="">volume.cfg 的内容，保存图 6 中的 Volume 结构</p><p class=""><br></p><p><img src="/ArchNotes/images/eb6c9b9af5682e12d269e9b28b038482959b736c.png" style="width: 770px !important; height: 99.4492px !important;"></p><p class="">backup_[ID].cfg，保存图 6 中的 Backup 结构<br></p><p class=""><br></p><p><img src="/ArchNotes/images/fa238d421e9935fb94448838519b329c172cb0c9.png" style="width: 770px !important; height: 102.903px !important;"></p><p><img src="/ArchNotes/images/cb4460ebc43fafa93cecd4a18031de9fc41a31c4.png" style="width: 770px !important; height: 408.467px !important;"></p><p class="">blocks 目录保存了 snapshot 存储的真实数据，以 block 的形式存储在不同目录。</p><p class=""><br></p><p><img src="/ArchNotes/images/a049f3e947097d7c4daaf647dfaccd3f72498c3c.png" style="width: 770px !important; height: 182.2px !important;"></p><p class=""><br></p><p class=""><span style="font-size: 20px;"><strong>三、容器、应用程序、持久化存储</strong></span></p><p class=""><br></p><p class="">容器与持久化存储，在我看来本不该拿来一起讨论，<strong>二者关联性是比较弱的。</strong></p><p class=""><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p class="">容器是一种打包方式，基于这种打包方式带来了一系列的好处，如部署、程序运行环境统一，编排，调度等，诚然这些貌似与外部持久化存储真心没太大关系。</p></li><li><p class="">对持久化存储真正有需求的是容器里面的应用程序，应用程序对存储的需求是多种多样的。</p></li></ul><p class=""><br></p><p class="">基于容器化应用程序带来的好处，运维工程师都是期望能将更多的应用程序容器化，以减轻运维负担。</p><p class=""><br></p><p class="">对于无状态应用程序，容器化几乎带来的只有好处。</p><p class=""><br></p><p class="">对于一些有状态的应用程序，如数据库，需要进行容器化时，便面临持久化存储的问题。下面是一个外部持久化存储解决 MySQL 容器化问题的例子。</p><p class=""><br></p><p class="">三台运行 MySQL 数据库的主机将持久化存储系统的虚拟磁盘映射上， MySQL 将数据写入这些虚拟磁盘中。</p><p class=""><br></p><p><img src="/ArchNotes/images/27f9510450d145a8b58a6fb8e25f8a291b880a6d.png" style="width: 615px !important; height: 428px !important;"></p><p class=""><br></p><p class="">当其中一个 MySQL 数据库发生故障时，在新的主机上将故障主机的虚拟磁盘映射上，供 MySQL 使用，可以快速恢复数据库故障。</p><p class=""><br></p><p><img src="/ArchNotes/images/0bc00766d2feb3abf26be534e4d31ccc75477444.png" style="width: 706px !important; height: 415px !important;"></p><p class=""><br></p><p class="">此时，将 MySQL 数据库容器化将变得十分简单，编排调度系统，能够快速发现 MySQL 集群异常，并快速调度其他主机上，减少故障时间。</p><p class=""><br></p><p><img src="/ArchNotes/images/b9dedc357b48354f0bef22fb814df6805d9d87ac.png" style="width: 628px !important; height: 335px !important;"></p><p class=""><br></p><p class="">由上述讨论，其实无论容器在或不在，存储还是存储。当然为了适应容器的快速迁移（相对于虚拟机），多种多样的应用程序对存储也提出了细粒度控制、应用感知、快速创删等新的需求，但存储作为以稳定性为重的基础设施，依然万变不离其宗。</p><p class=""><br></p><p class=""><span style="font-size: 20px;"><strong>四、持久化存储系统的选择</strong></span></p><p class=""><br></p><p class="">持久化存储系统可分为开源存储系统和商业存储系统。通常商业存储系统会由厂商解决所有问题，这里就不谈商业化存储了。</p><p class=""><br></p><p class="">开源分布式存储方案如下：</p><p class=""><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p class="">块存储： ceph rbd， sheepdog</p></li><li><p class="">文件存储： glusterfs， cephfs， HDFS</p></li><li><p class="">对象存储： OpenStack swift， ceph rgw<br></p></li></ul><p class=""><br></p><p class="">块存储、文件存储、对象存储三种存储访问方式不同的存储系统，最合适容器的，我想应该是对象存储系统，对象存储系统是通过 URL 访问的，应用程序只需要知道对象存储系统的 URL 就可以直接访问存储系统，这种方式更贴近容器的无状态、临时性和快速调度。</p><p class=""><br></p><p class=""><strong>为什么选择分布式存储系统？</strong></p><p class=""><br></p><p class="">1、云计算时代，传统存储不能满足虚拟化、容器对存储的需求<br></p><p class=""><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p class="">传统存储缺少灵活性，虚拟机、容器的部署及其负载是快速变化的，并且容器还是快速迁移的。</p></li><li><p class="">传统存储缺少自动化</p></li><li><p class="">传统存储缺少细粒度控制</p></li><li><p class="">传统存储的配置是非常严格的</p></li></ul><p class=""><br></p><p class="">2、构建存储的 TCO( 总拥有成本 ) 十分高昂<br></p><p class=""><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p class="">数据量成指数级增长，但存储的预算却没有相应的增长，传统存储的价格是无法承受之痛。</p></li><li><p class="">数据规模快速增长，企业往往需要过度预算，过度采购，因为传统存储的扩展，升级和替换是十分昂贵的。</p></li></ul><p class=""><br></p><p class="">3、高昂的存储系统运营成本 (OPEX)<br></p><p class=""><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p class="">需要专业的存储管理团队，不仅需要学习专业的存储知识，还要学习存储厂商指定的技巧。</p></li><li><p class="">处理存储系统问题是相当花费时间。</p></li></ul><p class=""><br></p><p class="">当然开源分布式存储系统，只解决了第 1， 2 点，第 3 点并没有得到有效的解决，反而有点加深的趋势。</p><p class=""><br></p><p style="font-size: 16px; white-space: normal; max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 20px; box-sizing: border-box !important; word-wrap: break-word !important;">Q&amp;A</span></strong></p><p><br></p><p class=""><strong><span style="font-size: 14px;">提问：请问有没有对 Flocker、 Rancher Convoy， REX-Ray 进行对比，性能，可用性及易用性？</span></strong></p><p class="">张朝潞： Docker volume plugin 只做管理，数据流并不经过这三种插件，我们对比过 Flocker 和 convoy， flocker 成熟一些，但是两者都没达到我们项目的要求，因为这些插件开发起来比较简单，我们就自己做了一套，主要是解决高可用的问题。<br></p><p class=""><span class=""></span></p><p class=""><br><span class=""></span></p><p class=""><span style="font-size: 14px;"><strong>提问：请问实际环境中分布式存储和容器应用运行需要注意哪些问题，数据库程序在容器中运行结合分布式存储做持久化有实际的生产环境案例吗？</strong></span></p><p class="">张朝潞：分布式存储作为基础设施必须要稳定，目前看来容器并没有对存储提出革命性的变革。但借助外部存储可以使系统更大程度的容器化，从而得到一系列容器带来的好处。容器结合 Ceph 的案例我们确实遇到过，但是是非关键数据小范围上生产环境，难点还是在存储上。<br><span class=""></span></p><p class=""><span class=""></span><br></p><p class=""><span style="font-size: 14px;"><strong>提问：贵司是 K 党还是 M 党？技术选型是怎么考虑的？</strong></span></p><p class="">张朝潞：我们深入研究过 Kuberntes 和 Rancher，最终选用 k8s，技术选型要根据公司内部研发人员的技术长处和兴趣点，无论是 K 或是 M 都能解决问题。<br><span class=""></span></p><p class=""><span class=""></span><br></p><p class=""><span style="font-size: 14px;"><strong>提问： gluster 与 Ceph 的区别是啥？应用场景有哪些不同？</strong></span></p><p class="">张朝潞： gluster 支持文件接口， Ceph 支持块，文件，对象接口；简单的 gluster 比较简单，社区版本就已经足够稳定，但是海量小文件问题比较突出。 Ceph 随着 OpenStack 已经十分火了，社区很活跃，也有不少存储厂商基于 Ceph 做分布式存储产品。<br><span class=""></span></p><p class=""><span class=""></span><br></p><p class=""><span style="font-size: 14px;"><strong>提问： convoy 不支持 Ceph？并没有说明 Docker 怎么与 Ceph 结合使用 ?</strong></span></p><p class="">张朝潞： convoy 不支持 Ceph，并且已经不再更新， Docker 跟 Ceph 结合非常简单，或者说 Docker 跟所有外部存储结合都非常简单，就像分享内容提到的满足几个接口就行了。<br><span class=""></span></p><p class=""><span class=""></span><br></p><p class=""><span style="font-size: 14px;"><strong>提问：对象存储，和块存储是不是有不同的技术选型？</strong></span></p><p class="">张朝潞：当然两者应用场景不一样，块存储主要是在虚拟化环境、数据库场景。对象存储优势在于大规模海量数据和 HTTP 接口上。 针对不同的应用场景选型，如果需要非常大规模的，跨区域的场景建议使用 OpenStack swift，简单好用。如果应用场景既需要块存储，对象存储只需要中小规模的情况，一个 Ceph 搞定所有，也是不小的诱惑。如果公司内部没有专业的研发和运维团队，谨慎使用开源存储上生产。<br><span class=""></span></p><p class=""><span class=""></span><br></p><p class=""><strong><span style="font-size: 14px;">提问：开源化存储 Ceph 和 sheepdog 的 IOPS 能达到多少？这两种存储的使用场景。</span></strong></p><p class="">张朝潞：具体的 IOPS 跟物理的存储介质和如何设置 Cache 的关系太大了， Ceph 用的最多的地方就是块存储， sheepdog 是块存储。个人感觉， Ceph 的设计比较学院派，大而全，数据拆分很细，元数据很多，维护难度较大，但是社区活跃，找人比较容易一些。 Sheepdog 体量小，架构复杂度较低，但出问题估计找人难度大。两者都可以块存储，应用场景类似。<br><span class=""></span></p><p class=""><span class=""></span><br></p><p class=""><span style="font-size: 14px;"><strong>提问： Docker 已经提供了 volume 功能， convoy 做为 Docker 的插件，在那方面有做改进或者优化？而且我们在实际部署 Docker 应用的时候，一般都没有考虑过存储的问题，都是通过存储工程师分配好的文件（包含共享存储），为何要引入 convoy？</strong></span></p><p class="">张朝潞： Docker 的 volume 是使用本地存储系统，通过 volume plugin 机制访问外部存储，如 convoy 就是 Docker volume plugin 的一种实现。<br><span class=""></span></p><p class=""><span class=""></span><br></p><p class="" style="white-space: normal;"><span style="font-size: 14px;"><strong>提问：贵司用 Docker 做块存储？为何不用 Ceph 呢？</strong></span></p><p class="" style="white-space: normal;">张朝潞： Ceph 复杂程度太大，自用都需要专门的运维与研发团队。想要产品化还是自研靠谱。<br><span class=""></span></p><p class=""><br></p><p class=""><strong><span style="font-size: 14px;">提问：能说下 Ceph 的瓶颈在哪方面吗？</span></strong></p><p class="" style="white-space: normal;">张朝潞：磁盘和网络，计算机体系结构中最慢的两个部件。 Ceph 的代码级没有什么可以优化的空间。当然 Ceph 的强一致性，造成 IO 路径加长会影响性能。<br><span class=""></span></p><p class=""><span style="font-size: 14px;"><strong><br></strong></span></p><p class=""><span style="font-size: 14px;"><strong>提问：我对最后那个 MySQL 的例子比较感兴趣，我的理解是三个 MySQL 实例同时连接到存储，然后一个挂了后，另起一个实例，我的问题是，这之前的三个存储是共享数据的 cluster 集群环境嘛？如果是怎么保证数据的一致性和写入冲突问题？</strong></span></p><p class="">张朝潞：多个 MySQL 最好不要挂同一个存储空间，数据的性能瓶颈在于存储端，多个挂一个存储卷并不会提升性能。通常都是有上层业务来实现分表分库，负载均衡，从而避免一致性问题。例子中是每个 MySQL 实例挂载一个单独卷。</p><p class=""><span class=""></span></p><p><br></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 20px; box-sizing: border-box !important; word-wrap: break-word !important;">推荐阅读</span></strong></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548247&amp;idx=1&amp;sn=99d0e90fa99deec3a7dab49eac418e5c&amp;chksm=813a7f4fb64df65946223f717a5231aae62edc5b6335613e45f8153367736ed480e9439d8906&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548247&amp;idx=1&amp;sn=99d0e90fa99deec3a7dab49eac418e5c&amp;chksm=813a7f4fb64df65946223f717a5231aae62edc5b6335613e45f8153367736ed480e9439d8906&amp;scene=21#wechat_redirect" style="color: rgb(0, 82, 255); text-decoration: underline; font-size: 14px;">数据库不适合Docker及容器化的7大原因</a><br></p></li><li><p><span style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548329&amp;idx=1&amp;sn=492072ce2ec0242343a0aa8a1db06502&amp;chksm=813a7eb1b64df7a75c846cbdf009c59c8bf3c49d91534b79eaf4a7b974b83f0505c2a9e4ef1a&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548329&amp;idx=1&amp;sn=492072ce2ec0242343a0aa8a1db06502&amp;chksm=813a7eb1b64df7a75c846cbdf009c59c8bf3c49d91534b79eaf4a7b974b83f0505c2a9e4ef1a&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"></a></span><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548305&amp;idx=1&amp;sn=b9b96c566e2cc9921d8bf102bb73af46&amp;chksm=813a7e89b64df79ffc26dce61bed64936904d455816f7e766dbc6dda21071b170bb44ccaaca6&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548305&amp;idx=1&amp;sn=b9b96c566e2cc9921d8bf102bb73af46&amp;chksm=813a7e89b64df79ffc26dce61bed64936904d455816f7e766dbc6dda21071b170bb44ccaaca6&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);">数据库容器化的价值——反驳数据库不适合容器化的错误观点</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548284&amp;idx=1&amp;sn=9243449fac7e86342f84da3a6a87453c&amp;chksm=813a7f64b64df6728b15072640657b9642aa87a0bc30107becffc890125d32d8ff4dd091c9bf&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548284&amp;idx=1&amp;sn=9243449fac7e86342f84da3a6a87453c&amp;chksm=813a7f64b64df6728b15072640657b9642aa87a0bc30107becffc890125d32d8ff4dd091c9bf&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">2016年容器技术思考: Docker, Kubernetes, Mesos将走向何方?</span></a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548329&amp;idx=1&amp;sn=492072ce2ec0242343a0aa8a1db06502&amp;chksm=813a7eb1b64df7a75c846cbdf009c59c8bf3c49d91534b79eaf4a7b974b83f0505c2a9e4ef1a&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548329&amp;idx=1&amp;sn=492072ce2ec0242343a0aa8a1db06502&amp;chksm=813a7eb1b64df7a75c846cbdf009c59c8bf3c49d91534b79eaf4a7b974b83f0505c2a9e4ef1a&amp;scene=21#wechat_redirect" style="color: rgb(0, 82, 255); text-decoration: underline; font-size: 14px;">管理数万个实例，服务上百个业务：kubernetes在腾讯游戏的使用及演进历程</a></p></li></ul><p><br></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;">本文为张朝潞在高可用架构的分享，转载请注明出处，技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。</span><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">高可用架构</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">改变互联网的构建方式</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/f6d330d516dce1ccc8afa78eadcccb86f8851363.jpeg" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 200px !important; height: 200px !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></strong></span><span style="max-width: 100%; font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">长按二维码 关注「高可用架构」公众号</span></p>
{% endraw  %}

