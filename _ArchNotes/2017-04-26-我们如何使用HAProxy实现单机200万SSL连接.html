---
title: 我们如何使用HAProxy实现单机200万SSL连接
author: Jesse 译
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1493342427&src=3&ver=1&signature=L9XD8GAQyzHEmNm3CARkqdiBak3LCAmIzPqaFlutSEzKVJEKz5KN5My*jr-6bBEedyFXj8pYJyJ0RJ0Mhavw838Q3ps4bh-yeXwRZ*SObgPzLGtFYoCRot61*laUqHYmlsh9fsJnSxg6D8YH*4NubqT2DVPMrzUMb8k7BSp*u3c=
date: '2017-04-26 00:00:00 +0000'

---

{% raw  %}
<p><span style="color: rgb(136, 136, 136); font-size: 14px;  background-color: rgb(255, 255, 255);">导读：架构师需要精确的了解服务的支撑能力，也希望通过调优来发挥单个节点最大的价值。本文分享了压测及调优 HAProxy 实现 200 万并发 SSL 连接的过程，由高可用架构翻译，转载请注明出处。</span></p><p><br></p><p><img src="/ArchNotes/images/17153267a22dc0ffb82511c802bd8399ece983c8.png" style="width: 770px !important; height: 390.019px !important; visibility: visible !important;"><br></p><p><br></p><p>先观察上面截图，可以看到两个关键信息：</p><p><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p>这台机器已经建立了 238 万个 TCP 连接</p></li><li><p>使用内存大约在 48G。</p></li></ul><p><br></p><p>下面将会介绍在单个 HAProxy 机器上实现这种规模访问所需的配置。本文是负载测试 HAProxy 系列文章的最后一篇。有时间的读者建议阅读本系列的前两篇（见文末链接），它将帮助您了解相应的内核调优方法。</p><p><br></p><p>在这个配置过程中，我们也使用了很多小组件帮助我们达到目标。</p><p><br></p><p>在展开最终 HAProxy 配置之前，我想给大家回顾一下负载测试的历程及想法，心急的读者可以直接跳到文章后段查阅相关 HAProxy 配置。</p><h2><br></h2><h2><strong><span style="font-size: 18px;">测试目标</span></strong></h2><p><br></p><p>我们要测试的组件是 HAProxy 1.6 版。生产环境是在 4 核 30 G 的机器上运行该软件，当前所有的连接都是非 SSL 的。<br><br>测试目标有两方面：<br></p><p><br></p><ol class="list-paddingleft-2"><li><p>当将整个负载从非 SSL 连接转移到 SSL 连接时，<strong>CPU 使用率增加的百分比</strong>。CPU 的使用率肯定会增加，这是由于 5 次握手的加长和数据包加密的开销所带来。</p></li><li><p>其次，希望能够测试单个 HAProxy 每秒请求数和最大并发连接数的上限</p></li></ol><p><br></p><p>目标一主要因为业务方面功能需要通过 SSL 进行通信。 目标二是为了可以在生产环境中部署最少规模的 HAProxy 机器。<br></p><p><br></p><h2><span style="font-size: 18px;"><strong>组件和配置</strong></span></h2><p><strong><br></strong></p><ul class="list-paddingleft-2"><li><p>使用多台客户端机器来执行 HAProxy 压力测试。</p></li><li><p>有各种配置的 HAProxy 1.6 的机器</p></li><ul class="list-paddingleft-2" style="list-style-type: square;"><li><p>4核，30G</p></li><li><p>16核，30G</p></li><li><p>16核，64G</p></li></ul><li><p>相关后端服务器，用于支持所有并发访问。</p></li></ul><h2><br></h2><h2><strong>HTTP 和 MQTT</strong></h2><p><br></p><p>我们的整个基础设施支持两种协议：<br></p><p><br></p><ul class="list-paddingleft-2"><li><p>HTTP</p></li><li><p>MQTT</p></li></ul><p><br></p><p>在我们的技术栈中，没有使用 HTTP 2.0，因此在 HTTP 上没有长连的功能。所以在生产环境中，单个 HAProxy 机器（上行 + 下行）的最大数量的 TCP 连接在（2 * 150k）左右。虽然并发连接数量相当低，但每秒请求的数量却相当高。<br><br>另一方面，MQTT 是一种不同的通信方式。它提供高质量的服务参数和持久的连接性。因此，可以在 MQTT 通道上使用双向长连通信。对于支持 MQTT（底层 TCP）连接的 HAProxy，在高峰时段会看到每台机器上大约有 600 - 700k 个 TCP 连接。<br><br>我们希望进行负载测试，这将为我们提供基于 HTTP 和 MQTT 连接的精确结果。<br><br>有很多工具可以帮助我们轻松地测试 HTTP 服务器，并且提供了高级功能，如结果汇总，将文本转换为图形等。然而，针对 MQTT，我们找不到任何压力测试工具。我们确实有一个自己开发的工具，但是它不够稳定，不足以支持这种负载。<br><br>所以我们决定使用客户端测试 HTTP 负载，并在 MQTT 服务器使用相同配置。<br></p><h2><br></h2><h2><span style="font-size: 18px;"><strong>初始化设置</strong></span></h2><p><br></p><p>考虑到相关内容对于进行类似的压力测试或调优的人来说有帮助，本文提供了很多相关细节，篇幅稍微有些长。<br></p><p><br></p><ul class="list-paddingleft-2"><li><p>我们采用了一台 16 核 30G 机器来运行 HAProxy，考虑到 HAProxy 的 SSL 产生的 CPU 巨大开销，因此没有直接使用目前生产环境。</p></li><li><p>对于服务器端，我们使用了一个简单的 NodeJs 服务器，它在接收到 ping 请求时用 pong 进行回复。</p></li><li><p>对于客户端，我们最终使用 Apache Bench。使用 ab 的原因是因为它是一个大家熟悉和稳定的负载测试工具，它也提供了很好的测试结果汇总，这正是我们所需要的。</p></li></ul><p><br></p><p>ab 工具提供了许多有用的参数用于我们的负载测试，如：<br></p><p><br></p><ul class="list-paddingleft-2"><li><p>-c，指定访问服务器的并发请求数。</p></li><li><p>-n，顾名思义，指定当前负载运行的请求总数。</p></li><li><p>-p，包含 POST 请求的正文（要测试的内容）。</p></li></ul><p><br></p><p>如果仔细观察这些参数，您会发现通过调整所有这三个参数可以进行很多排列组合。示例 ab 请求将看起来像这样<br></p><p><br></p><blockquote><p>ab -S -p post_smaller.txt -T application/json -q -n 100000 -c 3000 http://test.haproxy.in:80/ping</p></blockquote><p><br></p><p>这样的请求的示例结果看起来像这样<br></p><p><br></p><p><img src="/ArchNotes/images/db84ad1334209e1a5304b1ce111da0090b6cc177.png" style="width: 770px !important; height: 882.612px !important;"></p><p><br>我们感兴趣的数字是：<br></p><p><br></p><ul class="list-paddingleft-2"><li><p>99％ 的返回请求的响应延迟时间。</p></li><li><p>Time per request：每个请求的时间</p></li><li><p>No. of failed requests：失败请求数。</p></li><li><p>Requests per second: 每秒请求量</p></li></ul><p><br></p><p>ab 的最大问题是它不提供控制每秒发起请求量，因此我们不得不调整 -c 并发级别以获得所需的每秒钟请求数，并导致很多后文提到的问题和错误。<br></p><h2><br></h2><h2><span style="font-size: 18px;"><strong>测试图表</strong></span></h2><p><strong><br></strong></p><p>我们不能随机地进行多次测试来获得结果，这不会给我们提供任何有意义的信息。我们必须以某种具体的方式执行这些测试，以便从中获得有意义的结果。来看看这个图。<br></p><p><br></p><p><img src="/ArchNotes/images/de1b6e3090f495f5ea3e984b655a2e5e87896675.png" style="width: 650px !important; height: 500px !important;"></p><p><br></p><p>该图表明，在某一点之前，如果不断增加请求数量，延迟将几乎保持不变。然而，<strong>达到某个临界点</strong>，延迟将开始呈指数级增长。这就是该机器的临界点。<br></p><h2><br></h2><h2><span style="font-size: 18px;"><strong>Ganglia</strong></span></h2><p><br></p><p>在提供一些测试结果之前，我想提一下 Ganglia。</p><p><br></p><blockquote><p>Ganglia 是用于高性能计算系统（如集群和网格）的可扩展分布式监控系统。</p></blockquote><p><br></p><p>看看截图，了解 Ganglia 是什么，以及它提供的关于底层机器的信息。</p><p><br></p><p><img src="/ArchNotes/images/b4c7fefb729fc5756865e63be7554ed6ce93c82f.png" style="width: 770px !important; height: 304.92px !important;"></p><p><img src="/ArchNotes/images/f678e54c42c79be6a6b03af930edad742d5de29c.png" style="width: 770px !important; height: 334.95px !important;"></p><p><br></p><p>通过 Ganglia 可以监测 HAProxy 机器上一些重要参数。<br></p><p><br></p><ol class="list-paddingleft-2"><li><p><span style="background-color: rgb(214, 214, 214);">TCP &nbsp;established</span> 这告诉我们在系统上建立的 TCP 连接总数。注意：这是上行和下行连接的总和。</p></li><li><p><span style="background-color: rgb(214, 214, 214);">packets sent and received</span> 发送和接收的 TCP 数据包的总数。</p></li><li><p><span style="background-color: rgb(214, 214, 214);">bytes sent and received</span> 这将显示发送和接收的字节数。</p></li><li><p><span style="background-color: rgb(214, 214, 214);">memory</span> 随着时间的推移使用的内存数。</p></li><li><p><span style="background-color: rgb(214, 214, 214);">network</span>&nbsp;通过线路发送数据包而消耗的网络带宽。</p></li></ol><p><br></p><p>以下是通过通过负载测试找到的已知限制。</p><p><br></p><blockquote><p>700k TCP 连接，</p><p>50k 发送包数量，60k 接收包数量，</p><p>10-15MB 发送及接收的字节数，</p><p>14-15G 内存峰值，</p><p>7MB 带宽。</p><p><br></p><p>所有这些值都是基于每秒数据</p></blockquote><h2><strong><br></strong></h2><h2><strong>HAProxy Nbproc</strong></h2><p><br></p><p>最初，当我们开始测试 HAProxy 时，发现使用 SSL 情况下，CPU 很早就到了瓶颈，而每秒请求数都很低。 在使用 top 命令后，发现 HAProxy 只使用 1 个 CPU 核。 而我们还有 15 个以上的核没用。<br><br>Google 了 10 分钟后，我们在 HAProxy 中找到某个设置，可以让 HAProxy 使用多个核。<br><br><strong>它被称为 nbproc</strong>，具体设置请看这篇文章 [8]：<br><br>调整此设置是我们的负载测试策略的基础。 &nbsp;让我们可以方面的进行 HAProxy 组合以便测试。<br></p><h2><br></h2><h2><span style="font-size: 18px;"><strong>使用 AB 进行压力测试</strong></span></h2><p><br></p><p>当开始负载测试之旅时，我们不清楚应该测量的指标和需要达到的目标。<br><br>最初，我们只有一个目标：<strong>通过改变所有下面提到的参数来找到临界点</strong>。<br></p><p><br></p><p><img src="/ArchNotes/images/c79cd4b179dcef220e473c2b9ed5f85897c36229.png" style="width: 770px !important; height: 642.95px !important;"></p><p><br>我保留了各种负载测试结果的表格。 总而言之，做了 500 多次测试，以达到最终的效果。 您可以清楚地看到，每次测试都有很多不同的部分。<br></p><h3><br></h3><h3><strong>单客户端问题</strong></h3><p><br></p><p>我们看到客户端正在成为瓶颈，因为我们不断增加每秒的请求数。 ab 使用单个核，从文档中可以看出，它不提供使用多核的功能。<br><br>为了有效地运行多个客户端，我们发现一个有用的 Linux 工具叫做 Parallel [7]。 顾名思义，它可以帮助您同时运行多个命令来达到并行的目的。 正是我们想要的。<br><br>看一下使用 Parallel 运行多个客户端的示例命令。<br></p><p><br></p><p><img src="/ArchNotes/images/4969191a36d139199f84f30a1f7a27da82745c5f.png" style="width: 720px !important; height: 239px !important;"></p><p><br></p><p>上述命令将运行 3 个 ab 客户端击访问同一个 URL。 这有助于我们消除客户端瓶颈。<br></p><h2><br></h2><h2><strong><span style="font-size: 18px;">Sleep 及 Times 参数的问题</span></strong></h2><p><br></p><p>下面是 Ganglia 中的一些参数。让我们简单讨论一下。<br></p><p><br></p><ol class="list-paddingleft-2"><li><p><span style="background-color: rgb(214, 214, 214);">packets sent and received&nbsp;</span>为了产生更多数据，可以在 post 请求中添加更多数据</p></li><li><p><span style="background-color: rgb(214, 214, 214);">tcp_established</span> 这是想实现的目标。想象一下，如果单个 ping 请求大约需要一秒钟，那么每秒需要大约 700k 个请求来达到 tcp_established 的目标。现在这个数字在生产环境中可能看起来更容易达到，但是在测试场景中不太可能达到。</p></li></ol><p><br></p><p>我们在 POST 调用中加入了一个 sleep 参数，它指定了服务端发送返回之前需要 sleep 的毫秒数。这将模拟长时间运行的生产环境请求。如果让请求 sleep 20 分钟的话，只需要每秒发出 583 个请求就能达到 700k 并发连接的标准。<br></p><p><br></p><p>此外，我们还在 POST 调用中引入了另一个参数： times。服务器在返回请求时应该在 TCP 连接上写入响应的指定次数，这有助于模拟更多的数据。<br></p><h3><br></h3><h3><span style="font-size: 18px;"><strong>Apache Bench (AB) 的问题</strong></span></h3><p><br></p><p>虽然使用 AB 也得到了不少测试结果，但同时也遇到了很多问题。我不会在这里提到所有问题，因为不是这篇文章重点（下面介绍另一个客户端）。</p><p><br></p><p>我们非常满意从 ab 上获得的结果，但是它不支持在一段时间内生成所需指定的 TCP 连接数。不知何故，我们设置的 sleep 参数在 ab 上无法生效。</p><p><br></p><p>虽然在一台机器上可以运行多个 ab 客户端并且可以用工具合并结果，但是在多台客户机上运行此设置对我们来说仍然是一件痛苦的事情。那时我还没有听说过 pdsh [4] 这个工具。</p><p><br></p><p>此外，我们也没有关注过超时的问题。在 HAProxy，ab 客户端和服务器上有一些默认的超时设置，我们完全忽略了这些。后文会讲到。</p><p><br></p><p>我们一开始就提到通过临界点图来检测系统的上限，但讲了这么多有点偏离了最主要目标。然而，要得到有意义的结果只能着眼于这一点。</p><p><br></p><p>使用 AB 碰到的一个问题是到了某个点 TCP 连接数不再增加。我们有大约 40 - 45 个客户端运行在 5 - 6 台客户端机上，但依然不能达到想要的规模。理论上，TCP 连接的数量应该随着 sleep 时间的增加而增加，但对我们来说并非如此。</p><h2><br></h2><h2><span style="font-size: 18px;"><strong>引入 Vegeta</strong></span></h2><p><br></p><p>因此我们需要寻找一个负载测试工具，这些工具需要具有更好的扩展性和更好的功能性，最终，我们找到了 Vegeta [6]。<br></p><p><br>从我的个人经验来看，我已经看到 Vegeta 具有极高的扩展性，与 ab 相比，它提供了更好的功能。 在我们的负载测试中，单个 Vegeta 客户端能够产生相当于 15 倍 ab 的吞吐量。<br><br></p><p>下面，我将提供使用 Vegeta 的负载测试结果。<br></p><p><br></p><h2><strong><span style="font-size: 18px;">使用 Vegeta 进行负载测试</span></strong></h2><p><br></p><p>首先，看看我们用来运行一个 Vegeta 客户端的命令。 进行测试的命令称为 attack：（酷吧？）</p><p><img src="/ArchNotes/images/0b1e45f90ef96d04b387319183884d18f3d5f45a.png" style="width: 723px !important; height: 174px !important;"></p><p>我们太喜欢 Vegeta 提供的参数了，来看看下面的一些参数。</p><p><br></p><ol class="list-paddingleft-2"><li><p>-cpus = 32 指定此客户机要使用的 CPU 核数。 由于要生成的负载量，我们不得不将客户机扩展到 32 核 64G。 虽然上面的速度也不是特别高。 但是当有大量处于 sleep 状态的连接时，维持这些连接也会产生比较大的开销。</p></li><li><p>-duration = 10m 我想这是不言自明的。如果没有指定任何持续时间，测试将永远运行。</p></li><li><p>-rate = 2000 每秒请求的数量。</p></li></ol><p><br></p><p><img src="/ArchNotes/images/9658f8f55ec65f2b4c7c2292f4230d2f77848edb.png" style="width: 770px !important; height: 355.163px !important;"></p><p><br></p><p>所以如上图所示，我们在一台 4 核机器上每秒达到了 32k 请求量。 如果你记得临界点图，在这种情况下，非 SSL 请求的临时点是 31.5k。<br></p><p><br>从负载测试中看更多的结果。<br></p><p><br></p><p><img src="/ArchNotes/images/c0e7cfd0341552ff28ff386eaf2c2de434e3067a.png" style="width: 770px !important; height: 297.412px !important;"></p><p><br></p><p>16k 的 SSL 连接也不错。 请注意，在我们的负载测试过程中，必须从头开始，因为我们采用了一个新的客户端，它给了我们比 ab 更好的结果。 所以不得不再来一遍。<br></p><p><br></p><p><img src="/ArchNotes/images/7787b2ccce335bf16c732d2f2ed9e11ae8c93293.png" style="width: 770px !important; height: 260.837px !important;"></p><p><br></p><p>CPU 核数的增加导致机器在未达到 CPU 限制前，每秒可以用的请求数增加。<br><br></p><p>如果将 CPU 核数从 8 个增加到 16 个，我们发现每秒的请求数量并没有大幅度增加。如果在生产环境中使用 8 核机器，那么我们不会分配所有的核给 HAProxy，或者是它的任何其他进程。 所以我们决定用 6 核机器进行一些测试，看看是否能得到可接受的数字。<br></p><p><br></p><p><img src="/ArchNotes/images/e52268e2753942f5643f5ce9268b2ffe47dc0252.png" style="width: 770px !important; height: 187.688px !important;"></p><p><br></p><p>结果还不错。<br></p><h2><br></h2><h2><span style="font-size: 18px;"><strong>引入 sleep</strong></span></h2><p><strong><br></strong></p><p>我们现在对负载测试结果非常满意。 然而，这并没有模拟真正的生产场景。 当我们引入 sleep，才开始模拟生产环境的情况。<br></p><p><br></p><blockquote><p><span style="background-color: rgb(214, 214, 214);">echo "POST https://test.haproxy.in:443/ping" | vegeta -cpus=32 attack -duration=10m &nbsp;-header="sleep:1000" &nbsp;-body=post_smaller.txt-rate=2000 -workers=500 &nbsp;| tee reports.bin | vegeta report</span></p></blockquote><p><br></p><p>因此，x 毫秒的随机 sleep 时间将导致服务器 sleep 时间为 0 &lt; x &lt; 1000 。 因此上述负载测试将给出平均&nbsp;≥ 500ms 的延迟。</p><p><br></p><p><img src="/ArchNotes/images/1a11c1ebacfa03e7da83293e79c87ef1ed44ffdc.png" style="width: 770px !important; height: 205.012px !important;"></p><p><br></p><p>最后一个单元格中的含义是 TCP established, Packets Rec, Packets Sent</p><p><br></p><p>从表中可以看到，6 核机器可以支持的最大请求量从 20k 减少到 8k。 显然，sleep 有其影响，影响的是 TCP 连接的数量。 然而这距离我们设定的 700K 目标还很远。<br></p><h2><br></h2><h2><span style="font-size: 18px;"><strong>里程碑 #1</strong></span></h2><p><strong><br></strong></p><p>我们如何增加 TCP 连接的数量？ 很简单，不断增大 sleep 时间，连接数应该上升。 我们一直增加 sleep 时间并在 60 秒的 sleep 时间停了下来。 这意味着大约 30 秒的平均延迟。<br><br>Vegeta 可以提供成功请求百分比的结果参数。 我们看到，在上述的 sleep 时间，只有 50％ 的调用是成功的。 请看下面的结果。<br></p><p><br></p><p><br></p><p><img src="/ArchNotes/images/94b50199a2e82eeddef5c7194af3049b538990e8.png" style="width: 770px !important; height: 139.562px !important;"></p><p><br></p><p>我们达到了 400 万个 TCP 连接，在每秒 8k 请求和 60s 的 sleep 时间的情况下。 60000R 的 R 表示随机。</p><p><br></p><p>我们的第一个的发现是，在 Vegeta 中有一个默认的超时时间是 30 秒，这就解释了为什么 50％ 的请求会失败。 所以我们在后续测试中将超时调整到 70 秒，并随着需求的变化而不断变化。<br></p><p><br></p><p><img src="/ArchNotes/images/36c0a0a6177ba2bc54537244b919b33e74cfd63f.png" style="width: 770px !important; height: 414.837px !important;"></p><p><br>在客户端调整超时值之后，我们可以轻松地达到 700k 标准。 唯一的问题是这些不可持续，只是峰值的数据。 系统达到了 600k 或 700k 的峰值链接，但并没有坚持很长时间。<br><br>但是我们想要得到图上连接持续很久的效果<br></p><p><br></p><p><img src="/ArchNotes/images/ff9d229dc11ea6bb6c49f34963391e2dc62b7ed4.png" style="width: 770px !important; height: 333.988px !important;"></p><p><br></p><p><br></p><p>这显示了稳定保持 780k 连接的状态。如果仔细查看上面的统计信息，每秒的请求数量非常多。然而，在生产环境中，我们在单个 &nbsp;HAProxy 机器上的请求数量要少得多（约 300 个）。</p><p><br></p><p>我们确信，如果减少生产环境的 HAProxy 的数量（约 30 个，这意味着每秒 30 * 300〜9k 的连接），我们将会达到机器 TCP 连接限制，而不是 CPU。</p><p><br></p><blockquote><p>所以我们决定实现每秒 900 个请求、30MB/s 的网络流量，以及 210 万 TCP 连接。我们选用这些数字，因为这将是单个生产环境 HAProxy 机器的 3 倍流量。</p></blockquote><p><br></p><p>到目前为止，我们已经配置了 HAProxy 使用 6 核。我们只想测试 3 核，因为这是我们在我们的生产机器上使用的最简单的方法（如前所述，我们的生产机器是 4 核 30G，所以用 nbproc = 3 进行更改将是最简单的）。</p><p><br></p><p><strong style="font-size: 18px;">里程碑 #2</strong><br></p><p><br></p><p>现在我们对每秒请求的最大限制可以随机器不同而变化，所以我们只剩下一个任务，如上所述，实现 3 倍的生产负载：</p><p><br></p><ul class="list-paddingleft-2"><li><p>每秒 900 个请求</p></li><li><p>建立了 210 万个 TCP 链接。</p></li><li><p>30 MB/s 网络。</p></li></ul><p><br></p><p>在 220k 的测试环境下，我们再次陷入僵局。 无论客户机数量多少或睡眠时间多少，TCP 连接数似乎都停留在那里。<br><br>我们来看一些估算数据。 220k TCP 连接，每秒 900 个请求 = 110,000 / 900〜= 120 秒。达到了 110k，因为 220k 连接包括上行和下行。<br><br>当我们在 HAProxy 开启日志时，我们怀疑 2 分钟是系统某处的限制。 我们可以看到 120,000 ms 是日志中大量连接的总时间。<br></p><p><br></p><p><img src="/ArchNotes/images/f3568be4ff314ac9a76098e22ef9063aa3ceb0b2.png" style="width: 721px !important; height: 254px !important;"></p><p><br></p><p>在进一步调查中，我们发现 <strong>NodeJs 的默认请求超时为 2 分钟</strong>。 瞧！<br></p><p><br></p><p><img src="/ArchNotes/images/5448def4c26b52da6ba94e606f36bbcf71a0f250.png" style="width: 770px !important; height: 1002.92px !important;"></p><p><br></p><p>但我们的高兴显然很短暂，在 130 万，HAProxy 连接数突然下降到 0，并再次开始增长。我们很快检查了 dmesg 命令，里面可以查到 HAProxy 进程一些有用的内核信息。<br><br>基本上，HAProxy 进程已经耗尽内存。因此，我们决定增加机器内存，并将其转移到 nbproc = 3 的 16 核 64GB 的机器，经过调整，我们终于可以达到 240 万长连。<br></p><p><br></p><h2><strong><span style="font-size: 18px;">后端代码</span></strong></h2><p><br></p><p>下面是正在使用的后端服务器代码。 我们还在服务器代码中使用 statsd 来获取客户端接收的每秒请求的统计数据。<br></p><p><br></p><p><img src="/ArchNotes/images/c7a451165faeaf200d42f38d7a7d5948da6f9141.png" style="width: 644px !important; height: 647px !important;"></p><p><img src="/ArchNotes/images/8fea19a92612bf64cc31fce91e1b7636417de1bd.png" style="width: 652px !important; height: 348px !important;"></p><p><br></p><p>我们还有一个小脚本运行多个服务器。 我们有 8 台机器，每台机器部署了 10 个后端服务。 我们真的认为有条件的话可以进行无限扩容进行压测。<br></p><p><br></p><p><img src="/ArchNotes/images/8a3b1eddbba47fd003f19a254ad19ca3d57cd8ea.png" style="width: 645px !important; height: 309px !important;"></p><h2><br></h2><h2><strong><span style="font-size: 18px;">客户端代码</span></strong></h2><p><br></p><p>对于客户端，每个 IP 有最大 63k TCP 连接的限制。 如果您不确定这个概念，请参阅本系列之前的文章。<br><br>所以为了实现 240 万个连接（双向，来自客户机的是 120 万），我们需要约 20 台机器。 我们在所有机器上运行 Vegeta 命令，甚至找到了一种方法来使用像 csshx [3] 这样的工具，但仍然需要合并所有的 Vegeta 客户端的结果。<br><br>查看下面的脚本。</p><p><img src="/ArchNotes/images/892cfcc162bcf25236d3da8255148d13794ce2d5.png" style="width: 643px !important; height: 653px !important;"></p><p><br></p><p>Vegeta 提供了名为 pdsh [4] 的工具信息，可让您在多台计算机上同时运行命令。 此外，Vegeta 可以让我们将多个结果合并成一个，这就是我们想要的。<br></p><h2><br></h2><h2><strong><span style="font-size: 18px;">HAProxy 配置</span></strong></h2><p><br></p><p>下面可能是很多读者最关心的，我们在测试中使用的 HAProxy 配置。 最重要的部分是 nbproc 和 maxconn 参数。 maxconn 设置 HAProxy 允许提供的最大 TCP 连接数（单向）。<br><br>对 maxconn 设置的更改导致 HAProxy 进程的 ulimit 增加。 看看下面<br></p><p><br></p><p><img src="/ArchNotes/images/e356a03a8f83ed38415b1f6e56940ee407024ff4.png" style="width: 770px !important; height: 333.988px !important;"></p><p><br></p><p>最大打开文件已增加到 400 万，因为 HAProxy 的最大连接数设置为 200 万。<br><br>参阅文章 [5] 获得更多 HAProxy 优化。<br></p><p><br></p><p><img src="/ArchNotes/images/25a4c68618cc7943e874d6a672c744f6b469eea0.png" style="width: 770px !important; height: 754.6px !important;"></p><p><img src="/ArchNotes/images/a1d7c918a47be95034cc4f9b2f816ef62fa0addb.png" style="width: 770px !important; height: 810.425px !important;"></p><p><br></p><p><strong>相关链接</strong></p><p><br></p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p><span style="font-size: 14px;">系统一&nbsp;<span style="font-size: 14px; color: rgb(0, 82, 255);">https://medium.com/@sachinmalhotra/load-testing-haproxy-part-1-f7d64500b75d</span></span></p></li><li><p><span style="font-size: 14px;">系列二&nbsp;<span style="font-size: 14px; color: rgb(0, 82, 255);">https://medium.com/@sachinmalhotra/load-testing-haproxy-part-2-4c8677780df6</span></span></p></li><li><p><span style="font-size: 14px;">csshx: </span><span style="font-size: 14px; color: rgb(0, 82, 255);">https://github.com/brockgr/csshx</span></p></li><li><p><span style="font-size: 14px;">pdsh: </span><span style="font-size: 14px; color: rgb(0, 82, 255);">https://github.com/grondo/pdsh</span></p></li><li><p><span style="font-size: 14px;">haproxy 配置:&nbsp;<span style="font-size: 14px; color: rgb(0, 82, 255);">https://www.linangran.com/?p=547</span></span></p></li><li><p><span style="font-size: 14px;">Vegeta:&nbsp;<span style="font-size: 14px; color: rgb(0, 82, 255);">https://github.com/tsenart/vegeta</span></span></p></li><li><p><span style="font-size: 14px;">Parallel:&nbsp;<span style="font-size: 14px; color: rgb(0, 82, 255);">http://www.shakthimaan.com/posts/2014/11/27/gnu-parallel/news.html</span></span></p></li><li><p><span style="font-size: 14px;">nbproc setup: <span style="font-size: 14px; color: rgb(0, 82, 255);">http://blog.onefellow.com/post/82478335338/haproxy-mapping-process-to-cpu-core-for-maximum</span></span></p></li></ol><p><br></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 20px; box-sizing: border-box !important; word-wrap: break-word !important;">推荐阅读</span></strong></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548195&amp;idx=1&amp;sn=7668528e8521196f6ef122e85f6028e9&amp;chksm=813a7f3bb64df62dfabba5e9de1ac8373ece36c792a11e8255b57abdaeba8697236c6361f926&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548195&amp;idx=1&amp;sn=7668528e8521196f6ef122e85f6028e9&amp;chksm=813a7f3bb64df62dfabba5e9de1ac8373ece36c792a11e8255b57abdaeba8697236c6361f926&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">京东全链路压测军演系统(ForceBot)架构解密</span></a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=404402191&amp;idx=1&amp;sn=2d0a082e1da027a3b7988857d097d4e9&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=404402191&amp;idx=1&amp;sn=2d0a082e1da027a3b7988857d097d4e9&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">美团线上真实流量压测工具构建</span></a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547555&amp;idx=1&amp;sn=f56abeae32c906c441bb2754a80d8ce1&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547555&amp;idx=1&amp;sn=f56abeae32c906c441bb2754a80d8ce1&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);">10个互联网团队应对高压的容量评估与高可用体系:私董会1期</a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547431&amp;idx=1&amp;sn=744a42639e7c362a05aacbfbed6a988c&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547431&amp;idx=1&amp;sn=744a42639e7c362a05aacbfbed6a988c&amp;scene=21#wechat_redirect" style="color: rgb(0, 82, 255); text-decoration: underline; font-size: 14px;">大促系统全流量压测及稳定性保证——京东交易架构分享（含PPT）</a></p></li></ul><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">本文作者 Sachin Malhotra，由 Jesse 翻译，转载请注明出处，技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。</span><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">高可用架构</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">改变互联网的构建方式</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/f6d330d516dce1ccc8afa78eadcccb86f8851363.jpeg" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 200px !important; height: 200px !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></strong></span><span style="max-width: 100%; font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">长按二维码 关注「高可用架构」公众号</span></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1493342427&src=3&ver=1&signature=L9XD8GAQyzHEmNm3CARkqdiBak3LCAmIzPqaFlutSEzKVJEKz5KN5My*jr-6bBEedyFXj8pYJyJ0RJ0Mhavw838Q3ps4bh-yeXwRZ*SObgPzLGtFYoCRot61*laUqHYmlsh9fsJnSxg6D8YH*4NubqT2DVPMrzUMb8k7BSp*u3c=">微信地址</a> | <a href="https://medium.freecodecamp.com/how-we-fine-tuned-haproxy-to-achieve-2-000-000-concurrent-ssl-connections-d017e61a4d27"/>阅读原文</a>
{% endraw  %}

