---
title: 从持续集成到弹性缩扩容：一个容器案例落地问题的思考
author: 陈俊凯
date: '2017-04-12 00:00:00 +0000'

---

{% raw  %}
<p style="margin-right: 0em; margin-left: 0em; max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/39a780716609f5b768e5478d614b6cdb388455d5.jpeg" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 640px !important; height: 235px !important;"></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p></p><section data-mpa-template-id="167209" class="" data-mpa-color="#ffffff" style="margin-right: 0em; margin-left: 0em; max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><section style="padding-right: 10px; padding-left: 9px; max-width: 100%; font-size: 15px; letter-spacing: 1px; line-height: 1.8; color: rgb(60, 60, 60); text-align: justify; box-sizing: border-box !important; word-wrap: break-word !important;">容器是这两年最热的一个话题，去年大家都在谈 Mesos、Kubernetes、Swarm，究竟哪家的挖掘技术强，今年容器技术的进一步普及，更多的人更关心容器技术如何落地，下面我们就基于一个实际的案例来聊一下容器落地遇到的问题。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">背景：某银行数据中心计划搭建一个基于容器的PaaS平台</strong><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><section data-mpa-template-id="167215" class="" data-mpa-color="#ffffff" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section class="" style="padding-right: 10px; padding-left: 9px; max-width: 100%; font-size: 16px; font-weight: bold; text-align: center; line-height: 1.8; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; z-index: 10000; box-sizing: border-box !important; word-wrap: break-word !important;">持续集成</section><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/0bba824b5cb395f29bbee56bd4d37b72d522d5cb.png" style="font-weight: bold; text-align: center; display: inline-block; left: 0px; transform: rotateX(60deg); margin-top: 5px !important; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 632px !important; height: 33.575px !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></section><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">持续集成是容器一个绕不过去的话题，无论哪家容器厂商都一定会谈到，数人云关于持续集成，最开始用的是drone，一个小众的持续集成工具，将drone内置在平台上，通过平台的持续集成功能可以方便的实现持续集成的配置和管理。</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">drone 的坑</strong><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">一开始我们觉得这是一个很好的工具，但是后来发现其实没有想象中的那么美好，它的问题：<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="list-style-type: square;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">对SVN的支持不好</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">容易出问题，因为数人云平台所有的组件都是容器化的，所以若使用drone，则需要使用docker-in-docker技术，但是该技术已经是一个不再被维护的技术了，所以继续使用的风险很大。</p></li></ul><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">Jenkins是个好工具</strong><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">Jenkins是一个好工具，功能强大且稳定，基于Jenkins实现的持续集成基本没有花费什么开发的时间，通过脚本将代码构建和平台连接在一起即可轻松实现CI/CD。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">总结</strong></p><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">往往用户需要的并不是那些看起来很酷的功能，真正需要的是能够实际解决问题的方案，即使这个方案很普通。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><section data-mpa-template-id="167215" class="" data-mpa-color="#ffffff" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section class="" style="padding-right: 10px; padding-left: 9px; max-width: 100%; font-size: 16px; font-weight: bold; text-align: center; line-height: 1.8; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; z-index: 10000; box-sizing: border-box !important; word-wrap: break-word !important;">配置管理</section><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/0bba824b5cb395f29bbee56bd4d37b72d522d5cb.png" style="font-weight: bold; text-align: center; display: inline-block; left: 0px; transform: rotateX(60deg); margin-top: 5px !important; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 632px !important; height: 33.575px !important;"></p></section><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">在我看来，容器是一个革命性的产物，改变了软件交付的方式，它开箱即用的特性消灭了程序员常说的一句话 “在我这里运行时正常的啊！”； 它快速部署，环境无关的特性帮助运维人员提高了工作效率，但是任何事情都有其两面性，它的开箱即用，环境无关带来好处的同时，也带来了问题——配置文件。</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">传统应用在容器时代面临的第一个问题</strong><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">一般而言，每个程序都会有一个或多个配置文件，里边记录着DB地址、账号、密码、缓存地址等信息，在容器时代之前，应用程序一般的流转方式是“从开发-&gt;测试-&gt;生产”：</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="list-style-type: square;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">开发同学交付一个编译之后的二进制文件，源文件（解释执行）或者代码仓库中某一个tag，同时附带一个release notes；<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">测试同学拿到开发同学交付的内容后，就将其部署在自己的测试环境中，如果release notes中说明了有配置信息需要更新或依赖文件版本需要升级，会依照文件进行调整；</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">如果测试通过，确定可以投产，那么就将其交付给运维同学进行生产部署。</p></li></ul><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">此时有一个问题，开发、测试、运维每个环节都会自己维护配置文件，如果使用了容器，那么配置文件管理就是很麻烦的问题了，因为配置文件被放到了容器里，若想修改配置文件就不是那么简单的事情了，所以这就是传统应用在容器化时面临的第一个问题，当然这个问题也不是不能解决，一般而言，有以下几种解决方案：</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="list-style-type: square;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">挂盘，将配置文件放到外部存储中，然后将该目录挂到容器中；<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">生成新的镜像，基于Docker文件系统的特性，使用测试环境的配置文件覆盖开发环境的镜像，从而得到测试环境的镜像，同理，使用生产环境的配置文件覆盖开发环境的配置文件得到生产环境的镜像，使用该方案会导致每个环境都有一个镜像。</p></li></ul><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">容器时代配置管理的正确打开方式</strong><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">以上分析了传统应用容器化基本都会遇到的一个问题，而且也没有给出很好的解决方案，下面我们来谈下容器化时代配置管理的正确打开方式。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">其实通过上面问题的描述，我们可以很容易的找到问题的根本原因：配置文件本身是一个本地存储状态，要对其做无状态改造，对于配置管理的无状态改造一般是通过配置中心来完成的，即应用通过配置中心获取配置信息，无需读取本地配置文件，但是这个问题更麻烦，要解决这个问题需要首先解决两个问题：<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="list-style-type: square;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">要先有个配置中心</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">要改代码，使其可以适配配置中心</p></li></ul><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">随着容器的普及，未来配置中心肯定会逐渐成为程序的标配。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">最终选择的解决方案</strong></p><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">关于容器时代配置文件的问题，上边大概提到了3种方案，在最终落地的时候选择的是哪一种呢？<strong>答案是第二种——生成新的镜像</strong>。这是一个很保守的方案，为什么没有选择另外两种呢？ 我们来解释下原因：<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="list-style-type: square;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">方案一[挂盘]， 这个方案会给容器产生另外一个状态，外部文件，不符合cloud 的思想，pass；</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">方案三[配置中心]，成本太高，周期太长，而且需要改代码，往往之前的应用已经被维护了很多年，修改其配置接口，风险太大。</p></li></ul><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">总结</strong><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">虽然这个选择从技术上来看很保守，但是个人认为，使用一个不太优雅的方案帮助一个新技术快速落地，然后推动其快速前进，比一直纠结于方案是否高大上，是否优雅等，而导致新的技术一直被悬在空中更好，就像大家一直在争论Mesos、Kubernetes、Swarm究竟哪个更好，现在也没有一个结论，与其争论这么多虚的，不如仔细想一下自己的问题是什么，究竟哪个技术更适合自己。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><section data-mpa-template-id="167215" class="" data-mpa-color="#ffffff" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section class="" style="padding-right: 10px; padding-left: 9px; max-width: 100%; font-size: 16px; font-weight: bold; text-align: center; line-height: 1.8; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; z-index: 10000; box-sizing: border-box !important; word-wrap: break-word !important;">日志</section><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/0bba824b5cb395f29bbee56bd4d37b72d522d5cb.png" style="font-weight: bold; text-align: center; display: inline-block; left: 0px; transform: rotateX(60deg); margin-top: 5px !important; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 632px !important; height: 33.575px !important;"></p></section><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">目前使用ELK作为日志方案。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">传统应用的坑</strong></p><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">一般而言，传统的应用都是把日志写到一个指定的路径下，然后通过Logstash采集日志并送入Elasticsearch进行存储，但是这种应用如果直接容器化之后就会带来一个问题——应用的日志文件应该如何存储。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="list-style-type: square;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">方案一：放到容器里</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">方案二：挂盘，写到外部存储上</p></li></ul><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">两种方案都有一些问题：</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="list-style-type: square;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">放到容器里，逻辑上最简单，不需要做任何改动，但是它的问题是，怎么从容器中把日志取出来。</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">通过挂盘，把容器日志写到外部存储，然后沿用传统的Logstash + ES 的方式处理日志，听起来很美好，但是如何建立容器和日志的对应关系？<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li></ul><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">容器时代日志的正确打开方式</strong><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">按照之前的惯例，我们先提出在容器时代，日志的正确处理方式，如果应用使用Docker进行交付，不建议写日志文件，直接将日志写入标准输出即可，然后Logstash通过Docker的log-driver捕获日志，这样日志文件既不需要落盘，也使日志文件摆脱了状态，可以更容易的横向扩缩。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">最终选择的解决方案</strong></p><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">最终我们实现的是方案三，因为用户在我们的建议下，选择了将日志输出到标准输出。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">新的问题</strong></p><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">写日志的目的是为了看的，这是一个无比正确的废话，但是如何实时的看到需要的日志却成了我们面临的一个新问题。在容器时代之前，我们一般是通过tail来实时的看日志或者通过Kibana来分析日志。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">在容器的时代，通过Kibana看日志的方式没什么变化，但是看实时日志就有了一些问题，在用户采取了我们的建议将日志写入标准输出后可以比较优雅的处理日志了，但是另外一个问题出现了，实时日志没有了，因为日志已经被log-driver收走了，怎么办？虽然依然可以从ES中找到日志，但是由于ELK本身的机制，不能通过ELK看到实时日志。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">新的解决办法</strong></p><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">新的问题，需要新的办法来解决，如何解决，其实说穿了也简单，实现了一个log-agent的功能，可以将日志送到两个地方，Logstash和实时日志。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">总结</strong></p><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">事情就是这样，我们以为解决了一个问题的时候，往往一个新的问题又摆在前面，像容器落地这种事情，对传统应用的整体工作方式和流程都有很大的冲击，所以一定也会遇到同等规模的问题需要解决。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><section data-mpa-template-id="167215" class="" data-mpa-color="#ffffff" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section class="" style="padding-right: 10px; padding-left: 9px; max-width: 100%; font-size: 16px; font-weight: bold; text-align: center; line-height: 1.8; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; z-index: 10000; box-sizing: border-box !important; word-wrap: break-word !important;">监控</section><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/0bba824b5cb395f29bbee56bd4d37b72d522d5cb.png" style="font-weight: bold; text-align: center; display: inline-block; left: 0px; transform: rotateX(60deg); margin-top: 5px !important; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 632px !important; height: 33.575px !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></section>银行对监控是非常重视的，尤其是运维部门，所以为了满足客户的需求，我们实现了：<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="list-style-type: square;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">平台自身监控</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">宿主机监控</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">中间件监控</p></li></ul><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">监控本身是我们平台很重要的一个部分，但是在实际实施过程中发现，客户其实不是很在意做的监控页面，仪表盘等监控数据，他们自身有健全的监控平台，其实我们需要做的事情就是将我们的数据吐到他的平台上即可。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">总结</strong></p><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">世事难料，你永远不知道下一块巧克力什么味道，这个我们自身投入了很大精力和时间来实现的功能在用户那里就变成了一个对接的任务。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><section data-mpa-template-id="167215" class="" data-mpa-color="#ffffff" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section class="" style="padding-right: 10px; padding-left: 9px; max-width: 100%; font-size: 16px; font-weight: bold; text-align: center; line-height: 1.8; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; z-index: 10000; box-sizing: border-box !important; word-wrap: break-word !important;">弹性扩缩</section><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/0bba824b5cb395f29bbee56bd4d37b72d522d5cb.png" style="font-weight: bold; text-align: center; display: inline-block; left: 0px; transform: rotateX(60deg); margin-top: 5px !important; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 632px !important; height: 33.575px !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></section>弹性扩缩一直是容器厂家喜欢谈的一个口号，曾经有一度我们认为基于Docker的特性来实行弹性扩缩是一件很容易的事情，但是后来发现，这里其实有一个大坑。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">扩很容易，缩很难</strong></p><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">弹性扩容是一件比较容易的事情，我们只要对接监控数据，然后配置一些规则，即可触发应用容器个数增加，实现扩容，但是缩容就会面临几个问题：<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="list-style-type: square;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">什么时候缩容？</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">如何安全的缩容？</p></li></ul><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">什么时候缩容，这个问题相对来说还不是特别麻烦，可以设定一个指标，比如CPU，内存，IO等指标来触发缩容，这里只要做一些带有缓冲的规则，避免由于规则简单而导致的扩缩抖动即可。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">如何安全的缩容相当麻烦，缩容在本质上是要停掉一些容器的，如何判断这个容器是可以停止的，如果一个容器没有流量了，那么应该是可以被停止的，如何让一个容器的流量停止？可以通过前端负载进行控制，不往这个容器分发流量，那么前端的负载是如何判断应该如何往后端分发流量呢？这个有多重因素：<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="list-style-type: square;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">自身算法</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">应用程序本身是有状态的，需要保持会话</p></li></ul><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">从以上简单的分析中我们可以发现，缩容不是简单的条件符合了就可以做的事情，要想在不影响业务的情况下实现缩容，是一件非常麻烦的事情，它与平台架构，运行的程序的业务逻辑有很深的耦合。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">总结</strong></p><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">要实现自动的扩缩容，不是一件简单的事情，而是一个系统的工程。<br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">以上内容是基于数人云在某银行实施过程中总结出来的一些感悟，如果能给大家一些帮助，我们非常高兴，如果有问题，请指出来，我们共同提高，Docker到现在大概有3年多的历史，个人看来它距离真正落地还有很大一段路程要走，我们必须不停的摸索。</p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><section data-mpa-template-id="167209" class="" data-mpa-color="#ffffff" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section style="padding-right: 10px; padding-left: 9px; max-width: 100%; line-height: 1.8; box-sizing: border-box !important; word-wrap: break-word !important;"><section data-mpa-template-id="167215" class="" data-mpa-color="#ffffff" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section class="" style="padding-right: 10px; padding-left: 9px; max-width: 100%; font-size: 16px; font-weight: bold; text-align: center; line-height: 1.8; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; z-index: 10000; box-sizing: border-box !important; word-wrap: break-word !important;">Q&amp;A</section><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/0bba824b5cb395f29bbee56bd4d37b72d522d5cb.png" style="font-weight: bold; text-align: center; display: inline-block; left: 0px; transform: rotateX(60deg); margin-top: 5px !important; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 632px !important; height: 33.575px !important;"></p></section><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></section><blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section style="padding-right: 10px; padding-left: 9px; max-width: 100%; line-height: 1.8; box-sizing: border-box !important; word-wrap: break-word !important;"></section></blockquote><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">Q：我想问一下，日志打两份的话具体是怎么实现的呢，用到了哪些技术或现有的工具呢？</p><blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section style="padding-right: 10px; padding-left: 9px; max-width: 100%; line-height: 1.8; box-sizing: border-box !important; word-wrap: break-word !important;"></section></blockquote><blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section style="padding-right: 10px; padding-left: 9px; max-width: 100%; line-height: 1.8; box-sizing: border-box !important; word-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">A：我们自己实现了一个log-agent, 然后log-agent 可以实现这个功能。</p></section></blockquote><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">Q：如果应用有自己的写的日志，如log4j的，输出不到标准输出，还怎么处理？</p><blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section style="padding-right: 10px; padding-left: 9px; max-width: 100%; line-height: 1.8; box-sizing: border-box !important; word-wrap: break-word !important;">A：log4j貌似是可通过配置输出到标准输出的，另外如果有些应用不能输出到标准输出的，可以配置日志文件路径，我们会去读文件。</section></blockquote><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">Q：缩容的产生条件是否有比较好的解决方案，比如根据CPU、内存甚至业务规则多维度的进行考察？</p><blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section style="padding-right: 10px; padding-left: 9px; max-width: 100%; line-height: 1.8; box-sizing: border-box !important; word-wrap: break-word !important;">A：缩容很容易，但是麻烦的是如何安全的缩容，我理解这个环节其实是跟应用的逻辑有直接关系的，如果应用是一个无状态的应用，那么缩容非常简单，只需要在前端控制流量，然后停止容器即可，但是如果是有状态的应用，那么就有可能对用户造成影响。</section></blockquote><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">Q：配置管理这块，不断的覆盖会增加镜像体积，如何最大化减少镜像大小呢？</p><blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section style="padding-right: 10px; padding-left: 9px; max-width: 100%; line-height: 1.8; box-sizing: border-box !important; word-wrap: break-word !important;">A：首先，一个镜像最多被覆盖2，3次，测试镜像一次，生产镜像一次，而且配置文件一般是很小的，几乎对镜像大小没有影响。</section></blockquote><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">Q：测试环境配置文件覆盖开发环境镜像，是只用测试环境的docket file 吗？ 如果每天打版，会很麻烦吗？&nbsp;</p><blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section style="padding-right: 10px; padding-left: 9px; max-width: 100%; line-height: 1.8; box-sizing: border-box !important; word-wrap: break-word !important;">A：通过覆盖测试文件来解决环境问题，只是一个思路，不一定非要使用开发测试环境的信息，这个可以具体情况具体分析。</section></blockquote><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;">Q：log-agent具体实现呢，日志直接打给log-agent还是log-agent读取本地日志文件呢？或者说log-agent读取标准输出的内容呢？</p><blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><section style="padding-right: 10px; padding-left: 9px; max-width: 100%; line-height: 1.8; box-sizing: border-box !important; word-wrap: break-word !important;">A：log-agent可以通过Docker的log-driver获取标准输出的日志，同时也可以直接读取日志文件的日志。</section></blockquote></section></section></section><p></p><p><br></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 20px; box-sizing: border-box !important; word-wrap: break-word !important;">推荐阅读</span></strong></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548329&amp;idx=1&amp;sn=492072ce2ec0242343a0aa8a1db06502&amp;chksm=813a7eb1b64df7a75c846cbdf009c59c8bf3c49d91534b79eaf4a7b974b83f0505c2a9e4ef1a&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548329&amp;idx=1&amp;sn=492072ce2ec0242343a0aa8a1db06502&amp;chksm=813a7eb1b64df7a75c846cbdf009c59c8bf3c49d91534b79eaf4a7b974b83f0505c2a9e4ef1a&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">管理数万个实例，服务上百个业务：kubernetes在腾讯游戏的使用及演进历程</span></a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548284&amp;idx=1&amp;sn=9243449fac7e86342f84da3a6a87453c&amp;chksm=813a7f64b64df6728b15072640657b9642aa87a0bc30107becffc890125d32d8ff4dd091c9bf&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548284&amp;idx=1&amp;sn=9243449fac7e86342f84da3a6a87453c&amp;chksm=813a7f64b64df6728b15072640657b9642aa87a0bc30107becffc890125d32d8ff4dd091c9bf&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">2016年容器技术思考: Docker, Kubernetes, Mesos将走向何方?</span></a><br></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548247&amp;idx=1&amp;sn=99d0e90fa99deec3a7dab49eac418e5c&amp;chksm=813a7f4fb64df65946223f717a5231aae62edc5b6335613e45f8153367736ed480e9439d8906&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548247&amp;idx=1&amp;sn=99d0e90fa99deec3a7dab49eac418e5c&amp;chksm=813a7f4fb64df65946223f717a5231aae62edc5b6335613e45f8153367736ed480e9439d8906&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">数据库不适合Docker及容器化的7大原因</span></a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548305&amp;idx=1&amp;sn=b9b96c566e2cc9921d8bf102bb73af46&amp;chksm=813a7e89b64df79ffc26dce61bed64936904d455816f7e766dbc6dda21071b170bb44ccaaca6&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548305&amp;idx=1&amp;sn=b9b96c566e2cc9921d8bf102bb73af46&amp;chksm=813a7e89b64df79ffc26dce61bed64936904d455816f7e766dbc6dda21071b170bb44ccaaca6&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">数据库容器化的价值——反驳数据库不适合容器化的错误观点</span></a></p></li></ul><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">本文由数人云陈俊凯供稿，技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。</span><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">高可用架构</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">改变互联网的构建方式</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/f6d330d516dce1ccc8afa78eadcccb86f8851363.jpeg" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 200px !important; height: 200px !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></strong></span><span style="max-width: 100%; font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">长按二维码 关注「高可用架构」公众号</span></p><p><br></p>
{% endraw  %}

