---
title: 模块化还是微服务 - 为什么说大部分团队微服务化都走入了陷阱
author: Sander Mak
date: '2017-03-30 00:00:00 +0000'

---

{% raw  %}
<p><inherit style="display: block;"><span class="">网上已经有非常多从</span><span class="">单体</span><span class="">服务转移到微服务讨论</span><span class="">，但大家有没有反思过，</span><span class="">这种做法真的是最佳选择吗？&nbsp;</span><span class="">虽然</span><span class="">维护一个凌乱的</span><span class="">单体</span><span class="">应用有很多缺点</span><span class="">，</span><span class="">但有一个令人信服的替代方案经常被忽视：<strong>在服务内部实现良好的模块化</strong>。 下面我们来探讨这种替代方案，并展示它与微服务的关系。</span><br></inherit></p><p><span class=""><br></span></p><p><inherit style="display: block;"><strong><span class="" style="font-size: 15pt !important;">为了</span><span class="" style="font-size: 15pt !important;">模块化的微服务</span></strong></inherit></p><p><inherit style="display: block;"><span class=""><br></span></inherit><inherit style="display: block;"><span class="">“通过微服务，我们终于可以让团队独立工作”，或者“我们的</span><span class="">单体</span><span class="">服务太复杂，这会降低我们的</span><span class="">开发</span><span class="">速度”。这些说法是让开发团队走向微服务之路的众多原因之一。服务化另外的原因还包括可扩展性和弹性部署。工程师大多追求系统设计和开发的模块化方法，软件开发中的模块化可以归结为三个指导原则：</span></inherit></p><p><inherit style="display: block;"><br></inherit></p><ul class="list-paddingleft-2" style="padding-left: 2em; list-style-position: initial; list-style-image: initial; outline: none;"><li><p><strong><span class="">强封装：</span></strong><span class="">隐藏组件内部的实现细节，</span><span class="">让</span><span class="">不同部件之间的耦合度较低。团队可以在系统的解耦的部分单独工作。</span></p></li><li><p><strong><span class="">明确定义的接口：</span></strong><span class="">我们无法隐藏所有内容（否则系统将无法做任何有意义的事情），因此组件之间必须有定义良好且稳定的</span><span class="">&nbsp;</span><span class="">API。组件可以被符合接口规范的任何实现所替代.</span></p></li><li><p><strong><span class="">显式依赖：</span></strong><span class="">具有模块化系统意味着不同的组件必须一起工作，需要有一个表达他们的关系的好方法。</span></p></li></ul><p><span class=""><br></span></p><p><span class="">这些原则大部分情况是可以通过微服务来实现，一个服务只要有公开明确定义的接口（通常为 REST API），就可以以任何方式实现微服务。实施细节对服务来说是内部问题，可以在没有系统范围的影响或协调的情况下进行更改。微服务器之间的依赖关系在开发时通常不是很明确，从而导致可能的运行时服务编排失败。</span></p><p><inherit style="display: block;"><br></inherit></p><p>因此，微服务实现了重要的模块化原则，带来实质效益：</p><p><span class=""><br></span></p><ul class="list-paddingleft-2" style="padding-left: 2em; list-style-position: initial; list-style-image: initial; outline: none;"><li><p><span class="">团队可以独立工作和规模不同。</span></p></li></ul><ul class="list-paddingleft-2" style="padding-left: 2em; list-style-position: initial; list-style-image: initial; outline: none;"><li><p><span class="">微服务小而专注，降低复杂度。</span></p></li></ul><ul class="list-paddingleft-2" style="padding-left: 2em; list-style-position: initial; list-style-image: initial; outline: none;"><li><p><span class="">服务可以在内部进行更改或更换，而不影响全局。</span></p></li></ul><p><span class=""><br></span></p><p><strong>尽管如此，从一个单一的（虽然轻微肥胖的）应用程序进入到一个分布式的微服务系统，这带来了巨大管理复杂性。</strong>突然间，您需要持续部署许多不同的（可能是容器化的）服务。新的关注点开始出现：服务发现、分布式日志记录、跟踪等。你现在更容易出分布式服务各种错误。接口和配置管理的版本控制也成为新的需要关注的地方，问题的列表还会继续增长。（高可用架构小编注：以学习“新技术”为己任的工程师未必会这么想）</p><p><br></p><p><inherit>微服务之间连接的复杂性在于连接了所有微服务的业务逻辑，你不能简单粗暴分开你的单体式服务来实现微服务。虽然"意面代码"的单体服务是有问题的，但是引入网络边界放在新的服务之间，会使这些令人纠缠的问题升级到彻头彻尾的痛苦。</inherit></p><p><inherit style="display: block;"><span class="" style="font-size: 15pt !important;"><br></span></inherit><inherit style="display: block;"><strong><span class="" style="font-size: 15pt !important;">模块化的替代方案</span></strong></inherit></p><p><span class=""><br></span></p><p><span class="">这是否意味着我们要么必须维护混乱的单体服务，要么就需要淹没在微观服务的复杂性之间？其实，模块化也可以通过其他方式实现，我们只要在开发过程中有效地制定和实现边界，也可以通过创建一个结构良好的单体应用来实现这一点。而且如果只考虑模块化，我们可以从已有的编程语言和开发工具比如 IDE 中获得很多开发的便利，以实现模块化的原则。</span></p><p><span class=""><br></span></p><p><span class="">在</span><span class="">&nbsp;</span><span class="">Java</span><span class="">&nbsp;</span><span class="">中，有几个可以帮助应用模块</span><span class="">化的</span><span class="">系统。 OSGi</span><span class="">&nbsp;</span><span class="">是最知名的，</span><strong><span class="">随着</span><span class="">&nbsp;</span><span class="">Java 9</span><span class="">&nbsp;</span><span class="">的发布，本地模块系统被添加到</span><span class="">&nbsp;</span><span class="">Java</span><span class="">&nbsp;</span><span class="">平台本身。模块现在是 Java 语言</span><span class="">及</span><span class="">平台的一部分</span></strong><span class="">，作为一级结构，Java 模块可以表达对其他模块的依赖关系，并在强制封装实现类的同时公开导出接口。甚至</span><span class="">&nbsp;</span><span class="">Java</span><span class="">&nbsp;</span><span class="">平台本身（一个巨大的代码库）已经使用新的</span><span class="">&nbsp;</span><span class="">Java</span><span class="">&nbsp;</span><span class="">模块系统进行了模块化。在即将出版的</span><span class="">&nbsp;</span><span class="">Java 9</span><span class="">&nbsp;Modularity 一书</span><span class="">中，您可以</span><span class="">了解</span><span class="">使用</span><span class="">&nbsp;</span><span class="">Java 9</span><span class="">&nbsp;来实现</span><span class="">模块化开发的更多信息。</span></p><p><span class=""><br></span></p><p><span class="">其他语言提供类似的机制。例如，JavaScript</span><span class="">&nbsp;</span><span class="">获得了 ES2015 的模块系统。在此之前，Node.js 已经提供了一个用于</span><span class="">&nbsp;</span><span class="">JavaScript</span><span class="">&nbsp;</span><span class="">后端的非标准模块系统。然而，作为一种动态语言，JavaScript</span><span class="">&nbsp;</span><span class="">对于实现模块之间的接口（类型）和封装有较弱的支持。您可以考虑在</span><span class="">&nbsp;</span><span class="">JavaScript之上使用</span><span class="">&nbsp;</span><span class="">TypeScript</span><span class="">&nbsp;</span><span class="">来再次获得这一优势。</span></p><p><span class=""><br></span></p><p><span class="">Microsoft</span><span class="">&nbsp;</span><span class="">的</span><span class="">&nbsp;</span><span class="">.Net</span><span class="">&nbsp;</span><span class="">框架确实具有像</span><span class="">&nbsp;</span><span class="">Java</span><span class="">&nbsp;</span><span class="">这样的强类型，但是它</span><span class="">没有类似&nbsp;</span><span class="">Java</span><span class="">&nbsp;</span><span class="">即将</span><span class="">到来</span><span class="">的模块系统，</span><span class="">也</span><span class="">没有程序集之间的显式依赖。尽管如此，通过使用</span><span class="">&nbsp;</span><span class="">.Net Core</span><span class="">&nbsp;</span><span class="">中标准化的</span><span class="">&nbsp;</span><span class="">Inversion-of-Control</span><span class="">&nbsp;</span><span class="">模式和通过创建逻辑相关的程序集，可以实现良好的模块化架构。即使</span><span class="">&nbsp;</span><span class="">C++</span><span class="">&nbsp;</span><span class="">也正在考虑在将来的版本中添加模块系统。</span></p><p><span class=""><br></span></p><p><span class="">综上所述，许多语言正对模块化表示</span><span class="">重视</span><span class="">，这本身就是一个惊人的发展。</span></p><p><span class=""><br></span></p><p><span class="">当你使用开发平台的模块化功能时，就可以实现微服务相同的模块化优势。基本上，模块系统越好，在开发过程中获得的帮助越多。不同的团队可以在不同的部分工作，只要明确定义团队之间交互的接口。</span></p><p><span class=""><br></span></p><p><span class="">在部署时，所有模块组合在一个单独的单元中部署，这样可以防止微服务开发和管理带来的巨大复杂性和成本。当然，这也意味着您不能在不同的技术栈上构建每个模块。但是贵公司真的打算好使用异构技术栈来搭建同一个系统吗？</span></p><p><span class=""><br></span></p><p><inherit style="display: block;"><strong><span class="" style="font-size: 15pt !important;">设计模块</span><span class="" style="font-size: 15pt !important;">的哲学</span></strong></inherit></p><p><strong><span class=""><br></span></strong></p><p><strong><span class="">设计</span><span class="">模块需要与</span><span class="">设计</span><span class="">微服务一样保证设计</span><span class="">的</span><span class="">严谨性。</span></strong><span class="">模块应该对域的单个有</span><span class="">边</span><span class="">界</span><span class="">的</span><span class="">上下文建模。选择微服务边界是一个具有</span><span class="">重要</span><span class="">架构意义的决策，</span><span class="">选择</span><span class="">错误时会产生昂贵的后果。模块</span><span class="">的</span><span class="">边界更易于更改</span><span class="">，它</span><span class="">的重构通常由类型系统和编译器支持。重新划分微服务</span><span class="">需要</span><span class="">涉及到大量的</span><span class="">开发人员之间的</span><span class="">通信，以便</span><span class="">不会摧毁线上系统</span><span class="">。老实说</span><span class="">，</span><span class="">你</span><span class="">需要</span><span class="">经历多少次尝试才能得到</span><span class="">微服务合适</span><span class="">的界限？</span></p><p><span class=""><br></span></p><p><span class="">在许多方面，静态类型语言</span><span class="">中，</span><span class="">模块为明确定义的接口提供了更好的结构支持。通过另一个模块公开的类型化接口调用方法比在另一个微服务器上调用</span><span class="">&nbsp;</span><span class="">REST</span><span class="">&nbsp;</span><span class="">接口更加</span><span class="">鲁棒</span><span class="">。REST + JSON 是无处不在的，但是在没有（编译器检查）模式的情况下，它不是良好类型互操作性的标志。补充一点，通过网络进行（反）序列化仍然不是没有成本的。此外，许多模块系统允许您表达对其他模块的依赖。当试图违反这些依赖关系时，模块系统将不允许如此。微服务器之间的依赖关系只在运行时实现，导致难以调试系统。</span></p><p><span class=""><br></span></p><p><span class="">模块也是代码所有权的自然单元。团队可以负责系统中的一个或多个模块。与其他团队分享的唯一的东西就是模块的公共 API。在运行时，相比微服务来讲</span><span class="">，</span><span class="">模块之间的隔离较少。毕竟，一切仍然运行在相同的进程中。</span></p><p><span class=""><br></span></p><p><span class="">没有任何理由，</span><span class="">在单体应用中，</span><span class="">模块不能像微服务器一样拥有它的数据。模块化应用程序之间通过定义良好的接口或模块之间的消息</span><span class="">来共享数据</span><span class="">，而不是通过共享数据存储</span><span class="">，</span><span class="">与微服务的巨大差异在于一切都在同一个进程中。最终的一致性问题不应低估</span><span class="">，</span><span class="">使用模块，最终的一致性可以是一个</span><span class="">策略</span><span class="">的选择。或者，您只需“逻辑”地将数据分开存储在同一数据存储区中，并且仍然使用跨域事务。对于微服务，则没有选择：最终的一致性是必须的，您需要适应这点。</span></p><p><span class=""><br></span></p><p><inherit style="display: block;"><strong><span class="" style="font-size: 15pt !important;">微服务什么时候适合您的组织？</span></strong></inherit></p><p><span class=""><br></span></p><p><span class="">那么什么时候应该转向微服务器？</span><span class="">上面描述的都是如何</span><span class="">通过模块化来解决复杂性。对于这一点，微服务和模块化应用都可以做到。但到</span><span class="">各有</span><span class="">不同的挑战。</span></p><p><span class=""><br></span></p><p><strong><span class="">当您的组织处于</span><span class="">&nbsp;</span><span class="">Google</span><span class="">&nbsp;</span><span class="">或</span><span class="">&nbsp;</span><span class="">Netflix</span><span class="">&nbsp;</span><span class="">规模时，拥抱微服务是完全有道理的。</span></strong><span class="">您有能力建立自己的平台和工具包，而且工程师的数量也不允许任何</span><span class="">单体</span><span class="">服务</span><span class="">的可能</span><span class="">。但是大多数组织</span><span class="">都没有</span><span class="">在这个规模下运作。即使你认为你的组织有一天将成为一个十亿美元的独角兽，开始使用模块化</span><span class="">也</span><span class="">不会有太多的危害。</span></p><p><span class=""><br></span></p><p><strong><span class="">微服务</span><span class="">另一个好的理由</span><span class="">是，</span><span class="">不同的服务</span><span class="">可以</span><span class="">使用不同的技术栈。</span></strong><span class="">但是前提是</span><span class="">你必须拥有</span><span class="">足够</span><span class="">规模来吸引</span><span class="">开发人员</span><span class="">跨越这些不同的栈，并保持这些平台的运行。</span></p><p><span class=""><br></span></p><p><span class="">微服务还可以独立部署系统的不同部分，这在大多数模块化</span><span class="">系统中很</span><span class="">难（甚至是不可能）。隔离部署增加了系统的弹性和容错能力。此外，对于每个微服务器，伸缩能力可以不同。可以部署不同的微服务来匹配硬件。模块化整体式服务也可以水平缩放，但您需要将所有模块放在一起。尽管在实践中，你可以用这种方法得到很多好处，但是</span><span class="" style="font-size: 11pt;">这可能并不是最好的方式</span><span class="">。</span></p><p><span class=""><br></span></p><p><inherit style="display: block;"><strong><span class="" style="font-size: 15pt !important;">结论</span></strong></inherit></p><p><span class=""><br></span></p><p><strong><span class="">跟所有架构思路相似</span><span class="">，最好的选择是找到一个</span><span class="">折衷的</span><span class="">位置。</span></strong><span class="">两种方法都有适合的地方，</span><span class="">需要根据</span><span class="">环境，组织和应用程序本身</span><span class="">来做选择</span><span class="">。</span></p><p><span class=""><br></span></p><p><strong><span class="">在大部分情况何</span><span class="">不</span><span class="">考虑</span><span class="">从模块化</span><span class="">单体应用</span><span class="">开始？您随时可以选择转移至微服务。</span></strong><span class="">如果</span><span class="" style="font-size: 11pt;">您已经有明确的模块界限，</span><span class="">您也不必手术肢解您的</span><span class="">单体应用，</span><span class="">它甚至不是一个排他选择：您也可以在微服务内部使用模块。</span><span class="">因此也许</span><span class="">问题就变成了，为什么微服务必须“微”？</span></p><p><span class=""><br></span></p><p><strong><span class="">即</span><span class="">使</span><span class="">从模块化应用程序中脱离出来，服务也不必变</span><span class="">“微</span><span class="" style="font-size: 11pt;">”</span><span class="">才</span><span class="">可维护。</span></strong><span class="">在服务中应用模块化的原则使他们能够超越通常微服务</span><span class="">那种</span><span class="">复杂性。在这里有模块化和微服务共存的地方。通过减少您的架构中的服务数量</span><span class="">，</span><span class="">可以实现实际的成本节约。模块可以帮助构建和扩展服务，就像它们可以帮助构建单个整体式应用程序一样。</span></p><p><span class=""><br></span></p><p><strong><span class="">如果</span><span class="">您希望获得</span><span class="">模块化好处，请确保不要欺骗自己进入仅限微服务的心态。</span></strong><span class="">探索您最喜爱的技术堆栈中模块化功能或框架</span><span class="">，就可以</span><span class="">获得模块化设计的支持，而不必仅仅依靠约定来避免“意面</span><span class="">一样的</span><span class="">代码”。仔细</span><span class="">考虑是否需要</span><span class="">引入微服务带来的复杂性</span><span class="">，</span><span class="">有时你需要（但往往可以）找到更好的方法。</span></p><p><span class=""><br></span></p><p><span class="">原文：</span><span class=""><a style="background: transparent; outline: none; color: rgb(112, 177, 231); cursor: pointer !important;">https://www.oreilly.com/ideas/modules-vs-microservices</a></span></p><p><inherit style="display: block;"><br></inherit></p><p><span class="" style="   display: block; width: 613px; min-height: 60px; border-width: 1px; border-style: solid; border-color: transparent; text-align: center; "><img src="/ArchNotes/images/2ca4c8f9b4af8ac5640268a3d3faee73c866e441.jpeg" style="border-width: 0px; border-style: initial; border-color: initial; cursor: pointer; width: 158px !important; height: 158px !important;"></span></p><p><inherit style="display: block;"></inherit></p><blockquote><span class="" style="font-size: 11pt;">Sander Mak 是一名荷兰 Luminis 的研究员。 在 Luminis，他开发了系列模块化和可扩展的软件，大部分是基于 JVM 的。 他是即将出版的 O'Reilly Java 9 Modularity 的作者，他喜欢通过博客&nbsp;</span><span class="" style="font-size: 11pt;"><span style="color:#2b2b2b"><span style="font-size: 11pt;"><a style="background: transparent; outline: none; color: rgb(112, 177, 231); cursor: pointer !important;">http://branchandbound.net</a></span></span></span><span class="" style="font-size: 11pt;"><span style="color:#2b2b2b"><span style="font-size: 11pt;"><a style="background: transparent; outline: none; color: rgb(112, 177, 231); cursor: pointer !important;">&nbsp;</a></span></span></span><span class="" style="font-size: 11pt;">来分享知识。 可以通过 Twitter @Sander_Mak 联系。</span></blockquote><p><br></p><p><span class="" style="font-size: 11pt;"><br></span></p><p style="max-width: 100%; min-height: 1em; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 20px; box-sizing: border-box !important; word-wrap: break-word !important;">推荐阅读</span></strong></p><p style="max-width: 100%; min-height: 1em; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="max-width: 100%; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548321&amp;idx=1&amp;sn=e44e0717405865c1acb8a2f2788b9d56&amp;chksm=813a7eb9b64df7afacdb415dab29bcfb3d933a399c4070eb80b596b596ff8c65aefabe205d9d&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548321&amp;idx=1&amp;sn=e44e0717405865c1acb8a2f2788b9d56&amp;chksm=813a7eb9b64df7afacdb415dab29bcfb3d933a399c4070eb80b596b596ff8c65aefabe205d9d&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">从单体应用走向微服务:一次API Gateway升级的启示</span></a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547136&amp;idx=1&amp;sn=13f13bce3ed0ade574bfb243635c88a6&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547136&amp;idx=1&amp;sn=13f13bce3ed0ade574bfb243635c88a6&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">如何打造一键发布弹性伸缩微服务:应用上容器云干货案例</span></a></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548455&amp;idx=1&amp;sn=cf94a1414e51441ca9a89d45ddf6856a&amp;chksm=813a7e3fb64df72956c9a3af10572314d7e8abbbc8a0a0d21d1db2a4a10d03c4d916ca7be4a5&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548455&amp;idx=1&amp;sn=cf94a1414e51441ca9a89d45ddf6856a&amp;chksm=813a7e3fb64df72956c9a3af10572314d7e8abbbc8a0a0d21d1db2a4a10d03c4d916ca7be4a5&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">容器与持久化存储:容器的开源分布式存储方案选型</span></a><br></p></li></ul><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">本文为高可用架构翻译，转载请注明出处，技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。</span><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="max-width: 100%; min-height: 1em; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">高可用架构</strong></span></p><p style="max-width: 100%; min-height: 1em; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">改变互联网的构建方式</strong></span></p><p style="max-width: 100%; min-height: 1em; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/f6d330d516dce1ccc8afa78eadcccb86f8851363.jpeg" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 200px !important; height: 200px !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></strong></span><span style="max-width: 100%; font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">长按二维码 关注「高可用架构」公众号</span></p>
{% endraw  %}

