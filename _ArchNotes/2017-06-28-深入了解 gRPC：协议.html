---
title: 深入了解 gRPC：协议
author: 唐刘
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1499131380&src=3&ver=1&signature=iU4hCwtQzyv2pey6SDTnZwafWnzylf2tvmyp7DJaUVvr2xeBj8ZLzYvkqhreJEFaZsobw28ulAtit2G2Z12YqmrOSDh4P2NFPnxgS1dsCKlhDPlgy4Y3corJqpV6Cvd0njEaXEDyrZONrJ1PwmipXXkXj*K69qeNNgc4I0jOngs=
date: '2017-06-28 00:00:00 +0000'

---

{% raw  %}
<p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;"><span style=" color: rgb(136, 136, 136); border-width: 0px; border-style: initial; border-color: initial; ; ; ; ; ; ; ; ; ; ; ; ">gRPC&nbsp;</span><span style="color: rgb(136, 136, 136); font-size: 14px;  background-color: rgb(255, 255, 255);">是一个高性能、通用的开源RPC框架，其由 Google 主要面向移动应用开发并基于</span><span style=" border-width: 0px; border-style: initial; border-color: initial; ; ; ; ; ; ; ; ; ; ; ; ; ; ">HTTP/2&nbsp;</span><span style="color: rgb(136, 136, 136); font-size: 14px;  background-color: rgb(255, 255, 255);">协议标准而设计，基于&nbsp;ProtoBuf(Protocol Buffers) 序列化协议开发，且支持众多开发语言。本文作者深入研究了 gRPC 协议，对协议本身作出解构。</span></p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">gRPC 是基于 HTTP/2 协议的，要深刻理解 gRPC，理解下 HTTP/2 是必要的，这里先简单介绍一下 HTTP/2 相关的知识，然后再介绍下 gRPC 是如何基于 HTTP/2 构建的。<br></p><h2 style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ">HTTP/1.x</h2><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">HTTP 协议可以算是现阶段 Web 上面最通用的协议了，在之前很长一段时间，很多应用都是基于 HTTP/1.x 协议，HTTP/1.x 协议是一个文本协议，可读性非常好，但其实并不高效，笔者主要碰到过几个问题：</p><h3 style="box-sizing: border-box; font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-weight: 700; line-height: 1.7; color: rgb(47, 47, 47); margin-bottom: 15px; font-size: 22px; text-rendering: optimizeLegibility; white-space: normal;">Parser</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">如果要解析一个完整的 HTTP 请求，首先我们需要能正确的读出 HTTP header。HTTP header 各个 fields 使用&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">\r\n</code>&nbsp;分隔，然后跟 body 之间使用&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">\r\n\r\n</code>&nbsp;分隔。解析完 header 之后，我们才能从 header 里面的&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">content-length</code>&nbsp;拿到 body 的 size，从而读取 body。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">这套流程其实并不高效，因为我们需要读取多次，才能将一个完整的 HTTP 请求给解析出来，虽然在代码实现上面，有很多优化方式，譬如：</p><ul style="box-sizing: border-box; margin-bottom: 20px; word-break: break-word; margin-left: 22px; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;" class="list-paddingleft-2"><li><p>一次将一大块数据读取到 buffer 里面避免多次 IO read</p></li><li><p>读取的时候直接匹配&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">\r\n</code>&nbsp;的方式流式解析</p></li></ul><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">但上面的方式对于高性能服务来说，终归还是会有开销。其实最主要的问题在于，HTTP/1.x 的协议是 文本协议，是给人看的，对机器不友好，如果要对机器友好，二进制协议才是更好的选择。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">如果大家对解析 HTTP/1.x 很感兴趣，可以研究下&nbsp;http-parser，一个非常高效小巧的 C library，见过不少框架都是集成了这个库来处理 HTTP/1.x 的。</p><h3 style="box-sizing: border-box; font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-weight: 700; line-height: 1.7; color: rgb(47, 47, 47); margin-bottom: 15px; font-size: 22px; text-rendering: optimizeLegibility; white-space: normal;">Request/Response</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">HTTP/1.x 另一个问题就在于它的交互模式，一个连接每次只能一问一答，也就是client 发送了 request 之后，必须等到 response，才能继续发送下一次请求。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">这套机制是非常简单，但会造成网络连接利用率不高。如果需要同时进行大量的交互，client 需要跟 server 建立多条连接，但连接的建立也是有开销的，所以为了性能，通常这些连接都是长连接一直保活的，虽然对于 server 来说同时处理百万连接也没啥太大的挑战，但终归效率不高。</p><h3 style="box-sizing: border-box; font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-weight: 700; line-height: 1.7; color: rgb(47, 47, 47); margin-bottom: 15px; font-size: 22px; text-rendering: optimizeLegibility; white-space: normal;">Push</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">用 HTTP/1.x 做过推送的同学，大概就知道有多么的痛苦，因为 HTTP/1.x 并没有推送机制。所以通常两种做法：</p><ul style="box-sizing: border-box; margin-bottom: 20px; word-break: break-word; margin-left: 22px; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;" class="list-paddingleft-2"><li><p>Long polling 方式，也就是直接给 server 挂一个连接，等待一段时间（譬如 1 分钟），如果 server 有返回或者超时，则再次重新 poll。</p></li><li><p>Web-socket，通过 upgrade 机制显式的将这条 HTTP 连接变成裸的 TCP，进行双向交互。</p></li></ul><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">相比 Long polling，笔者还是更喜欢 web-socket 一点，毕竟更加高效，只是 web-socket 后面的交互并不是传统意义上面的 HTTP 了。</p><h3 style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ">Hello HTTP/2</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">虽然 HTTP/1.x 协议可能仍然是当今互联网运用最广泛的协议，但随着 Web 服务规模的不断扩大，HTTP/1.x 越发显得捉紧见拙，我们急需另一套更好的协议来构建我们的服务,于是就有了 HTTP/2。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">HTTP/2 是一个二进制协议，这也就意味着它的可读性几乎为 0，但幸运的是，我们还是有很多工具，譬如 Wireshark， 能够将其解析出来。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">在了解 HTTP/2 之前，需要知道一些通用术语：</p><ul style="box-sizing: border-box; margin-bottom: 20px; word-break: break-word; margin-left: 22px; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;" class="list-paddingleft-2"><li><p>Stream： 一个双向流，一条连接可以有多个 streams。</p></li><li><p>Message： 也就是逻辑上面的 request，response。</p></li><li><p>Frame:：数据传输的最小单位。每个 Frame 都属于一个特定的 stream 或者整个连接。一个 message 可能有多个 frame 组成。</p></li></ul><h3 style="box-sizing: border-box; font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-weight: 700; line-height: 1.7; color: rgb(47, 47, 47); margin-bottom: 15px; font-size: 22px; text-rendering: optimizeLegibility; white-space: normal;">Frame Format</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">Frame 是 HTTP/2 里面最小的数据传输单位，一个 Frame 定义如下（直接从官网 copy 的）：</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMiaiaXBYJJRpgP5IiboA3D3gK86rjMA9z8F1V4HMvXxjrP7UTax0SDZHsuKjwe7T9ouJ0kgjwCK8jLA/0?wx_fmt=png" style="width: 770px !important; height: 215.259px !important;"></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p>Flag 和 R：保留位，可以先不管。</p></li><li><p>Stream Identifier：标识所属的 stream，如果为 0，则表示这个 frame 属于整条连接。</p></li><li><p>Frame Payload：根据不同 Type 有不同的格式。</p></li></ul><p><br></p><p>可以看到，Frame 的格式定义还是非常的简单，按照官方协议，可以非常方便的写一个出来。</p><p><br></p><h3 style="box-sizing: border-box; font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-weight: 700; line-height: 1.7; color: rgb(47, 47, 47); margin-bottom: 15px; font-size: 22px; text-rendering: optimizeLegibility; white-space: normal;">Multiplexing</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">HTTP/2 通过 stream 支持了连接的多路复用，提高了连接的利用率。Stream 有很多重要特性：</p><ul style="box-sizing: border-box; margin-bottom: 20px; word-break: break-word; margin-left: 22px; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;" class="list-paddingleft-2"><li><p>一条连接可以包含多个 streams，多个 streams 发送的数据互相不影响。</p></li><li><p>Stream 可以被 client 和 server 单方面或者共享使用。</p></li><li><p>Stream 可以被任意一段关闭。</p></li><li><p>Stream 会确定好发送 frame 的顺序，另一端会按照接受到的顺序来处理。</p></li><li><p>Stream 用一个唯一 ID 来标识。</p></li></ul><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">这里再说一下 Stream ID，如果是 client 创建的 stream，ID 就是奇数，如果是 server 创建的，ID 就是偶数。ID 0x00 和 0x01 都有特定的使用场景。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">Stream ID 不可能被重复使用，如果一条连接上面 ID 分配完了，client 会新建一条连接。而 server 则会给 client 发送一个 GOAWAY frame 强制让 client 新建一条连接。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">为了更大的提高一条连接上面的 stream 并发，可以考虑调大&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">SETTINGS_MAX_CONCURRENT_STREAMS</code>，在 TiKV 里面，我们就遇到过这个值比较小，整体吞吐上不去的问题。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">这里还需要注意，虽然一条连接上面能够处理更多的请求了，但一条连接远远是不够的。一条连接通常只有一个线程来处理，所以并不能充分利用服务器多核的优势。同时，每个请求编解码还是有开销的，所以用一条连接还是会出现瓶颈。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">在 TiKV 有一个版本中，我们就过分相信一条连接跑多 streams 这种方式没有问题，就让 client 只用一条连接跟 TiKV 交互，结果发现性能完全没法用，不光处理连接的线程 CPU 跑满，整体的性能也上不去，后来我们换成了多条连接，情况才好转。</p><h3 style="box-sizing: border-box; font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-weight: 700; line-height: 1.7; color: rgb(47, 47, 47); margin-bottom: 15px; font-size: 22px; text-rendering: optimizeLegibility; white-space: normal;">Priority</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">因为一条连接允许多个 streams 在上面发送 frame，那么在一些场景下面，我们还是希望 stream 有优先级，方便对端为不同的请求分配不同的资源。譬如对于一个 Web 站点来说，优先加载重要的资源，而对于一些不那么重要的图片啥的，则使用低的优先级。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">我们还可以设置 Stream Dependencies，形成一棵 streams priority tree。假设 Stream A 是 parent，Stream B 和 C 都是它的孩子，B 的 weight 是 4，C 的 weight 是 12，假设现在 A 能分配到所有的资源，那么后面 B 能分配到的资源只有 C 的 1/3。</p><h3 style="box-sizing: border-box; font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-weight: 700; line-height: 1.7; color: rgb(47, 47, 47); margin-bottom: 15px; font-size: 22px; text-rendering: optimizeLegibility; white-space: normal;">Flow Control</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">HTTP/2 也支持流控，如果 sender 端发送数据太快，receiver 端可能因为太忙，或者压力太大，或者只想给特定的 stream 分配资源，receiver 端就可能不想处理这些数据。譬如，如果 client 给 server 请求了一个视频，但这时候用户暂停观看了，client 就可能告诉 server 别再发送数据了。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">虽然 TCP 也有 flow control，但它仅仅只对一个连接有效果。HTTP/2 在一条连接上面会有多个 streams，有时候，我们仅仅只想对一些 stream 进行控制，所以 HTTP/2 单独提供了流控机制。Flow control 有如下特性：</p><ul style="box-sizing: border-box; margin-bottom: 20px; word-break: break-word; margin-left: 22px; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;" class="list-paddingleft-2"><li><p>Flow control 是单向的。Receiver 可以选择给 stream 或者整个连接设置 window size。</p></li><li><p>Flow control 是基于信任的。Receiver 只是会给 sender 建议它的初始连接和 stream 的 flow control window size。</p></li><li><p>Flow control 不可能被禁止掉。当 HTTP/2 连接建立起来之后，client 和 server 会交换 SETTINGS frames，用来设置 flow control window size。</p></li><li><p>Flow control 是 hop-by-hop，并不是 end-to-end 的，也就是我们可以用一个中间人来进行 flow control。</p></li></ul><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">这里需要注意，HTTP/2 默认的 window size 是 64 KB，实际这个值太小了，在 TiKV 里面我们直接设置成 1 GB。</p><h3 style="box-sizing: border-box; font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-weight: 700; line-height: 1.7; color: rgb(47, 47, 47); margin-bottom: 15px; font-size: 22px; text-rendering: optimizeLegibility; white-space: normal;">HPACK</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">在一个 HTTP 请求里面，我们通常在 header 上面携带很多该请求的元信息，用来描述要传输的资源以及它的相关属性。在 HTTP/1.x 时代，我们采用纯文本协议，并且使用&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">\r\n</code>&nbsp;来分隔，如果我们要传输的元数据很多，就会导致 header 非常的庞大。另外，多数时候，在一条连接上面的多数请求，其实 header 差不了多少，譬如我们第一个请求可能&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">GET /a.txt</code>，后面紧接着是&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">GET /b.txt</code>，两个请求唯一的区别就是 URL path 不一样，但我们仍然要将其他所有的 fields 完全发一遍。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">HTTP/2 为了结果这个问题，使用了 HPACK。虽然 HPACK 的&nbsp;RFC 文档&nbsp;看起来比较恐怖，但其实原理非常的简单易懂。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">HPACK 提供了一个静态和动态的 table，静态 table 定义了通用的 HTTP header fields，譬如 method，path 等。发送请求的时候，只要指定 field 在静态 table 里面的索引，双方就知道要发送的 field 是什么了。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">对于动态 table，初始化为空，如果两边交互之后，发现有新的 field，就添加到动态 table 上面，这样后面的请求就可以跟静态 table 一样，只需要带上相关的 index 就可以了。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">同时，为了减少数据传输的大小，使用 Huffman 进行编码。这里就不再详细说明 HPACK 和 Huffman 如何编码了。</p><h3 style="box-sizing: border-box; font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-weight: 700; line-height: 1.7; color: rgb(47, 47, 47); margin-bottom: 15px; font-size: 22px; text-rendering: optimizeLegibility; white-space: normal;">小结</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">上面只是大概列举了一些 HTTP/2 的特性，还有一些，譬如 push，以及不同的 frame 定义等都没有提及，大家感兴趣，可以自行参考 HTTP/2&nbsp;RFC 文档。</p><h2 style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ">Hello gRPC</h2><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">gRPC 是 Google 基于 HTTP/2 以及 protobuf 的，要了解 gRPC 协议，只需要知道 gRPC 是如何在 HTTP/2 上面传输就可以了。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">gRPC 通常有四种模式，unary，client streaming，server streaming 以及 bidirectional streaming，对于底层 HTTP/2 来说，它们都是 stream，并且仍然是一套 request + response 模型。</p><h3 style="box-sizing: border-box; font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-weight: 700; line-height: 1.7; color: rgb(47, 47, 47); margin-bottom: 15px; font-size: 22px; text-rendering: optimizeLegibility; white-space: normal;">Request</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">gRPC 的 request 通常包含 Request-Headers, 0 或者多个 Length-Prefixed-Message 以及 EOS。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">Request-Headers 直接使用的 HTTP/2 headers，在 HEADERS 和 CONTINUATION frame 里面派发。定义的 header 主要有 Call-Definition 以及 Custom-Metadata。Call-Definition 里面包括 Method（其实就是用的 HTTP/2 的 POST），Content-Type 等。而 Custom-Metadata 则是应用层自定义的任意 key-value，key 不建议使用&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">grpc-</code>&nbsp;开头，因为这是为 gRPC 后续自己保留的。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">Length-Prefixed-Message 主要在 DATA frame 里面派发，它有一个 Compressed flag 用来表示该 message 是否压缩，如果为 1，表示该 message 采用了压缩，而压缩算啊定义在 header 里面的 Message-Encoding 里面。然后后面跟着四字节的 message length 以及实际的 message。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">EOS（end-of-stream） 会在最后的 DATA frame 里面带上了&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">END_STREAM</code>&nbsp;这个 flag。用来表示 stream 不会再发送任何数据，可以关闭了。</p><h3 style="box-sizing: border-box; font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-weight: 700; line-height: 1.7; color: rgb(47, 47, 47); margin-bottom: 15px; font-size: 22px; text-rendering: optimizeLegibility; white-space: normal;">Response</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">Response 主要包含 Response-Headers，0 或者多个 Length-Prefixed-Message 以及 Trailers。如果遇到了错误，也可以直接返回 Trailers-Only。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">Response-Headers 主要包括 HTTP-Status，Content-Type 以及 Custom-Metadata 等。Trailers-Only 也有 HTTP-Status ，Content-Type 和 Trailers。Trailers 包括了 Status 以及 0 或者多个 Custom-Metadata。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">HTTP-Status 就是我们通常的 HTTP 200，301，400 这些，很通用就不再解释。Status 也就是 gRPC 的 status， 而 Status-Message 则是 gRPC 的 message。Status-Message 采用了 Percent-Encoded 的编码方式，具体参考这里。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">如果在最后收到的 HEADERS frame 里面，带上了 Trailers，并且有&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">END_STREAM</code>&nbsp;这个 flag，那么就意味着 response 的 EOS。</p><h3 style="box-sizing: border-box; font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-weight: 700; line-height: 1.7; color: rgb(47, 47, 47); margin-bottom: 15px; font-size: 22px; text-rendering: optimizeLegibility; white-space: normal;">Protobuf</h3><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">gRPC 的 service 接口是基于 protobuf 定义的，我们可以非常方便的将 service 与 HTTP/2 关联起来。</p><ul style="box-sizing: border-box; margin-bottom: 20px; word-break: break-word; margin-left: 22px; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;" class="list-paddingleft-2"><li><p>Path :&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">/Service-Name/{method name}</code></p></li><li><p>Service-Name :&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">?( {proto package name} "." ) {service name}</code></p></li><li><p>Message-Type :&nbsp;<code style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ">{fully qualified proto message name}</code></p></li><li><p>Content-Type : "application/grpc+proto"</p></li></ul><h2 style=" box-sizing: border-box; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ">后记</h2><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">上面只是对 gRPC 协议的简单理解，可以看到，gRPC 的基石就是 HTTP/2，然后在上面使用 protobuf 协议定义好 service RPC。虽然看起来很简单，但如果一门语言没有 HTTP/2，protobuf 等支持，要支持 gRPC 就是一件非常困难的事情了。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">悲催的是，Rust 刚好没有 HTTP/2 支持，也仅仅有一个可用的 protobuf 实现。为了支持 gRPC，我们 team 付出了很大的努力，也走了很多弯路，从最初使用纯 Rust 的 rust-grpc 项目，到后来自己基于 c-grpc 封装了 grpc-rs，还是有很多可以说的，后面再慢慢道来。如果你对 gRPC 和 rust 都很感兴趣，欢迎参与开发。</p><p style="box-sizing: border-box; margin-bottom: 25px; word-break: break-word; color: rgb(47, 47, 47); font-family: -apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; font-size: 16px; white-space: normal;">gRPC-rs:&nbsp;<span style="color: rgb(0, 82, 255);">https://github.com/pingcap/grpc-rs</span></p><p style="max-width: 100%; min-height: 1em; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 20px; box-sizing: border-box !important; word-wrap: break-word !important;">推荐阅读</span></strong></p><p style="max-width: 100%; min-height: 1em; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="max-width: 100%; width: 728.641px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547134&amp;idx=1&amp;sn=44b97d6a5105498abd7aa3bba406157a&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">支撑微博千亿调用的轻量级RPC框架Motan正式开源</span></a></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=405781868&amp;idx=1&amp;sn=cbb10d37e25c76a1845f593a222da3c9&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">唯品会RPC服务框架与容器化演进</span></a></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=405037902&amp;idx=1&amp;sn=97d9af490eefc5d6158cb6b6a70f67e5&amp;scene=21#wechat_redirect" target="_blank" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">Rust语言入门、关键技术与实战经验</span></a><br></p></li></ul><p style="max-width: 100%; min-height: 1em; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">本文作者唐刘，转载自 PingCAP （微信号：pingcap2015），技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。</span><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="max-width: 100%; min-height: 1em; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">高可用架构</strong></span></p><p style="max-width: 100%; min-height: 1em; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">改变互联网的构建方式</strong></span></p><p style="max-width: 100%; min-height: 1em; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOPOK9rQud9XibGhPOPsA3gA8Wr4CEnzmhfZQzSGu0Q09GOuk18S9icZtuVnQewvyqZtOWyDnJPBDn1A/640?wx_fmt=jpeg" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 200px !important; height: 200px !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></strong></span><span style="max-width: 100%; font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">长按二维码 关注「高可用架构」公众号</span></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1499131380&src=3&ver=1&signature=iU4hCwtQzyv2pey6SDTnZwafWnzylf2tvmyp7DJaUVvr2xeBj8ZLzYvkqhreJEFaZsobw28ulAtit2G2Z12YqmrOSDh4P2NFPnxgS1dsCKlhDPlgy4Y3corJqpV6Cvd0njEaXEDyrZONrJ1PwmipXXkXj*K69qeNNgc4I0jOngs=">微信地址</a>
{% endraw  %}

