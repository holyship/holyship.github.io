---
title: Java 微服务框架新选择：Spring 5
author: Alexey Nesterov
date: '2017-04-21 00:00:00 +0000'

---

{% raw  %}
<p>在这篇文章中，我们将讨论即将发布的第五代 Spring 框架中的新概念—— “Functional Web Framework”，来看看它如何帮助我们构建轻量级的微服务。<br><br>你可能会对标题中出现的 “Spring” 和 “微服务框架”感到惊讶。但是确实如此，Spring 5非常适合成为你 Java Web 微服务框架的新选择。首先，为了避免混淆让我们来对“微服务”中的“微”达成共识：</p><p><br></p><ul class="list-paddingleft-2"><li><p>简洁 - 无需样板工程，无需额外设置</p></li><li><p>简单 - 没有任何“魔法”</p></li><li><p>易于部署 - 产生单一的可部署工件</p></li><li><p>容易运行 - 没有额外的依赖</p></li><li><p>轻量级 - 最小内存占用/CPU 使用</p></li><li><p>非阻塞 - 更好的并发性</p></li></ul><p><br></p><p>虽然 Spring Boot 已经能做到上述的一些点，但 Spring MVC 本身依然引入了很多魔法。比如 <code>@Controller</code> 这个广泛使用的注解就有点含糊不清，更不用说 Spring 的自动配置和组件扫描等特性了。通常来说，这是开发一个大规模应用时可以承受的烦恼，毕竟 Spring 帮我们搞定了依赖注入、请求路由、各类复杂的配置等。然而，在微服务的世界中，应用程序只是类似一个大机器中运行的小齿轮，Spring Boot 就显得有些“杀鸡用牛刀”了。</p><p><br></p><p>为了解决这些问题，Spring 团队引出了一个名为“Functional Web Framework”的新概念，它是 Spring WebFlux（以前称为 Spring Reactive Web）这个大项目的一部分。同时也是我们现在要讨论的。</p><p><br></p><p>首先，让我们回顾一下基础知识，看看一个 Web 应用程序到底是什么样的，以及由什么组件构成。很显然，最基本的部分就是<strong>网络服务器</strong>（Web server）本身，为了避免手工解析 HTTP 请求，然后委派给应用程序的某个方法，我们需要一个<strong>请求路由器</strong>（router），同时我们也需要一个<strong>请求处理器</strong>或<strong>处理程序</strong>（handler），其实就是一段代码，它可以接受请求，做实际的逻辑处理，并最终返回一个响应。所有这些也正是 Spring Functional Web 所做的，它剥离了所有的抽象层（beans 和 contexts）。注意，这并不意味着它脱离并放弃了成熟的 Spring MVC 模型，而是提供了使用 Spring 来构建 Web 应用程序的另一种选择。</p><p><br></p><p><strong><span style="font-size: 18px;">请求处理器</span></strong></p><p><br></p><p>我们来看一下这个例子。 开始前请访问 <a>http://start.spring.io</a> 使用项目创建器创建一个新的空白工程，使用 Spring Boot 2.0 和 Reactive Web 作为唯一的依赖。 接着我们就可以定义第一个<strong>请求处理器或处理方法</strong>（handler）了，很简单，它接受请求并返回响应。</p><p><br></p><p><img src="/ArchNotes/images/50d9a8c5ae852318bd204827bb7dd92952a312a0.png" style="width: 692px !important; height: 129px !important;"></p><p><br></p><p>从上述代码可以看出来，它是 <code>HandlerFunction </code>接口的一个实现，定义了一个方法来获取一个<em>请求</em>（类型为 <code>ServerRequest</code>），并返回具有 <code>"Hello" </code>字符串的 <code>ServerResponse</code> 对象。 Spring 还提供了方便的<strong>构建器</strong>（builder）来构造响应。在我们的例子中，我们使用 <code>ok() </code>自动将返回码设置为 <code>HTTP 200 。</code>为了构造响应体，我们使用另一个叫 <strong>Mono</strong> 的概念，它代表 <strong>single reactive value </strong>，但我们这里先不管它，只要明白 <code>Mono.just(...) 是</code>一种通过返回 <code>Publisher 类型对象（其实是类似 Promise）</code>来实现非阻塞编程范式的方式。Reactive Web 是Spring 5 的一部分，它是通过 Java 9 的 <em>Reactive Stream</em> 来实现的。你可以参考 Dave Syer 的<a>这篇文章</a>。<br><br>我们还可以使用 Java 8 的 lambdas 表达式使代码更简洁，如下：</p><p><br></p><p><img src="/ArchNotes/images/329e814c4392ba58637aeba48ef7709b937601a7.png" style="width: 658px !important; height: 50px !important;"></p><p><br></p><h2><span style="font-size: 18px;"><strong>请求路由器</strong></span></h2><p><span style="font-size: 18px;"><strong><br></strong></span></p><p>上面我们已经有一个 handler 了，现在我们可以定义一个请求路由器了。 假设我们要使用 <code>GET</code> 方法请求 <code>"/"</code> 时调用我们的 handler。 为此，我们可以使用 <code>RouterFunction </code>。</p><p><br></p><p><img src="/ArchNotes/images/87a8e4a3aa2e3b2ad055c2fee38dc1dbdc794b25.png" style="width: 692px !important; height: 33px !important;"></p><p><br></p><p><code>route</code> 和 <code>GET</code> 都是 <code>RequestPredicates</code> 和 <code>RouterFunctions</code> 的静态方法，它们可以用来构建 <code>RouterFunction</code> 。它接受一个请求，检查它是否能匹配现有handler（比如请求路径（path）、请求方法（method）或者是内容类型（content type）等）。如果匹配则调用 handler。 在我们的例子中，HTTP 方法是 GET，请求路径是 <code>"/"</code>， handler 函数是上面定义的 <code>hello</code>。</p><p><br></p><h2><span style="font-size: 18px;"><strong>Web 服务器</strong></span></h2><p><span style="font-size: 18px;"><strong><br></strong></span></p><p>现在我们可以把他们组装在一起来完成整个应用程序。我们将使用非常轻量、简单的 Reactive Netty 作为 Web 服务器。要将我们的请求路由器集成到 Web 服务器中，我们需要将其转换为 <code>HttpHandler</code>。</p><p><br></p><p><img src="/ArchNotes/images/4f5bad1e77e0e368ba23ce0c9e71fd5c141f7f1a.png" style="width: 733px !important; height: 34px !important;"></p><p><br></p><p>接着这样来启动 Web 服务器：</p><p><br></p><p><img src="/ArchNotes/images/2158d3b59e3c5d53396a23080da85e5903ccc3c6.png" style="width: 725px !important; height: 94px !important;"></p><p><br></p><p><code>其中 ReactorHttpHandlerAdapter </code>只是一个包装了 <code>HttpHandler</code> 的 Netty 中的类，其余的代码非常简单直白。我们创建一个新的 Web 服务器，监听 localhost 地址的8080端口，并且添加我们的 HTTP handler，实际上这是我们的请求路由器的入口。</p><p><br></p><p>好了！整个应用程序已经差不多了，完整的代码如下：</p><p><br></p><p><img src="/ArchNotes/images/8d8ecec5dce9eaa89b346bbe111c8f21fc2e9e80.png" style="width: 733px !important; height: 334px !important;"></p><p><br></p><p>最后一行只是用来保持 JVM 进程一直运行。 你可能会发现整个应用程序启动飞快，这是因为没有任何组件扫描或配置注入发生，就像以前你们使用 Spring 会遇到的。<br><br>同时整个程序可以作为一个简单的 Java 应用程序来运行，不需要任何容器。<br><br>为了将整个应用打包和部署，我们仍然可以利用 Spring Maven 插件，只需执行以下操作：</p><p><br></p><p><img src="/ArchNotes/images/2561b1ea0594c97908e45c67af19369e63a05448.png" style="width: 674px !important; height: 30px !important;"></p><p><br></p><p>此命令将生成一个包含所有依赖关系的 fat jar，可以在仅安装了 JRE 的环境来部署和执行：</p><p><br></p><p><img src="/ArchNotes/images/a4370ac266b476f70422a92c987488fb0a536495.png" style="width: 674px !important; height: 32px !important;"></p><p><br></p><p>另外，如果我们想查看整个应用的内存使用情况，大概只有32MB左右，包括了22MB的 metaspace（你们知道用来存放加载的 classes）和大约10MB的 heap。就像前面提到的，整个框架和运行时环境只需要很少的资源。</p><p><br></p><h2><span style="font-size: 18px;"><strong>支持JSON</strong></span></h2><p><span style="font-size: 18px;"><strong><br></strong></span></p><p>在上面的示例中，我们返回一个字符串作为响应，但是想返回 JSON 对象也非常容易。<br><br>让我们创建一个新的可以返回 JSON 的 API endpoint 来扩展我们的应用。这个 data class 非常简单，只有一个名为 <code>name</code> 的字符串类型的字段。为了避免写那些冗长的 Java 样板代码（就像你们厌恶的 <code>setter</code>, <code>getter</code>），我们使用 <code><a>Project Lombok</a></code> 特性：使用 <code>@Data</code> 注解。通过在类上添加此注解，我们可以透明得获得 <code>getter</code>，<code>setters</code>，<code>equals</code> 和 <code>hashCode</code> 方法，而无须手动实现。</p><p><br></p><p><img src="/ArchNotes/images/d8f51044924cabbed14e318a14650013ecfaecaa.png" style="width: 733px !important; height: 90px !important;"></p><p><br></p><p>然后，我们需要扩展我们的请求路由器，以便为 <code>"/json" </code>路径的 GET 请求提供新的响应。 这可以通过在现有路由上调用 <code>andRoute(...)</code> 方法来完成。</p><p><br></p><p><img src="/ArchNotes/images/44bd94cb131915f1afb92f35a5a843dab5ac37c3.png" style="width: 770px !important; height: 247.535px !important;"></p><p><br></p><p>我们还优化了一点代码，将新的返回 JSON 的 handler 以内连的方式声明，同时将 <code>ok()</code> 静态导入，这使得代码变得更简洁。<br><br>重新启动后，应用程序将通过 <code>"/json"</code> 路径返回 <code>{"name": "world"}</code>，同时将响应头部中的内容类型（content-type）设置为 <code>application/json</code>。</p><p><br></p><h2><span style="font-size: 18px;"><strong>应用上下文</strong></span></h2><p><span style="font-size: 18px;"><strong><br></strong></span></p><p>你可能已经注意到整个代码中并没有定义应用上下文（Application Context）。是的，我们不再需要它！Spring WebFlux 中支持 <code>RouterFunction</code>，这样一个简单且轻量的 JSON 服务不再需要应用上下文。<br><br></p><h2><span style="font-size: 18px;"><strong>测试</strong></span></h2><p><span style="font-size: 18px;"><strong><br></strong></span></p><p>为了测试 reactive web application，Spring 提供了新的名为 <code>WebTestClient</code> 的客户端（类似于 <code>MockMvc</code>）。 我们将它绑定到我们的请求路由器上：</p><p><br></p><p><img src="/ArchNotes/images/564699a41de1f7f83182e599eb7db985304029eb.png" style="width: 770px !important; height: 506.14px !important;"></p><p><br></p><p><code>WebTestClient 有一组针对</code>返回结果的断言，以验证返回状态码，返回体，以及内容类型等等。</p><p><br></p><h2><span style="font-size: 18px;"><strong>总结</strong></span></h2><p><span style="font-size: 18px;"><strong><br></strong></span></p><p>Spring 5 引入了新的编程范式用来开发小型的、轻量级的、微服务式 Web应用程序。 我们显式得定义请求路由器和请求处理函数，在完全不需要应用上下文的情况下快速运行并部署。<br><br></p><h2><span style="font-size: 18px;"><strong>代码</strong></span></h2><p><span style="font-size: 18px;"><strong><br></strong></span></p><p>本文中所有代码均可以在<a>这里</a>访问到。</p><p>https://github.com/alek-sys/spring-functional-microframework</p><p><br></p><h2><span style="font-size: 18px;"><strong>参考</strong></span></h2><p><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p>https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework</p></li><li><p>https://spring.io/blog/2016/06/13/notes-on-reactive-programming-part-ii-writing-some-code</p></li><li><p>http://www.baeldung.com/spring-5-functional-web</p></li><li><p>https://spring.io/blog/2016/07/28/reactive-programming-with-spring-5-0-m1</p></li></ul><p><br></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; -webkit-text-size-adjust: 100%; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 20px; box-sizing: border-box !important; word-wrap: break-word !important;">推荐阅读</span></strong></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; -webkit-text-size-adjust: 100%; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; -webkit-text-size-adjust: 100%; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548609&amp;idx=1&amp;sn=4c76d4e83ef5def978a496dcb124dcee&amp;chksm=813a61d9b64de8cf6bc8eb8dedbce187881f468886842e24a1af2685ef40d815dc961fc458b6&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548609&amp;idx=1&amp;sn=4c76d4e83ef5def978a496dcb124dcee&amp;chksm=813a61d9b64de8cf6bc8eb8dedbce187881f468886842e24a1af2685ef40d815dc961fc458b6&amp;scene=21#wechat_redirect">程序员如何提问面试官？针对工程师、技术经理及CTO的提问指南</a></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548605&amp;idx=1&amp;sn=d9bf0f57ed4bc1c0fca75b980ba8cddb&amp;chksm=813a61a5b64de8b3c61eccaf71e1e2d835dba955a306328361807cec9adfbdbc682831e4e5c8&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548605&amp;idx=1&amp;sn=d9bf0f57ed4bc1c0fca75b980ba8cddb&amp;chksm=813a61a5b64de8b3c61eccaf71e1e2d835dba955a306328361807cec9adfbdbc682831e4e5c8&amp;scene=21#wechat_redirect">我们如何用Cassandra每天存储上亿条线上数据</a></p></li><li><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; word-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548596&amp;idx=1&amp;sn=5a90dc3c05c22f65dfcbe2427879e79c&amp;chksm=813a61acb64de8bae14775137f902c54e7744e8ff818f16e1a5e98c4c718858a0db76094053f&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548596&amp;idx=1&amp;sn=5a90dc3c05c22f65dfcbe2427879e79c&amp;chksm=813a61acb64de8bae14775137f902c54e7744e8ff818f16e1a5e98c4c718858a0db76094053f&amp;scene=21#wechat_redirect">为什么Slack等聊天工具不适合开源项目开发团队的沟通？</a><br></p></li></ul><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; -webkit-text-size-adjust: 100%; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; -webkit-text-size-adjust: 100%; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">本文作者 Alexey Nesterov，由魏佳翻译，转载请注明出处，技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。</span><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; -webkit-text-size-adjust: 100%; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; -webkit-text-size-adjust: 100%; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">高可用架构</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; -webkit-text-size-adjust: 100%; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">改变互联网的构建方式</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; -webkit-text-size-adjust: 100%; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/f6d330d516dce1ccc8afa78eadcccb86f8851363.jpeg" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 200px !important; height: 200px !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></strong></span><span style="max-width: 100%; font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">长按二维码 关注「高可用架构」公众号</span></p><p><span style="max-width: 100%; font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"><br></span></p><p><br></p>
{% endraw  %}

