---
title: Elasticsearch前沿：ES 5.x改进详解与ES6展望
author: 曾勇
date: '2017-04-14 00:00:00 +0000'

---

{% raw  %}
<p class=""><span style="color: rgb(136, 136, 136); font-size: 14px;">导读：本文介绍 Elasticsearch 最新的动态，包括 ES 5.x 改进详解与 ES6 展望，由曾勇在高可用架构群分享，转载请注明来自高可用架构公众号。</span></p><p class=""><br></p><blockquote><p class=""><span class=""></span></p><p><img src="/ArchNotes/images/0b36204cc175d33e38edf09f777a11d90e89d676.png" style="float: left; width: 133px !important; height: 133px !important; visibility: visible !important;"><span style="font-size: 14px; color: rgb(136, 136, 136);">曾勇（Medcl），Elastic&nbsp;工程师与布道师，2015&nbsp;年加入&nbsp;Elastic&nbsp;公司。加入&nbsp;Elastic&nbsp;之前，在搜索和运维等方面积累了超过七年的经验。Elasticsearch&nbsp;国内首批用户，自&nbsp;2010&nbsp;年起就开始接触&nbsp;Elasticsearch，是&nbsp;ES&nbsp;中文社区发起人，也是&nbsp;Elastic&nbsp;在中国的首位员工。</span></p></blockquote><p class=""><br></p><p>我最早是从 2010 年 3 月开始接触 Elasticsearch ，后面在 2015 年 9 月加入了 Elastic ，即 Elasticsearch 这款开源软件背后的公司，一直围绕在 ES 打转，也算是 ES 半个老司机了。</p><p class=""><br></p><p class="">自去年 10 月正式发布 5.0 以来， Elasticsearch 又新增了不少东西，让我们一起来看一下都有哪些值得关注的特性和改进吧。</p><p class=""><br></p><p class=""><strong><span style="font-size: 20px;">数据结构方面</span></strong></p><p class=""><br></p><p class="">首先是索引这块的改进，大家知道 ES 的数据支持增删改查，比如修改文档的时候其实是需要通过 ID 找到 Lucene 文件里对应的文档先删除然后再插入一个新的，所有写操作需要进行相应的版本检查来确保没有冲突。</p><p class=""><br></p><p class="">如果你的场景是日志，那么基本上数据进去之后是不需要进行修改的，所以现在 ES 新增了一个 append-only 的索引模式，也就是当 ES 是自动生成 ID 的时候， ES 可以跳过不必要的版本检测，<strong>大概可以提升 20% 左右的索引性能。</strong></p><p class=""><br></p><p class="">我们来看一组前后对比图吧，单这一块的提升还是可圈可点的。</p><p class=""><br></p><p><img src="/ArchNotes/images/90ef5adbd871c2ee9f0227dfec1c0bbbe57fc053.png" style="width: 617px !important; height: 301px !important;"></p><p class=""><br></p><p class="">在数据结构方面，新增了多个 range 字段类型，有什么用呢，现在你可以计算连续数据的交并集，可以是时间范围，也可以是数值范围。</p><p class=""><br></p><p class="">比如数据存放的是会议信息，航班有一个 range 字段，里面存的是会议的开始和结束时间，你通过对应的 range 查询可以很方便的查询，得到某个时间点哪些会议同时正在进行，那段时间会议室有空闲，可以预订等等。</p><p class=""><br></p><p class="">常见的场景，比如日历，电视节目单。</p><p class=""><br></p><p><img src="/ArchNotes/images/8b887339e268e49b9f99ff76b84ef23aeb540666.png" style="width: 770px !important; height: 598.047px !important;"></p><p class=""><br></p><p><img src="/ArchNotes/images/09eee9c4e63868c0056819ecfcd8e33c1bf9670a.png" style="width: 770px !important; height: 401.538px !important;"></p><p class=""><br></p><p class="" style="white-space: normal;">怎么使用呢？看例子会比较清晰一点。</p><p class=""><br></p><p class="">首先看看怎么定义吧，下面的这个例子， mapping 里面设置字段的 type 为 date_range 即表示一个时间的范围字段：</p><p class=""><br></p><p><img src="/ArchNotes/images/84f43572a42ccd7e8d2c31263da7fbdf40e564c4.png" style="width: 480px !important; height: 246px !important;"></p><p class=""><br></p><p class="">然后我们插入一些数据，可以看到指定的是一个范围，有起始值。</p><p class=""><br></p><p><img src="/ArchNotes/images/0cfbf89d4e8ac4a5c1098491649af253a996721a.png" style="width: 487px !important; height: 247px !important;"></p><p class=""><br></p><p class="">查询呢？</p><p class=""><br></p><p><img src="/ArchNotes/images/a20b759b0aa31be8c44e8e645295d1e98a627432.png" style="width: 488px !important; height: 249px !important;"></p><p><br></p><p>大概就是这么简单。</p><p class=""><br></p><p class=""><strong>下一个特性值得介绍的就是 _all 字段的移除</strong></p><p class=""><br></p><p class="">关于 _all 这个字段，场景其实就是为了满足快速检索的需求，当你不知道 mapping 里面有什么字段的情况下，你也能够自由的进行搜索， 所以为了实现这个需求，就有一个 _all 字段，它会把其他字段的内容都拷贝到这个字段里面，然后都当成 string 类型来处理，所以就存在了数据的冗余了，另外数字当成 string 也不能很好的压缩，并且都在 _all 一个字段，所以只能用一种分析器，在高亮的时候也是对这个 _all 字段进行的高亮，而不是真实的字段值，显示起来效果也不好。</p><p class=""><br></p><p>现在 query_string 和 simple_query_string 查询引入了一个 all_fields 模式，在没有指定字段的情况下，默认可以自动选择相关类型的字段分别执行查询，自动帮你展开，使用起来更加简单，另外， _all 字段将在 6.0 默认禁用且不可配置。</p><p class=""><br></p><p class="">这里有一个去掉 _all 字段的前后对比，可以看到磁盘占用少了不少，索引性能也有一些提升。</p><p class=""><br></p><p><img src="/ArchNotes/images/af3da55e67a26b2e6eeb85a9785acfa66aa936bf.png" style="width: 770px !important; height: 349.139px !important;"></p><p class=""><br></p><p class="">索引性能的提升，图上转折点就是。下面是对应的磁盘空间的下降。</p><p class=""><br></p><p><img src="/ArchNotes/images/93c851e60cbaf33cb2c9afa6aa5ef8cf65709ecd.png" style="width: 770px !important; height: 384.764px !important;"></p><p class=""><br></p><p class="">接下来，我们看看搜索的高亮，我们知道文本高亮是搜索体验的重要的一环，通过显示匹配结果的文本块并对关键字进行高亮能够让我们对搜索结果有一个直观的认识。</p><p class=""><br></p><p>现在有一个新的高亮器： Unified Highlighter，大家可能会问，目前 ES 默认已经提供了 3 种不同的高亮器，为什么还会有一个新的轮子呢，因为之前的用法有点复杂 , 用户选择起来比较困难，新的 unified highlighter 目的就是简化高亮的使用，可以支持前面 3 种高亮类型的自动选择。<br></p><p class=""><br></p><p class="">还有一个是 keyword 类型可以通过 normalizer 来进行标准化了， keyword 类型相比 text 类型就是不能分词，但是可能同样需要进行相应的标准化处理，比如统一转成小写，移除标点符号等等，使用方式和 analyzer 一样，比如下面的需求：</p><p class=""><br></p><p><img src="/ArchNotes/images/019cef4ff6e0c9a94f46515bfbdf2b3252f50aa3.png" style="width: 588px !important; height: 162px !important;"></p><p class=""><br></p><p class="">尽管设置了 keyword 类型，但是我同样是需要对文本进行处理的啊，用户不可能输入的完全都是一样，错一个大小写，可能就查不出来了。</p><p class=""><br></p><p class="">新的 normalizer 使用起来 很简单，和 analyzer 基本一样，专门用于 keyword 类型，如下：</p><p class=""><br></p><p class=""><img src="/ArchNotes/images/dacb4253d1e08af35270027351b81cdaa9dfa6b8.png" style="width: 625px !important; height: 515px !important;"><br></p><p class=""><br></p><p class="">另一个就是 Multi-Word Synonyms，之前是不支持同义词中间有空格分割的，分词的时候会帮你切分开，搜索的时候不能正确处理词组这种同义词，如下面的场景。</p><p class=""><br></p><p class="">这里有一组同义词，看起来没毛病。</p><p><img src="/ArchNotes/images/65c6976f5fe667b26f336a54239e5f4e852cbb91.png" style="width: 681px !important; height: 301px !important;"></p><p class="">有一个 phrase 查询，看起来也没毛病。</p><p><img src="/ArchNotes/images/9b2237ca59a77ea389b698840b307aa3230cc288.png" style="width: 514px !important; height: 227px !important;"></p><p><img src="/ArchNotes/images/217b2cbdae3e378cb31c69b46fdcc423d8b4ddd4.png" style="width: 682px !important; height: 135px !important;"></p><p class="" style="white-space: normal;">我的同义词过滤器就不对了，如下：</p><p class="" style="white-space: normal;"><br></p><p><img src="/ArchNotes/images/0776a8b9dab75c4be01903b812da6ee1ffed2b5c.png" style="width: 685px !important; height: 127px !important;"></p><p><br></p><p class="">new is old ？这是什么情况？</p><p class=""><br></p><p class="">因为分词的时候，把他们单个字拆开进行的同义处理。新的多词同义词采用 graph 方式处理，很好的解决了上面的问题。</p><p class=""><br></p><p><img src="/ArchNotes/images/9297582581b662723d54344049ae9f1e0b41154b.png" style="width: 679px !important; height: 292px !important;"></p><p class=""><br></p><p class="">同义词现在可以支持词组了，也就是说同义词如果是由多个词组成的，不会在分词的时候被傻傻的拆开，而是正确的处理。</p><p class=""><br></p><p class="">还一个就是字段折叠（ Field collapsing），这个特性比较有意思，你可以在搜索的时候，按某个字段作为维度进行去重，我这里写过一篇详细的博客，有兴趣的可以去看看：</p><p class=""><br></p><p class="">http://elasticsearch.cn/article/132</p><p class=""><br></p><p class=""><strong>Cancellable searches</strong></p><p class=""><br></p><p class="">ES 的搜索，对于一些耗时较长的查询，以前是没有办法取消的，除了干掉节点重来或者等待结束，没有办法，现在可以通过 ES 的任务管理机制来进行取消了， 5.3 已经提供。感兴趣的可以查看文档：</p><p class=""><br></p><p class="">https://www.elastic.co/guide/en/Elasticsearch/reference/5.3/search.html#global-search-cancellation</p><p class=""><br></p><p class=""><strong>Partitioned term aggs</strong></p><p class=""><br></p><p class="">ES 的聚合功能很强大吧， term aggs 相信也是大家常用的一种，如果遇到字段里面唯一 term 很多的场景，聚合起来不只是慢，可能还没法正常运行。</p><p class=""><br></p><p class="">现在 term aggs 提供了一种分区的概念，你可以对一个字段，分 n 次进行聚合，分而治之，有兴趣的可以看看文档：</p><p class=""><br></p><p class="">https://www.elastic.co/guide/en/Elasticsearch/reference/5.3/search-aggregations-bucket-terms-aggregation.html#_filtering_values_with_partitions</p><p class=""><br></p><p class="">另外，当你的集群变红的时候，你是不是手忙脚乱过，检查一大堆配置，访问一大堆接口来查看到底是哪里出了问题。</p><p class=""><br></p><p><img src="/ArchNotes/images/d10516fe32c03eba530b4b830037820bc9fb6b66.png" style="width: 686px !important; height: 342px !important;"></p><p class=""><br></p><p class="">现在方便了，新增的 /_cluster/allocation/explain 接口能够直接告诉你哪里出了问题：</p><p class=""><br></p><p style="white-space: normal;"><img src="/ArchNotes/images/605eea66126d4c91676b47b8434b46a1e7b7991f.png" style="width: 606px !important; height: 294px !important;"></p><p><img src="/ArchNotes/images/cceba134fb01588b8034ad127c6f92e409a41ff1.png" style="width: 621px !important; height: 290px !important;"></p><p>Java REST Client 也有了更新， ES 之前提供了一个偏底层的 Java HTTP REST client，但是用起来太费劲，需要手动拼 JSON，现在， Java REST Client 分成了 Java High Level REST Client 和 Java Low Level REST Client， High Level 基于 Low Level 来实现，顾名思义，提供更多用户方便的接口调用， High Level REST Client 将提供和 Transport Client 类似的接口，不用手动去拼接 QueryDSL 的 JSON 了，目测在 5.5 版本提供。<br></p><p class=""><br></p><p class="">听说你们有很多集群在跑？那你有没有用过 tribe node 来访问多个集群呢？， tribe-node 的工作方式是合并多个集群的元数据到一起，负责请求的转发。</p><p class=""><br></p><p><img src="/ArchNotes/images/7089be2f2a14a04f987c1ba77ff68185bd2f5af8.png" style="width: 600px !important; height: 288px !important;"></p><p class=""><br></p><p class="">大概就是这个图。</p><p class=""><br></p><p class="">不过 tribe-node 有几个问题，首先，他需要和各个集群的每个节点建立连接，另外 tribe-node 的 配置的静态的，修改之后需要重启 tribe-node，每个集群的元数据变化之后都需要进行合并，频繁的操作十分影响性能，并且集群的索引名称必须保证不能相同，同时，通过 tribe-node 只能只读，无法创建索引，再者，跨集群查询，会将所有的分片的数据都放到 tribe-node 上进行 reduce，如果分片很多，可能出现 OOM 等问题。</p><p class=""><br></p><p class="">新引入的 cross-cluster 跨集群功能就是为了方便以一种更优雅的方式来替换掉 tribe-node。</p><p class=""><br></p><p class="">先来上一张图，里面可以看到如何创建一个 cross-cluster。</p><p class=""><br></p><p><img src="/ArchNotes/images/ef137b680bd8dd40c341f81e8937313300b10c14.png" style="width: 682px !important; height: 367px !important;"></p><p class=""><br></p><p class="">可以看到，集群的任何节点都能执行跨集群操作，节点的元数据不需要频繁更新，集群间索引基于命名空间进行了隔离。</p><p class=""><br></p><p class="">什么是命名空间？</p><p class=""><br></p><blockquote><p class="">GET sales:*,r_and_d:logs*/_search</p><p class="">{<br></p><p class="">"query": { … }</p><p class="">}</p></blockquote><p class=""><br></p><p class="">可以看到上面的 QueryDSL，正常的索引前面有 namespace：这样的前缀，这就是命名空间，也就是选择不同的集群。</p><p class=""><br></p><p class="">不仅可以动态设置多个集群的访问，也不需要重启节点。集群间互相不受影响，更没有频繁的元数据的同步。</p><p class=""><br></p><p class="">Kibana 能够完全访问多个集群，且能创建索引和进行修改，具备完整访问权限。</p><p class=""><br></p><p class="">跨集群访问只需要很轻量级的几个连接，不需要和每个节点都建立连接，这个功能在 5.3 已经支持。</p><p class=""><br></p><p class=""><strong>Batched Search Reduce Phases</strong></p><p class=""><br></p><p class="">另外，以前的搜索的 reduce 操作都是要等到把每个分片的结果都拿到本地之后再做合并，所以为了避免海量分片造成的资源大量占用的问题，之前是有一个最多 1000 个分片的软限制，也就是一个搜索最多只能检索 1000 个分片，现在新增的 batched search reduce phases 提供了分批进行 reduce 的行为，也就是不用全部拿到之后再做 reduce，而是拿到足够的分片（默认 512）之后就开始 做 reduce，然后拿到合并结果，释放相关的资源，继续获取其他的分片数据继续进行 reduce，这样就能处理海量的数据了，这个功能在 5.4 发布。</p><p class=""><br></p><p class=""><span style="font-size: 20px;"><strong>ES 6.0 展望</strong></span></p><p class=""><br></p><p class="">上面的这些功能基本会在 5.x 提供，而 es6.0 早已在路上了，有很多特性值得期待：</p><p class=""><br></p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p class="">稀疏性 Doc Values 的支持，大家知道 es 的 doc values 是列式存储，文档的原始值都是存放在 doc values 里面的，而稀疏性是指，一个索引里面，文档的结构其实是多样性的，但是郁闷的是只要一个文档有这个字段，其他所有的文档尽管没有这个字段，可也都要承担这个字段的开销，所以会存在磁盘空间的浪费，而这块的改进就是这个问题。</p></li><li><p class="">Index sorting，即在索引阶段的排序，即我们查询的时候有时候会根据某个字段的值进行排序，比如时间、编号等等，如果在索引的时候提取排好序，那么搜索或聚合的时候就会非常快，相应的直接走预先排序好的索引就行了。当然索引的时候会要增加额外开销，适合不怎么变化的索引的场景。</p></li><li><p class="">顺序号的支持，每个 es 的操作都有一个顺序编号，这个属于 es 内部的一个功能，可以提供：快速的分片副本恢复或同步；跨数据中心的节点恢复；甚至提供一个 Changes API 等等；</p></li><li><p class="">无缝滚动升级，使之能够从 5 的最后一个版本滚动升级到 6 的最后一个版本，不需要集群的完整重启。无缝滚动升级，也就是不用停服务，在线升级，补充一下。</p></li></ol><p class=""><br></p><p class="">什么是最后一个版本？</p><p class=""><br></p><p class="">也就是 6 发布第一个版本，比如 6.0 的时候， 5 的对应的那个最后的发布的版本，比如 5.5，那么 5.5 可以直接滚动升级到 6.0。并且这两个版本我们称为主要版本，他们还支持跨大版本的搜索。就是前面提到的 cross-cluster 特性，不同的版本也能支持跨集群访问，如下：</p><p class=""><br></p><p><img src="/ArchNotes/images/4ca204b1e05eccb5a01abcc0ea2e89567f396b27.png" style="width: 721px !important; height: 371px !important;"></p><p class=""><br></p><p class="">下面还有一些：</p><p class=""><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p class="">Removal of types，在 6.0 里面，开始不支持一个 index 里面存在多个 type 了，所有的新的 index 都将只有一个虚拟的固定的 type： doc 来代替，基于 type 的 parent-child 关系将通过单独的 join 字段来实现， type 会在 7.0 彻底移除。</p></li><li><p class="">Index-template inheritance，索引版本的继承，目前索引模板是所有匹配的都会合并，这样会造成索引模板有一些冲突问题， 6.0 将会只匹配一个，索引创建时也会进行验证。</p></li><li><p class="">Load aware shard routing， 基于负载的请求路由，目前的搜索请求是全节点轮询，那么性能最慢的节点往往会造成整体的延迟增加，新的实现方式将基于队列的耗费时间自动调节队列长度，负载高的节点的队列长度将减少，让其他节点分摊更多的压力，搜索和索引都将基于这种机制。</p></li><li><p class="">已经关闭的索引将也支持 replica 的自动处理，确保数据可靠。</p></li></ul><p class=""><br></p><p class=""><strong><span style="font-size: 20px;">X-Pack 的部分特性：</span></strong></p><p class=""><br></p><p class="">6.0 的部分特性预告就上面这些，我猜下面的特性你也同样感兴趣：<br></p><p class=""><br></p><p class=""><strong>Elasticsearch-SQL</strong></p><p class=""><br></p><p class="">Elasticsearch 官方也要支持的 SQL 特性了。</p><p class=""><br></p><p class="">默认提供了一个 CLI 工具，可以很方便的执行 SQL 查询，主要面向管理人员，提高常见操作的使用效率。</p><p class=""><br></p><p class="">Kibana 里面也可以直接执行。</p><p class=""><br></p><p class="">另外也兼容 JDBC 协议，现存的很多基于 JDBC 协议的各种 SQL 工具及 BI 工具都能直接把 es 当数据库来连接和进行数据分析。</p><p class=""><br></p><p><img src="/ArchNotes/images/17ef843d620a85fcf7589f42783890235ed1d661.png" style="width: 770px !important; height: 875.273px !important;"></p><p class=""><br></p><p><img src="/ArchNotes/images/ca4a242506e57ec5506183974c655b2dcdadfaba.png" style="width: 770px !important; height: 629.234px !important;"></p><p><br></p><p><img src="/ArchNotes/images/c4be777f3760cf9f6f1e4a0f874d01c8d72386b5.png" style="width: 770px !important; height: 443.953px !important;"></p><p class=""><br></p><p class="">支持在 Java 里面通过 Java.sql 和 javax.sql API 接口访问 ES 数据。</p><p class=""><br></p><p><img src="/ArchNotes/images/ae08d5ae4bdf9af8119675935fb8a62dc6f77f71.png" style="width: 770px !important; height: 537.797px !important;"></p><p class=""><br></p><p class="">使用 ES 变得更加轻量级，使用起来无依赖。</p><p class=""><br></p><p class=""><strong><span style="font-size: 20px;">机器学习</span></strong></p><p class=""><br></p><p class="">去年 Elastic 收购了业界领先的行为数据分析厂商 Prelert，现在相关产品已经集成进入了 X-Pack 的机器学习模块，可以快速的实现基于 ES 数据的行为分析，借助 ES 的海量实时处理能力，采用非监督机器学习来识别异常行为。</p><p class=""><br></p><p><img src="/ArchNotes/images/54ce28e4395d6f42fb7cf48f684128fb94a8b422.jpeg" style="width: 770px !important; height: 373.57px !important;"></p><p class=""><br></p><p class="">上图是机器学习自动识别出来的异常数据点。</p><p class=""><br></p><p class="">本文只是 ES 最近的众多改进的一部分，有关更详细的更新内容还以具体的版本发布记录为准。</p><p class=""><br></p><p class="">ElasticStack 的其他开源项目也有很多有意思的改进和 feature，愿意了解更多的，可以关注我们官方及社区的活动：</p><p class="">http://elasticsearch.cn/article/141</p><p class=""><br></p><p class="" style="text-align: center;"><strong><span style="font-size: 20px;">Q&amp;A&nbsp;</span></strong></p><p class=""><br></p><p><strong><span style="font-size: 14px;">提问：能否说说 ES 是如何在 lucene 上实现分布式的？</span></strong></p><p>这个不是一句话能够说清楚点，可以参考我们的权威指南：</p><p>http://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/distributed-docs.html<br></p><p><br></p><p><strong><span style="font-size: 14px;">提问：可否组织一些 ES 常见的复杂模型构建思路探讨这样的论题。主要是探讨如何实现与优化。我想这是在座的同学都会有遇到的问题。<br></span></strong></p><p>曾勇：复杂模型需要具体分析，可以参看我们的权威指南：</p><p>http://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/modeling-your-data.html</p><p><br></p><p><strong><span style="font-size: 14px;">提问：ES 与 solr 对比有什么优势？技术选型时如何考虑？</span></strong></p><p>曾勇：网上的对比有很多，我就不一一赘述了，如果没有用过 solr，那建议直接使用 ES 吧，上手更快更简单。另外网上的优劣比较其实也要结合自己的实际场景，实践出真知。</p><p><br></p><p><strong><span style="font-size: 14px;">问：请问下，如果我有 9G 的数据导入，如何导最快？之前 curl @xxx.txt 方式，但是数据文件一大 curl 标准格式导入就不行了。</span></strong></p><p>曾勇：走 bulk 方式肯定是最快的，txt 内容是什么格式呢，利用一些现存的工具，可以试试，比如 logstash，记得选择 bulk 模式。导入的时候，有很多参数也对速度有帮助，这个就要去看看索引的优化这块的内容了。</p><p class=""><br></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 20px; box-sizing: border-box !important; word-wrap: break-word !important;">推荐阅读</span></strong></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547666&amp;idx=1&amp;sn=f57978358640a8af61d6cbf404ef32b9&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547666&amp;idx=1&amp;sn=f57978358640a8af61d6cbf404ef32b9&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">百姓网 Elasticsearch 2.x 升级之路</span></a><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></p></li><li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=209488723&amp;idx=1&amp;sn=d60c0637d7a9f4a4b981a69f10c6b90a&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=209488723&amp;idx=1&amp;sn=d60c0637d7a9f4a4b981a69f10c6b90a&amp;scene=21#wechat_redirect" style="text-decoration: underline; font-size: 14px; color: rgb(0, 82, 255);"><span style="font-size: 14px; color: rgb(0, 82, 255);">亿级规模的Elasticsearch优化实战</span></a><br></p></li></ul><p><br></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">本文由微博崔建兴供稿，转载请注明出处，技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。</span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">高可用架构</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">改变互联网的构建方式</strong></span></p><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 18px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/ArchNotes/images/f6d330d516dce1ccc8afa78eadcccb86f8851363.jpeg" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 200px !important; height: 200px !important;"><br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></strong></span><span style="max-width: 100%; font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;">长按二维码 关注「高可用架构」公众号</span></p>
{% endraw  %}

