---
title: Android外部存储：揭秘表面之下的技术迭代与更新
author: 庄灿杰
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1515989891&src=3&ver=1&signature=yyLj*6br2FUtW3BtBE3siLzBNVIeS0k49bS4kssGXwf*0NkFqIADcPjHSTCBPEcWR5SS8axxfH5aYkjejEUxuS*dQ9x614Uh8MpCtgjT3Avr5hwh4Leu03D4FB3rckfMABlZ1xnL99m-27YyRj5LIwdAUotzcslnWEmc9Up-Q-A=
date: '2017-12-28 00:00:00 +0000'

---

{% raw  %}
<blockquote><p>外部存储作为开发中经常接触的一个重要系统组成，在Android历代版本中，有过许许多多重要的变更。</p></blockquote><p><br></p><p style="margin: 0px 0px 1.2em !important;"><span style="font-size: 1.4em;font-weight: bold;">一、各版本外部存储特性</span></p><ol style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">Android 4.0</p></li><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>支持模拟外部存储（通过FUSE实现）</p></li><li><p>出现了主外部存储，以及二级外部存储（没有接口对外暴露）</p></li><li><p>支持MTP（Media Transfer Protocol）、PTP协议（Picture Transfer Protocol）</p></li></ul><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">Android 4.1</p></li><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>开发者选项出现”强制应用声明读权限才可以进行读操作”的开关</p></li></ul><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">Android 4.2</p></li><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>支持多用户，每个用户拥有独立的外部存储</p></li></ul><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">Android 4.4</p></li><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>读操作需要声明<code style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;padding: 0px 0.3em;white-space: pre-wrap;border-width: 1px;border-style: solid;border-color: rgb(234, 234, 234);background-color: rgb(248, 248, 248);border-radius: 3px;display: inline;">READ_EXTERNAL_STORAGE</code>权限</p></li><li><p>应用读写在外部存储的应用目录（/sdcard/Android/</p><pkg>/）不需要声明权限</pkg></li><li><p>增加了<code style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;padding: 0px 0.3em;white-space: pre-wrap;border-width: 1px;border-style: solid;border-color: rgb(234, 234, 234);background-color: rgb(248, 248, 248);border-radius: 3px;display: inline;">Context.getExternalFilesDirs()</code> 接口，可以获取应用在主外部存储和其他二级外部存储下的files路径</p></li><li><p>引入存储访问框架（SAF，Storage Access Framework）</p></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Sa7mwT4mK8ibYISibGwia3W7tHZYXQg9d3bYY369ZS2YHg1blrhkYamrQnSib9UvS4eq47JZ4icZYgWqv58MXdicvZuw/0?wx_fmt=png" style="width: 680px !important; height: 673px !important; visibility: visible !important;"></p><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">Android 6.0</p></li><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>外部存储支持动态权限管理</p></li><li><p>Adoptable Storage特性</p></li></ul><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">Android 7.0</p></li><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>引入作用域目录访问</p></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Sa7mwT4mK8ibYISibGwia3W7tHZYXQg9d3bppnAfpqGeVtY22VibhgDPbCQy3m6Rt64B8QsNcRQ7YGyba7EneUSibsQ/0?wx_fmt=png" style="width: 400px !important; height: 685px !important;"></p></ol><blockquote style="margin: 1.2em 0px;border-left: 4px solid rgb(221, 221, 221);padding: 0px 1em;color: rgb(119, 119, 119);quotes: none;"><p style="margin: 0px 0px 1.2em !important;">补充一个点：如果应用的minSdkVersion和targetSdkVersion设置成&lt;=3，系统会默认授予READ_EXTERNAL_STORAGE权限。</p></blockquote><h2 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.4em;">二、部分特性讲解</h2><h3 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.3em;">1. 模拟外部存储</h3><h4 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.2em;">a. 必要性</h4><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p><code style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;padding: 0px 0.3em;white-space: pre-wrap;border-width: 1px;border-style: solid;border-color: rgb(234, 234, 234);background-color: rgb(248, 248, 248);border-radius: 3px;display: inline;">FAT32</code> 属于微软专利，可能存在许可和法律问题（相关文章）；</p></li><li><p>可以定制Android自己的外部存储访问规则；</p></li><li><p>为多用户做铺垫；</p></li></ul><h4 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.2em;">b. 实现原理</h4><p style="margin: 0px 0px 1.2em !important;">系统/system/bin/sdcard守护进程，使用FUSE实现类FAT格式SD卡文件系统的模拟，也就是我们经常说的内置SD卡。（详细代码可以参考：/xref/system/core/sdcard/sdcard.c）</p><blockquote style="margin: 1.2em 0px;border-left: 4px solid rgb(221, 221, 221);padding: 0px 1em;color: rgb(119, 119, 119);quotes: none;"><p style="margin: 0px 0px 1.2em !important;"><strong>用户空间文件系统</strong>（<strong>F</strong>ilesystem in <strong>Use</strong>rspace，简称<strong>FUSE</strong>）是一个面向类Unix计算机操作系统的软件接口，它使无特权的用户能够无需编辑内核代码而创建自己的文件系统。目前Linux通过内核模块对此进行支持。<br></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Sa7mwT4mK8ibYISibGwia3W7tHZYXQg9d3bf5MTjV8Jnz6caTZBm7PcsgrtcjjvPMPJ9BYtF0dn8FibRICtgygun6w/0?wx_fmt=png" style="width: 280px !important; height: 212px !important;"></p></blockquote><p style="margin: 0px 0px 1.2em !important;">sdcard守护进程模拟外部存储大致流程（Android 4.0为例）：</p><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>首先，指定/data/media目录用于模拟外部存储。该路径的owner和group一般为media_rw，这样保证只有sdcard程序或root进程能够访问该目录。</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;"># create virtual SD card at /mnt/sdcard, based on the /data/media directory
# daemon will drop to user/group system/media_rw after initializing
# underlying files in /data/media will be created with user and group media_rw (1023)
service sdcard /system/bin/sdcard /data/media 1023 1023
 &nbsp; &nbsp;class late_start</code></pre></li><li><p>sdcard守护进程启动后，打开/dev/fuse设备。</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;">fd = open(<span class="" style="color: rgb(204, 147, 147);">"/dev/fuse"</span>, O_RDWR);<span class="" style="color: rgb(227, 206, 171);">if</span> (fd &lt; <span class="" style="color: rgb(140, 208, 211);">0</span>) {
 &nbsp; &nbsp;ERROR(<span class="" style="color: rgb(204, 147, 147);">"cannot open fuse device (%d)\n"</span>, errno); &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> -<span class="" style="color: rgb(140, 208, 211);">1</span>;
}</code></pre></li><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">在/mnt/sdcard目录挂载fuse文件系统。</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;"><span class="" style="color: rgb(204, 147, 147);">#<span class="" style="color: rgb(227, 206, 171);">define</span> MOUNT_POINT "/mnt/sdcard"</span>...<span class="" style="color: rgb(204, 147, 147);">sprintf</span>(opts, <span class="" style="color: rgb(204, 147, 147);">"fd=%i,rootmode=40000,default_permissions,allow_other,"</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">"user_id=%d,group_id=%d"</span>, fd, uid, gid);

res = mount(<span class="" style="color: rgb(204, 147, 147);">"/dev/fuse"</span>, MOUNT_POINT, <span class="" style="color: rgb(204, 147, 147);">"fuse"</span>, MS_NOSUID | MS_NODEV, opts);<span class="" style="color: rgb(227, 206, 171);">if</span> (res &lt; <span class="" style="color: rgb(140, 208, 211);">0</span>) {
 &nbsp;ERROR(<span class="" style="color: rgb(204, 147, 147);">"cannot mount fuse filesystem (%d)\n"</span>, errno); &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> -<span class="" style="color: rgb(140, 208, 211);">1</span>;
}</code></pre></li><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">开线程，在线程中处理文件系统事件，并将结果写回。</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;"><span class="" style="color: rgb(227, 206, 171);">void</span> handle_fuse_requests(<span class="" style="color: rgb(227, 206, 171);">struct</span> fuse *fuse)
{ &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">unsigned</span> <span class="" style="color: rgb(227, 206, 171);">char</span> req[<span class="" style="color: rgb(140, 208, 211);">256</span> * <span class="" style="color: rgb(140, 208, 211);">1024</span> + <span class="" style="color: rgb(140, 208, 211);">128</span>]; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">int</span> len; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">for</span> (;;) {
 &nbsp; &nbsp; &nbsp; &nbsp;len = read(fuse-&gt;fd, req, <span class="" style="color: rgb(140, 208, 211);">8192</span>); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (len &lt; <span class="" style="color: rgb(140, 208, 211);">0</span>) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (errno == EINTR) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">continue</span>;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ERROR(<span class="" style="color: rgb(204, 147, 147);">"handle_fuse_requests: errno=%d\n"</span>, errno); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span>;
 &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp; &nbsp; &nbsp;handle_fuse_request(fuse, (<span class="" style="color: rgb(227, 206, 171);">void</span>*) req, (<span class="" style="color: rgb(227, 206, 171);">void</span>*) (req + <span class="" style="color: rgb(227, 206, 171);">sizeof</span>(<span class="" style="color: rgb(227, 206, 171);">struct</span> fuse_in_header)), len);
 &nbsp; &nbsp;}
}</code></pre></li></ul><p style="margin: 0px 0px 1.2em !important;">经过上面一系列步骤，sdcard进程在/mnt/sdcard路径上创建了一个FUSE文件系统，所有对/mnt/sdcard将转为事件由sdcard守护进程处理，并对应到/data/media目录。<br>例如，应用创建/mnt/sdcard/a文件，实际是创建/data/media/a文件。</p><h4 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.2em;">c. 优点</h4><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>模拟外部存储容量和/data分区是共享的，用户数据在内外存储的分配更加自由；</p></li><li><p>模拟外部存储本身不可卸载，不会因为卸载导致应用访问出现问题，也减少了外部因素导致被破坏的情况；</p></li><li><p>所有的访问都经过sdcard守护进程，Android可以定制访问规则；</p></li></ul><h4 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.2em;">d. 劣势</h4><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>性能上存在一定损失</p></li></ul><h4 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.2em;">e. 影响</h4><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>Android 6.0以后，由于动态权限管理的需要，会存在多个fuse挂载点，这导致inotify/FileObserver对外部存储进行文件事件监控时，会丢失事件。</p><blockquote style="margin: 1.2em 0px;border-left: 4px solid rgb(221, 221, 221);padding: 0px 1em;color: rgb(119, 119, 119);quotes: none;"><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;"><strong>inotify</strong>是Linux核心子系统之一，做为文件系统的附加功能，它可监控文件系统并将异动通知应用程序。 &nbsp; &nbsp;—— 维基百科</p></blockquote></li></ul><h3 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.3em;">2. 多用户</h3><h4 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.2em;">a. 支持版本</h4><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>Android 4.2开始支持多用户，但仅限平板；</p></li><li><p>Android 5.0开始，设备制造商可以在编译时候开启多用户模块；</p></li></ul><h4 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.2em;">b. 背景知识</h4><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>绑定挂载——mount —bind</p></li></ul><blockquote style="margin: 1.2em 0px;border-left: 4px solid rgb(221, 221, 221);padding: 0px 1em;color: rgb(119, 119, 119);quotes: none;"><p style="margin: 0px 0px 1.2em !important;"><strong>MS_BIND</strong> (Linux 2.4 onward)</p><p style="margin: 0px 0px 1.2em !important;">Perform a bind mount, making a file or a directory subtree visible at another point within a file system. Bind mounts may cross file system boundaries and span <strong>chroot</strong>(2) jails. The <em>filesystemtype</em> and <em>data</em>arguments are ignored. Up until Linux 2.6.26, <em>mountflags</em> was also ignored (the bind mount has the same mount options as the underlying mount point). &nbsp; &nbsp; —— mount(2) - Linux man page</p></blockquote><p style="margin: 0px 0px 1.2em !important;">图例（来自https://xionchen.github.io/2016/08/25/linux-bind-mount）：</p><p style="margin: 0px 0px 1.2em !important;">1) 将/home目录树bind到/mnt/backup：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Sa7mwT4mK8ibYISibGwia3W7tHZYXQg9d3bY8Z5ICpxz8CGFGKzZP7vmu82JFbibjzUaico3wA2wNu97PQ3cUBCNH1w/0?wx_fmt=png" style="width: 770px !important; height: 326.485px !important;"></p><p style="margin: 0px 0px 1.2em !important;">2) bind完成之后，对/mnt/backup的访问将等同于对/home的访问，原/mnt/backup变为不可见。</p><p><img src="http://mmsns.qpic.cn/mmsns/Sa7mwT4mK8ibYISibGwia3W7tHZYXQg9d3b2qnyFyYYcEE0cacVOdkaicw/0" style="width: 770px !important; height: 648.214px !important;"></p><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">挂载命名空间</p><blockquote style="margin: 1.2em 0px;border-left: 4px solid rgb(221, 221, 221);padding: 0px 1em;color: rgb(119, 119, 119);quotes: none;"><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">Mount namespaces provide isolation of the list of mount points seen by the processes in each namespace instance. &nbsp;Thus, the processes in each of the mount namespace instances will see distinct single-directory hierarchies. &nbsp; &nbsp; —— mount_namespaces(7) - Linux manual page - man7.org</p></blockquote><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">通俗的讲，挂载命名空间实现了挂载点的隔离，在不同挂载命名空间的进程，看到的目录层次不同。</p></li><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">挂载传播之共享挂载、从属挂载、私有挂载</p><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">挂载命名空间实现了完全的隔离，但对于有些情况并不适用。例如在Linux系统上，进程A在命名空间1挂载了一张CD-ROM，这时候命名空间2因为隔离无法看到这张CD-ROM。</p><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">为了解决这个问题，引入了挂载传播（mount propagation）。传播挂载定义了挂载点的传播类型:</p></li><ol style="list-style-type: lower-roman;margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>共享挂载，此类型的挂载点会加入一个peer group，并会在group内传播和接收挂载事件；</p></li><li><p>从属挂载，此类型的挂载点会加入一个peer group，并会接收group内的挂载事件，但不传播；</p></li><li><p>共享/从属挂载，上面两种类型的共存体。可以从一个peer group（此时类型为从属挂载）接收挂载事件，再传播到另一个peer group；</p></li><li><p>私有挂载，此类型的挂载点没有peer group，既不传播也不接收挂载事件；</p></li><li><p>不可绑定挂载，不展开讲；</p></li></ol><p><br></p><p>peer group的形成条件为，一个挂载点被设置成共享挂载，并满足以下任意一种情况：</p><ol class="list-paddingleft-2" style="list-style-type: lower-roman;"><li><p>挂载点在创建新的命名空间时被复制</p></li><li><p>从该挂载点创建了一个绑定挂载</p><p><br></p></li></ol><p>另外再补充下传播类型的转换：</p></ul><table style="margin: 1.2em 0px;padding: 0px;border-collapse: collapse;border-spacing: 0px;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;border-width: 0px;border-style: initial;border-color: initial;"><thead><tr style="border-width: 1px 0px 0px;border-right-style: initial;border-bottom-style: initial;border-left-style: initial;border-right-color: initial;border-bottom-color: initial;border-left-color: initial;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><th style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;font-weight: bold;background-color: rgb(240, 240, 240);word-break: break-all;"><br></th><th style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;font-weight: bold;background-color: rgb(240, 240, 240);">make-shared</th><th style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;font-weight: bold;background-color: rgb(240, 240, 240);">make-slave</th><th style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;font-weight: bold;background-color: rgb(240, 240, 240);">make-priv</th><th style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;font-weight: bold;background-color: rgb(240, 240, 240);">make-unbind</th></tr></thead><tbody style="margin: 0px;padding: 0px;border-width: 0px;border-style: initial;border-color: initial;"><tr style="border-width: 1px 0px 0px;border-right-style: initial;border-bottom-style: initial;border-left-style: initial;border-right-color: initial;border-bottom-color: initial;border-left-color: initial;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">shared</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">shared</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">slave/priv [1]</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">priv</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">unbind</td></tr><tr style="border-width: 1px 0px 0px;border-right-style: initial;border-bottom-style: initial;border-left-style: initial;border-right-color: initial;border-bottom-color: initial;border-left-color: initial;border-top-style: solid;border-top-color: rgb(204, 204, 204);margin: 0px;padding: 0px;background-color: rgb(248, 248, 248);"><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">slave</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">slave+shared</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">slave [2]</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">priv</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">unbind</td></tr><tr style="border-width: 1px 0px 0px;border-right-style: initial;border-bottom-style: initial;border-left-style: initial;border-right-color: initial;border-bottom-color: initial;border-left-color: initial;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">slave+shared</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">slave+shared</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">slave</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">priv</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">unbind</td></tr><tr style="border-width: 1px 0px 0px;border-right-style: initial;border-bottom-style: initial;border-left-style: initial;border-right-color: initial;border-bottom-color: initial;border-left-color: initial;border-top-style: solid;border-top-color: rgb(204, 204, 204);margin: 0px;padding: 0px;background-color: rgb(248, 248, 248);"><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">private</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">shared</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">priv [2]</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">priv</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">unbind</td></tr><tr style="border-width: 1px 0px 0px;border-right-style: initial;border-bottom-style: initial;border-left-style: initial;border-right-color: initial;border-bottom-color: initial;border-left-color: initial;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">unbindable</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">shared</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">unbind [2]</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">priv</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">unbind</td></tr></tbody></table><p style="margin: 0px 0px 1.2em !important;">[1] 如果一个共享挂载是peer group中仅存的挂载点，那么对它应用从属挂载将会导致它变为私有挂载。<br>[2] 对一个非共享挂载类型的挂载点，应用从属挂载是无效的。</p><p style="margin: 0px 0px 1.2em !important;">背景知识讲到这里，其中挂载点的传播类型比较不好理解，但很重要，可以参考上面mount namespace的Linux Programmer’s Manual里面的例子（搜索MS_XXX example）进行学习（http://man7.org/linux/man-pages/man7/mount_namespaces.7.html）。</p><h4 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.2em;">c. 实现原理</h4><p style="margin: 0px 0px 1.2em !important;">概括多用户的外部存储隔离实现：应用进程在创建时，创建了新的挂载命名空间，然后通过绑定挂载对应用暴露当前用户的外部存储空间。</p><p style="margin: 0px 0px 1.2em !important;">以Android 4.2代码为例【mountEmulatedStorage(dalvik_system_Zygote.cpp)】：</p><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">首先获取用户id。在多用户下，用户id为应用uid/100000。</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;"><span class="" style="color: rgb(127, 159, 127);">/*
 * Create a private mount namespace and bind mount appropriate emulated
 * storage for the given user.
 */</span><span class="" style="color: rgb(227, 206, 171);">static</span> <span class="" style="color: rgb(227, 206, 171);">int</span> mountEmulatedStorage(uid_t uid, u4 mountMode) { &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// See storage config details at http://source.android.com/tech/storage/</span>
 &nbsp; &nbsp;userid_t userid = multiuser_get_user_id(uid);</code></pre></li><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">通过unshare方法创建新的挂载命名空间。</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;"> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Create a second private mount namespace for our process</span>
 &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (unshare(CLONE_NEWNS) == -<span class="" style="color: rgb(140, 208, 211);">1</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp;SLOGE(<span class="" style="color: rgb(204, 147, 147);">"Failed to unshare(): %s"</span>, strerror(errno)); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> -<span class="" style="color: rgb(140, 208, 211);">1</span>;
 &nbsp; &nbsp;}</code></pre></li><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">获取外部存储相关的环境变量。EXTERNAL_STORAGE环境变量是从旧版本沿袭下来的环境变量，记录了外部存储的传统路径。EMULATED_STORAGE_SOURCE环境变量，记录绑定挂载的源路径，注意应用是没有权限进入这个目录的。EMULATED_STORAGE_TARGET记录绑定挂载的目标路径，应用获取的外部存储路径就在这个目录下。</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;"> &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Create bind mounts to expose external storage</span>
 &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (mountMode == MOUNT_EXTERNAL_MULTIUSER
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| mountMode == MOUNT_EXTERNAL_MULTIUSER_ALL) { &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// These paths must already be created by init.rc</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">const</span> <span class="" style="color: rgb(227, 206, 171);">char</span>* source = getenv(<span class="" style="color: rgb(204, 147, 147);">"EMULATED_STORAGE_SOURCE"</span>); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">const</span> <span class="" style="color: rgb(227, 206, 171);">char</span>* target = getenv(<span class="" style="color: rgb(204, 147, 147);">"EMULATED_STORAGE_TARGET"</span>); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">const</span> <span class="" style="color: rgb(227, 206, 171);">char</span>* legacy = getenv(<span class="" style="color: rgb(204, 147, 147);">"EXTERNAL_STORAGE"</span>); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (source == NULL || target == NULL || legacy == NULL) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SLOGE(<span class="" style="color: rgb(204, 147, 147);">"Storage environment undefined; unable to provide external storage"</span>); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> -<span class="" style="color: rgb(140, 208, 211);">1</span>;
 &nbsp; &nbsp; &nbsp; &nbsp;}</code></pre></li><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">准备挂载路径并进行绑定挂载。这里看mountMode为MOUNT_EXTERNAL_MULTIUSER时的执行分支，/mnt/shell/emulated/0将被绑定到/storage/emulated/0。如果是第二个用户，则是/mnt/shell/emulated/1绑定到/storage/emulated/1，数字就是用户id。注意这里是新的挂载命名空间，所以只有该应用看得到/storage/emulated/0下的绑定挂载，从adb shell下是看到的只能是个空目录。</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Prepare source paths</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">char</span> source_user[PATH_MAX]; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">char</span> source_obb[PATH_MAX]; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">char</span> target_user[PATH_MAX]; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// /mnt/shell/emulated/0</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">snprintf</span>(source_user, PATH_MAX, <span class="" style="color: rgb(204, 147, 147);">"%s/%d"</span>, source, userid); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// /mnt/shell/emulated/obb</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">snprintf</span>(source_obb, PATH_MAX, <span class="" style="color: rgb(204, 147, 147);">"%s/obb"</span>, source); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// /storage/emulated/0</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">snprintf</span>(target_user, PATH_MAX, <span class="" style="color: rgb(204, 147, 147);">"%s/%d"</span>, target, userid); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (fs_prepare_dir(source_user, <span class="" style="color: rgb(140, 208, 211);">0000</span>, <span class="" style="color: rgb(140, 208, 211);">0</span>, <span class="" style="color: rgb(140, 208, 211);">0</span>) == -<span class="" style="color: rgb(140, 208, 211);">1</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| fs_prepare_dir(source_obb, <span class="" style="color: rgb(140, 208, 211);">0000</span>, <span class="" style="color: rgb(140, 208, 211);">0</span>, <span class="" style="color: rgb(140, 208, 211);">0</span>) == -<span class="" style="color: rgb(140, 208, 211);">1</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| fs_prepare_dir(target_user, <span class="" style="color: rgb(140, 208, 211);">0000</span>, <span class="" style="color: rgb(140, 208, 211);">0</span>, <span class="" style="color: rgb(140, 208, 211);">0</span>) == -<span class="" style="color: rgb(140, 208, 211);">1</span>) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> -<span class="" style="color: rgb(140, 208, 211);">1</span>;
 &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (mountMode == MOUNT_EXTERNAL_MULTIUSER_ALL) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Mount entire external storage tree for all users</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (mount(source, target, NULL, MS_BIND, NULL) == -<span class="" style="color: rgb(140, 208, 211);">1</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SLOGE(<span class="" style="color: rgb(204, 147, 147);">"Failed to mount %s to %s: %s"</span>, source, target, strerror(errno)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> -<span class="" style="color: rgb(140, 208, 211);">1</span>;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp; &nbsp; &nbsp;} <span class="" style="color: rgb(227, 206, 171);">else</span> { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Only mount user-specific external storage</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (mount(source_user, target_user, NULL, MS_BIND, NULL) == -<span class="" style="color: rgb(140, 208, 211);">1</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SLOGE(<span class="" style="color: rgb(204, 147, 147);">"Failed to mount %s to %s: %s"</span>, source_user, target_user, strerror(errno)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> -<span class="" style="color: rgb(140, 208, 211);">1</span>;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp; &nbsp; &nbsp;}</code></pre></li><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">为了兼容以前的版本，将用户的外部存储路径绑定到EXTERNAL_STORAGE环境变量指定的路径。</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;"> &nbsp; &nbsp; &nbsp; &nbsp;... &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Finally, mount user-specific path into place for legacy users</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (mount(target_user, legacy, NULL, MS_BIND | MS_REC, NULL) == -<span class="" style="color: rgb(140, 208, 211);">1</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SLOGE(<span class="" style="color: rgb(204, 147, 147);">"Failed to mount %s to %s: %s"</span>, target_user, legacy, strerror(errno)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> -<span class="" style="color: rgb(140, 208, 211);">1</span>;
 &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp; &nbsp; &nbsp;...</code></pre></li></ul><h3 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.3em;">3. 动态权限管理</h3><h4 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.2em;">a.背景</h4><p style="margin: 0px 0px 1.2em !important;">Android 6.0引入了运行时权限，允许用户对危险权限进行动态授权，这部分权限包含外部存储访问权限。</p><h4 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.2em;">b.实现原理</h4><p style="margin: 0px 0px 1.2em !important;">外部存储访问权限的动态授权，是利用FUSE和挂载命名空间这两个技术配合实现。<br>通过下面这个提交记录，我们可以很清楚的了解整个实现。</p><blockquote style="margin: 1.2em 0px;border-left: 4px solid rgb(221, 221, 221);padding: 0px 1em;color: rgb(119, 119, 119);quotes: none;"><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;background-color: rgb(248, 248, 248);white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em 0.7em;display: block !important;">Let's reinvent storage, yet again!

Now that we're treating storage as a runtime permission, we need to
grant read/write access without killing the app. &nbsp;This is really
tricky, since we had been using GIDs for access control, and they're
set in stone once Zygote drops privileges.

The only thing left that can change dynamically is the filesystem
itself, so let's do that. &nbsp;This means changing the FUSE daemon to
present itself as three different views:

/mnt/runtime_default/foo - view for apps with no access
/mnt/runtime_read/foo - view for apps with read access
/mnt/runtime_write/foo - view for apps with write access

There is still a single location for all the backing files, and
filesystem permissions are derived the same way for each view, but
the file modes are masked off differently for each mountpoint.

During Zygote fork, it wires up the appropriate storage access into
an isolated mount namespace based on the current app permissions. &nbsp;When
the app is granted permissions dynamically at runtime, the system
asks vold to jump into the existing mount namespace and bind mount
the newly granted access model into place.

Bug: 21858077
Change-Id: I5a016f0958a92fd390c02b5ae159f8008bd4f4b7</code></pre></blockquote><p style="margin: 0px 0px 1.2em !important;">为了达到不杀死进程，就能够赋予进程读/写外置存储的目的，Android利用FUSE对/data/media模拟了三种访问视图，分别是default、read、write。</p><table style="margin: 1.2em 0px;padding: 0px;border-collapse: collapse;border-spacing: 0px;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;border-width: 0px;border-style: initial;border-color: initial;"><thead><tr style="border-width: 1px 0px 0px;border-right-style: initial;border-bottom-style: initial;border-left-style: initial;border-right-color: initial;border-bottom-color: initial;border-left-color: initial;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><th style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;font-weight: bold;background-color: rgb(240, 240, 240);">视图</th><th style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;font-weight: bold;background-color: rgb(240, 240, 240);">作用</th></tr></thead><tbody style="margin: 0px;padding: 0px;border-width: 0px;border-style: initial;border-color: initial;"><tr style="border-width: 1px 0px 0px;border-right-style: initial;border-bottom-style: initial;border-left-style: initial;border-right-color: initial;border-bottom-color: initial;border-left-color: initial;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">default</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">给没有外部存储访问权限的应用使用</td></tr><tr style="border-width: 1px 0px 0px;border-right-style: initial;border-bottom-style: initial;border-left-style: initial;border-right-color: initial;border-bottom-color: initial;border-left-color: initial;border-top-style: solid;border-top-color: rgb(204, 204, 204);margin: 0px;padding: 0px;background-color: rgb(248, 248, 248);"><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">read</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">给授予外部存储读权限的应用使用</td></tr><tr style="border-width: 1px 0px 0px;border-right-style: initial;border-bottom-style: initial;border-left-style: initial;border-right-color: initial;border-bottom-color: initial;border-left-color: initial;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">write</td><td style="font-size: 1em;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);margin: 0px;padding: 0.5em 1em;">给授予外部存储写权限的应用使用</td></tr></tbody></table><p style="margin: 0px 0px 1.2em !important;">当应用被授予读/写权限时，vold子进程会切换到应用的挂载命名空间，将对应的视图重新绑定到应用的外部存储路径上。</p><p style="margin: 0px 0px 1.2em !important;">切换进程的挂载命名空间，需要内核版本在3.8及以上，切换函数为setns，ndk貌似没有对开发者暴露，但可以在源码里找到arm的实现，有需要直接编入就可以了，也就一个sys call。</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;">/* Generated by gensyscalls.py. Do not edit. */

#include &lt;private/bionic_asm.h&gt;

ENTRY(setns)
 &nbsp; &nbsp;mov &nbsp; &nbsp; ip, r7
 &nbsp; &nbsp;ldr &nbsp; &nbsp; r7, =__NR_setns
 &nbsp; &nbsp;swi &nbsp; &nbsp; #0
 &nbsp; &nbsp;mov &nbsp; &nbsp; r7, ip
 &nbsp; &nbsp;cmn &nbsp; &nbsp; r0, #(MAX_ERRNO + 1)
 &nbsp; &nbsp;bxls &nbsp; &nbsp;lr
 &nbsp; &nbsp;neg &nbsp; &nbsp; r0, r0
END(setns)</code></pre><h4 style="margin: 1.3em 0px 1em;padding: 0px;font-weight: bold;font-size: 1.2em;">c. 代码分析</h4><ul style="margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">源码版本：Android 6.0.0_r1</p></li><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">首先从/xref/system/core/sdcard/sdcard.c开始分析，仅摘取部分代码，并加了些注释：</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;"><span class="" style="color: rgb(227, 206, 171);">static</span> <span class="" style="color: rgb(227, 206, 171);">void</span> run(<span class="" style="color: rgb(227, 206, 171);">const</span> <span class="" style="color: rgb(227, 206, 171);">char</span>* source_path, <span class="" style="color: rgb(227, 206, 171);">const</span> <span class="" style="color: rgb(227, 206, 171);">char</span>* label, uid_t uid,
 &nbsp; &nbsp; &nbsp; &nbsp;gid_t gid, userid_t userid, <span class="" style="color: rgb(227, 206, 171);">bool</span> multi_user, <span class="" style="color: rgb(227, 206, 171);">bool</span> full_write) {
 &nbsp; &nbsp; &nbsp;... &nbsp; &nbsp; &nbsp; <span class="" style="color: rgb(127, 159, 127);">// 分配三个视图路径，分别为default、read和write，label一般用来标示存储，例如模拟的外置存储，这里label为"emulated"</span>
 &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">snprintf</span>(fuse_default.dest_path, PATH_MAX, <span class="" style="color: rgb(204, 147, 147);">"/mnt/runtime/default/%s"</span>, label); &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">snprintf</span>(fuse_read.dest_path, PATH_MAX, <span class="" style="color: rgb(204, 147, 147);">"/mnt/runtime/read/%s"</span>, label); &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">snprintf</span>(fuse_write.dest_path, PATH_MAX, <span class="" style="color: rgb(204, 147, 147);">"/mnt/runtime/write/%s"</span>, label);

 &nbsp; &nbsp; &nbsp;... &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// fuse_setup方法挂载fuse文件系统</span>
 &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (multi_user) { &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">/* Multi-user storage is fully isolated per user, so "other"
 &nbsp; &nbsp; &nbsp; &nbsp; * permissions are completely masked off. */</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (fuse_setup(&amp;fuse_default, AID_SDCARD_RW, <span class="" style="color: rgb(140, 208, 211);">0006</span>)
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| fuse_setup(&amp;fuse_read, AID_EVERYBODY, <span class="" style="color: rgb(140, 208, 211);">0027</span>)
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| fuse_setup(&amp;fuse_write, AID_EVERYBODY, full_write ? <span class="" style="color: rgb(140, 208, 211);">0007</span> : <span class="" style="color: rgb(140, 208, 211);">0027</span>)) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ERROR(<span class="" style="color: rgb(204, 147, 147);">"failed to fuse_setup\n"</span>); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">exit</span>(<span class="" style="color: rgb(140, 208, 211);">1</span>);
 &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;} <span class="" style="color: rgb(227, 206, 171);">else</span> { &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">/* Physical storage is readable by all users on device, but
 &nbsp; &nbsp; &nbsp; &nbsp; * the Android directories are masked off to a single user
 &nbsp; &nbsp; &nbsp; &nbsp; * deep inside attr_from_stat(). */</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (fuse_setup(&amp;fuse_default, AID_SDCARD_RW, <span class="" style="color: rgb(140, 208, 211);">0006</span>)
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| fuse_setup(&amp;fuse_read, AID_EVERYBODY, full_write ? <span class="" style="color: rgb(140, 208, 211);">0027</span> : <span class="" style="color: rgb(140, 208, 211);">0022</span>)
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| fuse_setup(&amp;fuse_write, AID_EVERYBODY, full_write ? <span class="" style="color: rgb(140, 208, 211);">0007</span> : <span class="" style="color: rgb(140, 208, 211);">0022</span>)) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ERROR(<span class="" style="color: rgb(204, 147, 147);">"failed to fuse_setup\n"</span>); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">exit</span>(<span class="" style="color: rgb(140, 208, 211);">1</span>);
 &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;}

 &nbsp; &nbsp; &nbsp;... &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// 从原本一个处理线程变为三个，分别处理三个视图的访问请求</span>
 &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (pthread_create(&amp;thread_default, NULL, start_handler, &amp;handler_default)
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| pthread_create(&amp;thread_read, NULL, start_handler, &amp;handler_read)
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| pthread_create(&amp;thread_write, NULL, start_handler, &amp;handler_write)) {
 &nbsp; &nbsp; &nbsp; &nbsp;ERROR(<span class="" style="color: rgb(204, 147, 147);">"failed to pthread_create\n"</span>); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">exit</span>(<span class="" style="color: rgb(140, 208, 211);">1</span>);
 &nbsp; &nbsp;}
 &nbsp; &nbsp; &nbsp;...
}</code></pre><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;"><span class="" style="color: rgb(127, 159, 127);">// 挂载fuse文件系统</span><span class="" style="color: rgb(227, 206, 171);">static</span> <span class="" style="color: rgb(227, 206, 171);">int</span> fuse_setup(<span class="" style="color: rgb(227, 206, 171);">struct</span> fuse* fuse, gid_t gid, mode_t mask) { &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">char</span> opts[<span class="" style="color: rgb(140, 208, 211);">256</span>];

 &nbsp; &nbsp;fuse-&gt;fd = open(<span class="" style="color: rgb(204, 147, 147);">"/dev/fuse"</span>, O_RDWR); &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (fuse-&gt;fd == -<span class="" style="color: rgb(140, 208, 211);">1</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp;ERROR(<span class="" style="color: rgb(204, 147, 147);">"failed to open fuse device: %s\n"</span>, strerror(errno)); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> -<span class="" style="color: rgb(140, 208, 211);">1</span>;
 &nbsp; &nbsp;}

 &nbsp; &nbsp;umount2(fuse-&gt;dest_path, MNT_DETACH); &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">snprintf</span>(opts, <span class="" style="color: rgb(227, 206, 171);">sizeof</span>(opts), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(204, 147, 147);">"fd=%i,rootmode=40000,default_permissions,allow_other,user_id=%d,group_id=%d"</span>,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fuse-&gt;fd, fuse-&gt;global-&gt;uid, fuse-&gt;global-&gt;gid); &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (mount(<span class="" style="color: rgb(204, 147, 147);">"/dev/fuse"</span>, fuse-&gt;dest_path, <span class="" style="color: rgb(204, 147, 147);">"fuse"</span>, MS_NOSUID | MS_NODEV | MS_NOEXEC |
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MS_NOATIME, opts) != <span class="" style="color: rgb(140, 208, 211);">0</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp;ERROR(<span class="" style="color: rgb(204, 147, 147);">"failed to mount fuse filesystem: %s\n"</span>, strerror(errno)); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> -<span class="" style="color: rgb(140, 208, 211);">1</span>;
 &nbsp; &nbsp;}

 &nbsp; &nbsp;fuse-&gt;gid = gid;
 &nbsp; &nbsp;fuse-&gt;mask = mask; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(140, 208, 211);">0</span>;
}</code></pre></li><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">应用进程创建时，大致流程如下（/xref/frameworks/base/core/jni/com_android_internal_os_Zygote.cpp）：</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;"><span class="" style="color: rgb(127, 159, 127);">// Create a private mount namespace and bind mount appropriate emulated</span><span class="" style="color: rgb(127, 159, 127);">// storage for the given user.</span><span class="" style="color: rgb(227, 206, 171);">static</span> <span class="" style="color: rgb(227, 206, 171);">bool</span> MountEmulatedStorage(uid_t uid, jint mount_mode, &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">bool</span> force_mount_namespace) { &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// See storage config details at http://source.android.com/tech/storage/</span>

 &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Create a second private mount namespace for our process</span>
 &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (unshare(CLONE_NEWNS) == -<span class="" style="color: rgb(140, 208, 211);">1</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp;ALOGW(<span class="" style="color: rgb(204, 147, 147);">"Failed to unshare(): %s"</span>, strerror(errno)); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(227, 206, 171);">false</span>;
 &nbsp; &nbsp;} &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Unmount storage provided by root namespace and mount requested view</span>
 &nbsp; &nbsp;UnmountTree(<span class="" style="color: rgb(204, 147, 147);">"/storage"</span>);

 &nbsp; &nbsp;String8 storageSource; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (mount_mode == MOUNT_EXTERNAL_DEFAULT) {
 &nbsp; &nbsp; &nbsp; &nbsp;storageSource = <span class="" style="color: rgb(204, 147, 147);">"/mnt/runtime/default"</span>;
 &nbsp; &nbsp;} <span class="" style="color: rgb(227, 206, 171);">else</span> <span class="" style="color: rgb(227, 206, 171);">if</span> (mount_mode == MOUNT_EXTERNAL_READ) {
 &nbsp; &nbsp; &nbsp; &nbsp;storageSource = <span class="" style="color: rgb(204, 147, 147);">"/mnt/runtime/read"</span>;
 &nbsp; &nbsp;} <span class="" style="color: rgb(227, 206, 171);">else</span> <span class="" style="color: rgb(227, 206, 171);">if</span> (mount_mode == MOUNT_EXTERNAL_WRITE) {
 &nbsp; &nbsp; &nbsp; &nbsp;storageSource = <span class="" style="color: rgb(204, 147, 147);">"/mnt/runtime/write"</span>;
 &nbsp; &nbsp;} <span class="" style="color: rgb(227, 206, 171);">else</span> { &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Sane default of no storage visible</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(227, 206, 171);">true</span>;
 &nbsp; &nbsp;} &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (TEMP_FAILURE_RETRY(mount(storageSource.<span class="" style="color: rgb(204, 147, 147);">string</span>(), <span class="" style="color: rgb(204, 147, 147);">"/storage"</span>,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NULL, MS_BIND | MS_REC | MS_SLAVE, NULL)) == -<span class="" style="color: rgb(140, 208, 211);">1</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp;ALOGW(<span class="" style="color: rgb(204, 147, 147);">"Failed to mount %s to /storage: %s"</span>, storageSource.<span class="" style="color: rgb(204, 147, 147);">string</span>(), strerror(errno)); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(227, 206, 171);">false</span>;
 &nbsp; &nbsp;}</code></pre></li><ol style="list-style-type: lower-roman;margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>创建新的挂载命名空间；</p></li><li><p>将之前的挂载命名空间在/storage下的挂载全部去除，排除影响；</p></li><li><p>根据mount_mode，选择一个路径；</p></li><li><p>将选择的路径绑定到/storage下。</p></li></ol><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">进程在运行时，当外部存储的访问许可发生改变（用户授权）时，基本流程如下（/xref/system/vold/VolumeManager.cpp）：</p><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;">重新挂载部分的逻辑和应用进程创建时基本一致，不难理解。</p><pre style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em;line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em;font-family: Consolas, Inconsolata, Courier, monospace;margin: 0px 0.15em;white-space: pre;overflow: auto;border-radius: 3px;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);padding: 0.5em;background: rgb(63, 63, 63);color: rgb(220, 220, 220);text-size-adjust: none;display: block !important;"><span class="" style="color: rgb(227, 206, 171);">int</span> VolumeManager::remountUid(uid_t uid, <span class="" style="color: rgb(227, 206, 171);">const</span> std::<span class="" style="color: rgb(204, 147, 147);">string</span>&amp; mode) {
 &nbsp; &nbsp;LOG(DEBUG) &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">"Remounting "</span> &lt;&lt; uid &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">" as mode "</span> &lt;&lt; mode;

 &nbsp; &nbsp;DIR* dir; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">struct</span> dirent* de; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">char</span> rootName[PATH_MAX]; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">char</span> pidName[PATH_MAX]; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">int</span> pidFd; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">int</span> nsFd; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">struct</span> stat sb;
 &nbsp; &nbsp;pid_t child; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (!(dir = opendir(<span class="" style="color: rgb(204, 147, 147);">"/proc"</span>))) {
 &nbsp; &nbsp; &nbsp; &nbsp;PLOG(ERROR) &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">"Failed to opendir"</span>; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> -<span class="" style="color: rgb(140, 208, 211);">1</span>;
 &nbsp; &nbsp;} &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Figure out root namespace to compare against below</span>
 &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (sane_readlinkat(dirfd(dir), <span class="" style="color: rgb(204, 147, 147);">"1/ns/mnt"</span>, rootName, PATH_MAX) == -<span class="" style="color: rgb(140, 208, 211);">1</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp;PLOG(ERROR) &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">"Failed to readlink"</span>;
 &nbsp; &nbsp; &nbsp; &nbsp;closedir(dir); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> -<span class="" style="color: rgb(140, 208, 211);">1</span>;
 &nbsp; &nbsp;} &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Poke through all running PIDs look for apps running as UID</span>
 &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">while</span> ((de = readdir(dir))) {
 &nbsp; &nbsp; &nbsp; &nbsp;pidFd = -<span class="" style="color: rgb(140, 208, 211);">1</span>;
 &nbsp; &nbsp; &nbsp; &nbsp;nsFd = -<span class="" style="color: rgb(140, 208, 211);">1</span>;

 &nbsp; &nbsp; &nbsp; &nbsp;pidFd = openat(dirfd(dir), de-&gt;d_name, O_RDONLY | O_DIRECTORY | O_CLOEXEC); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (pidFd &lt; <span class="" style="color: rgb(140, 208, 211);">0</span>) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">goto</span> next;
 &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (fstat(pidFd, &amp;sb) != <span class="" style="color: rgb(140, 208, 211);">0</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PLOG(WARNING) &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">"Failed to stat "</span> &lt;&lt; de-&gt;d_name; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">goto</span> next;
 &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (sb.st_uid != uid) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">goto</span> next;
 &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Matches so far, but refuse to touch if in root namespace</span>
 &nbsp; &nbsp; &nbsp; &nbsp;LOG(DEBUG) &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">"Found matching PID "</span> &lt;&lt; de-&gt;d_name; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (sane_readlinkat(pidFd, <span class="" style="color: rgb(204, 147, 147);">"ns/mnt"</span>, pidName, PATH_MAX) == -<span class="" style="color: rgb(140, 208, 211);">1</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PLOG(WARNING) &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">"Failed to read namespace for "</span> &lt;&lt; de-&gt;d_name; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">goto</span> next;
 &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (!<span class="" style="color: rgb(204, 147, 147);">strcmp</span>(rootName, pidName)) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LOG(WARNING) &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">"Skipping due to root namespace"</span>; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">goto</span> next;
 &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// We purposefully leave the namespace open across the fork</span>
 &nbsp; &nbsp; &nbsp; &nbsp;nsFd = openat(pidFd, <span class="" style="color: rgb(204, 147, 147);">"ns/mnt"</span>, O_RDONLY); &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (nsFd &lt; <span class="" style="color: rgb(140, 208, 211);">0</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PLOG(WARNING) &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">"Failed to open namespace for "</span> &lt;&lt; de-&gt;d_name; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">goto</span> next;
 &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (!(child = fork())) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (setns(nsFd, CLONE_NEWNS) != <span class="" style="color: rgb(140, 208, 211);">0</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PLOG(ERROR) &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">"Failed to setns for "</span> &lt;&lt; de-&gt;d_name;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_exit(<span class="" style="color: rgb(140, 208, 211);">1</span>);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}

 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unmount_tree(<span class="" style="color: rgb(204, 147, 147);">"/storage"</span>);

 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::<span class="" style="color: rgb(204, 147, 147);">string</span> storageSource; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (mode == <span class="" style="color: rgb(204, 147, 147);">"default"</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;storageSource = <span class="" style="color: rgb(204, 147, 147);">"/mnt/runtime/default"</span>;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} <span class="" style="color: rgb(227, 206, 171);">else</span> <span class="" style="color: rgb(227, 206, 171);">if</span> (mode == <span class="" style="color: rgb(204, 147, 147);">"read"</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;storageSource = <span class="" style="color: rgb(204, 147, 147);">"/mnt/runtime/read"</span>;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} <span class="" style="color: rgb(227, 206, 171);">else</span> <span class="" style="color: rgb(227, 206, 171);">if</span> (mode == <span class="" style="color: rgb(204, 147, 147);">"write"</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;storageSource = <span class="" style="color: rgb(204, 147, 147);">"/mnt/runtime/write"</span>;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} <span class="" style="color: rgb(227, 206, 171);">else</span> { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Sane default of no storage visible</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_exit(<span class="" style="color: rgb(140, 208, 211);">0</span>);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (TEMP_FAILURE_RETRY(mount(storageSource.c_str(), <span class="" style="color: rgb(204, 147, 147);">"/storage"</span>,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NULL, MS_BIND | MS_REC | MS_SLAVE, NULL)) == -<span class="" style="color: rgb(140, 208, 211);">1</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PLOG(ERROR) &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">"Failed to mount "</span> &lt;&lt; storageSource &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">" for "</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; de-&gt;d_name;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_exit(<span class="" style="color: rgb(140, 208, 211);">1</span>);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(127, 159, 127);">// Mount user-specific symlink helper into place</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;userid_t user_id = multiuser_get_user_id(uid);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::<span class="" style="color: rgb(204, 147, 147);">string</span> userSource(StringPrintf(<span class="" style="color: rgb(204, 147, 147);">"/mnt/user/%d"</span>, user_id)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (TEMP_FAILURE_RETRY(mount(userSource.c_str(), <span class="" style="color: rgb(204, 147, 147);">"/storage/self"</span>,
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NULL, MS_BIND, NULL)) == -<span class="" style="color: rgb(140, 208, 211);">1</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PLOG(ERROR) &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">"Failed to mount "</span> &lt;&lt; userSource &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">" for "</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; de-&gt;d_name;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_exit(<span class="" style="color: rgb(140, 208, 211);">1</span>);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}

 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_exit(<span class="" style="color: rgb(140, 208, 211);">0</span>);
 &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">if</span> (child == -<span class="" style="color: rgb(140, 208, 211);">1</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PLOG(ERROR) &lt;&lt; <span class="" style="color: rgb(204, 147, 147);">"Failed to fork"</span>; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">goto</span> next;
 &nbsp; &nbsp; &nbsp; &nbsp;} <span class="" style="color: rgb(227, 206, 171);">else</span> {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TEMP_FAILURE_RETRY(waitpid(child, <span class="" style="color: rgb(227, 206, 171);">nullptr</span>, <span class="" style="color: rgb(140, 208, 211);">0</span>));
 &nbsp; &nbsp; &nbsp; &nbsp;}

next:
 &nbsp; &nbsp; &nbsp; &nbsp;close(nsFd);
 &nbsp; &nbsp; &nbsp; &nbsp;close(pidFd);
 &nbsp; &nbsp;}
 &nbsp; &nbsp;closedir(dir); &nbsp; &nbsp;<span class="" style="color: rgb(227, 206, 171);">return</span> <span class="" style="color: rgb(140, 208, 211);">0</span>;
}</code></pre></li><ol style="list-style-type: lower-roman;margin-left: 0px;margin-right: 0px;" class="list-paddingleft-2"><li><p>获取init的挂载命名空间，为了对之后进程的挂载命名空间进行对比，如果一致，不重新绑定；</p></li><li><p>遍历/proc下各个进程目录，根据uid进行筛选；</p></li><li><p>找到对应的pid后，fork子进程进行重新挂载，这里用到setns进行挂载命名空间的切换。</p></li></ol></ul><p><br></p><p><br></p><p style="margin-top: 15px;white-space: normal;text-align: center;"><span style="color: rgb(0, 176, 240);font-family: 宋体;font-size: 14px;white-space: pre-wrap;">✎ 如果您想了解更多关于移动终端安全的内容，请收听我们的</span><strong style="color: rgb(0, 176, 240);font-family: 宋体;font-size: 14px;white-space: pre-wrap;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">微信公众号(终端安全那些事儿)</strong><span style="color: rgb(0, 176, 240);font-family: 宋体;font-size: 14px;white-space: pre-wrap;">，我们将定期为您分享；</span><br></p><p style="white-space: normal;line-height: 25.6px;color: rgb(62, 62, 62);font-family: Verdana, 宋体, sans-serif;min-height: 1em;border-width: 0px;border-style: initial;border-color: initial;list-style: none;word-break: normal;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;text-align: center;"><span style="color: rgb(0, 176, 240);font-family: 宋体;line-height: 22.5px;word-break: normal;font-size: 14px;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">✎ 如果您对移动终端安全有什么问题和建议，关注我们的公众账号后直接回复消息联系我们。</span></p><p style="white-space: normal;line-height: 25.6px;color: rgb(62, 62, 62);font-family: Verdana, 宋体, sans-serif;min-height: 1em;border-width: 0px;border-style: initial;border-color: initial;list-style: none;word-break: normal;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;text-align: center;"><span style="color: rgb(0, 176, 240);font-family: 宋体;line-height: 22.5px;word-break: normal;font-size: 14px;max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><br></span></p><p style="margin-bottom: 10px;white-space: normal;line-height: 25.6px;text-align: center;"><span style="max-width: 100%;color: rgb(0, 176, 240);box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;">终端安全那些事儿&nbsp;</span></strong></span><span style="max-width: 100%;color: rgb(0, 176, 240);font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;">汇聚最优影响力的安全技术文章</span></p><p style="white-space: normal;line-height: 25.6px;text-align: center;"><img src="http://mmbiz.qpic.cn/mmbiz/Sa7mwT4mK886dCibVZvJVBnhzGR5E6sDE6ZJgeuFIakefoSvcCf6jRUXNO5JMLnqAsicWL4yXpxiaC0cbX2iaWibcYA/0?wx_fmt=png" style="width: 138px !important; height: 137px !important;"></p><p style="white-space: normal;line-height: 25.6px;text-align: center;"><span style="color: rgb(0, 176, 240);font-size: 11px;">▲长按二维码可识别关注</span></p><p style="text-align: center;"><span style="color: rgb(0, 176, 240);font-size: 11px;"><br></span></p><p><br></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1515989891&src=3&ver=1&signature=yyLj*6br2FUtW3BtBE3siLzBNVIeS0k49bS4kssGXwf*0NkFqIADcPjHSTCBPEcWR5SS8axxfH5aYkjejEUxuS*dQ9x614Uh8MpCtgjT3Avr5hwh4Leu03D4FB3rckfMABlZ1xnL99m-27YyRj5LIwdAUotzcslnWEmc9Up-Q-A=">微信地址</a>
{% endraw  %}

