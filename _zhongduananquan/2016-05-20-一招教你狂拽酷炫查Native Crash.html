---
title: 一招教你狂拽酷炫查Native Crash
author: 李咏华
date: '2016-05-20 00:00:00 +0000'

---

{% raw  %}
<p><strong style="font-size: 24px;">一 / 前言</strong><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;">IDA Pro是一款可视化的二进制代码文件逆向分析工具，功能十分强大，常用于游戏破解、软件逆向以及其他需要对二进制机器码进行逆向分析的场景。</span></p><p style="margin-top: 15px;"><span style="font-size: 18px;">本文将要介绍的是如何在分析和排查android native crash的过程中运用IDA Pro来帮助我们快速地收集有效信息、定位问题原因。</span></p><p style="margin-top: 15px;"><span style="font-size: 18px;">下面将通过两类案例来介绍IDA Pro在实际过程中的基本用法和操作，一是android N 系统的native crash问题根因分析，二是定位和排查native crash堆栈。</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;"><br></span></p><p style="margin-top: 15px;"><span style="font-size: 24px;"><strong>二 / 分析android N native crash</strong></span></p><p style="margin-top: 15px;"><span style="font-size: 18px;">问题源自于谷歌在android N系统上的改动，新增了对第三方native so限制，不再允许开发者自由使用非公开的系统native api，禁止第三方native so动态链接或者使用dlopen动态加载大部分的系统so库。</span></p><p style="margin-top: 15px;"><span style="font-size: 18px;">不符合规范的so在android N的正式发布版本上将会导致应用直接crash，而在目前谷歌放出的预览版上则会通过弹窗提示开发者，具体效果如下图所示：</span></p><p style="margin-top: 15px; text-align: center;"><img src="/zhongduananquan/images/3554c4cc25a101f9206b11df9de823563653277c.png" style="width: 277px !important; height: 239px !important; visibility: visible !important;"><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;">在谷歌的兼容性测试组件的源码中罗列了一份android 系统so的白名单（<span style="font-size: 18px; color: rgb(61, 170, 214);">https://android.googlesource.com/platform/cts/+/4bbdf2da6dac0740b25e01b3be30e49f1e43ea66/tests/tests/jni/libjnitest/android_jni_cts_LinkerNamespacesTest.cpp</span>），开发者只能链接使用白名单中的系统so。白名单列表如下：</span></p><blockquote><p style="margin-top: 5px;"><span style="font-size: 18px;">libandroid.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libc.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libdl.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libEGL.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libGLESv1_CM.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libGLESv2.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libGLESv3.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libicui18n.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libicuuc.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libjnigraphics.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">liblog.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libmediandk.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libm.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libOpenMAXAL.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libOpenSLES.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libRS.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libstdc++.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libwebviewchromium_plat_support.so</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;">libz.so</span></p></blockquote><p style="margin-top: 15px;"><span style="font-size: 18px;">所以必须结合白名单对我们的so进行检查，主要的检查点有：</span></p><p style="margin-top: 15px;"><strong><span style="font-size: 18px;">1、</span></strong><span style="font-size: 18px;">检查so的外部依赖库链接了哪些白名单之外的系统so。</span></p><p style="margin-top: 5px;"><strong><span style="font-size: 18px;">2、</span></strong><span style="font-size: 18px;">检查so使用了哪些非公开的系统api，也就是白名单之外的系统so所导出的函数。</span></p><p style="margin-top: 15px;"><span style="font-size: 18px;">众所周知，so就是ELF文件，至于具体的文件格式，在此就不作过多地描述了。我们需要关注的是so文件中的三个部分：</span></p><p style="margin-top: 15px;"><strong><span style="font-size: 18px;">1、</span></strong><span style="font-size: 18px;">外部依赖库——记录了so文件动态链接了哪些外部so。</span></p><p style="margin-top: 5px;"><strong><span style="font-size: 18px;">2、</span></strong><span style="font-size: 18px;">导入表——记录了so文件使用了哪些外部函数。</span></p><p style="margin-top: 5px;"><strong><span style="font-size: 18px;">3、</span></strong><span style="font-size: 18px;">导出表——记录了so文件提供了哪些函数给其他so使用。</span></p><p><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;">而IDA Pro就能够解析ELF文件格式，并且提供了可视化的窗口视图查看相关的解析数据。因此使用IDA Pro可以非常直观地查看我们所关注的信息，快速地确定问题。下面就是具体的使用过程：</span></p><p style="margin-top: 15px;"><span style="font-size: 20px;"><strong>首先</strong></span><span style="font-size: 18px;">，使用IDA Pro打开要检查的so，在主视图界面（IDA View）的顶部就可以看到so的外部依赖库信息，这是IDA Pro根据so文件的相应数据自动生成的一些注释性的文本信息，如下图所示：</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/ad9a707c6fd270f2d619f7414f9d913ef37bfddd.png" style="width: 554px !important; height: 322px !important;"><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;">视图中非常直观地显示了该so所链接的外部so，结合之前的白名单，就可以快速地确定so链接了哪些白名单之外的系统so。</span></p><p style="margin-top: 15px;"><span style="font-size: 20px;"><strong>然后</strong></span><span style="font-size: 18px;">，进入导入表界面（Import视图）查看该so所使用的外部函数，分析so使用的非公开的系统api，如下图所示：</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/fa51d7c6bda509504e0fda17517b0939ea972ff0.png" style="width: 770px !important; height: 555.342px !important;"><br></p><p><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;">导入表界面（Import视图）有排序和检索功能，根据函数名排序之后可以很方便地进行检索。</span></p><p style="margin-top: 15px;"><span style="font-size: 18px;">这里可以先使用排除法缩小目标范围，排除常见的linux c api、android ndk api和一些编译器自动添加的异常处理函数之后，再结合之前确定的非白名单的系统so，通过IDA Pro将其一一打开，并查看导出表界面（Export视图，和Import视图类似），利用界面的排序和检索功能快速地进行对比验证，就可以确定哪些是非公开的系统api了。</span></p><p style="margin-top: 15px;"><span style="font-size: 18px;">当然，很多时候其实并不需要最后的对比验证，ndk开发经验比较丰富或者对系统源码比较熟悉的话，查看导入表就可以基本确定哪些是非公开的系统api了。</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;"><br></span></p><p style="margin-top: 15px;"><strong><span style="font-size: 24px;">三 / 分析native crash堆栈</span></strong></p><p style="margin-top: 15px;"><span style="font-size: 18px;">对于native crash堆栈，也可以使用IDA Pro来分析。下面将介绍如何使用IDA Pro来进行具体的分析：</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/1cbd9636b57bbfdcbfc3134111c573b3823af4ef.png" style="width: 554px !important; height: 194px !important;"><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;">上图就是一个native crash堆栈，其中比较重要的信息就是crash的类型和crash的指令地址。段错误一般是由空指针或者越界访问引起的，而crash的指令地址则可以用来定位问题的相关代码。</span></p><p style="margin-top: 15px;"><span style="font-size: 18px;">在分析之前需要先介绍一下使用IDA Pro对so进行逆向分析时的一些常用操作：</span></p><p style="margin-top: 15px;"><strong><span style="font-size: 18px;">1、</span></strong><span style="font-size: 18px;">快捷键g——可以快速跳转到输入的指定地址。</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/83591a5ba0fd77718e73283b96cad0e8c8d98e83.png" style="width: 334px !important; height: 107px !important;"><br></p><p style="margin-top: 15px;"><strong><span style="font-size: 18px;">2、</span></strong><span style="font-size: 18px;">快捷键F5——可以查看与当前汇编代码对应的伪C代码。</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/80f25d343218c195599855ceff7dc33df0fe7981.png" style="width: 770px !important; height: 146.799px !important;"><br></p><p style="margin-top: 15px;"><strong><span style="font-size: 18px;">3、</span></strong><span style="font-size: 18px;">快捷键x——可以查询变量、函数或其他标识的引用位置。</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/83a7aee9fe6feba3d39f3877f5d107fca0ce05f0.png" style="width: 770px !important; height: 135.719px !important;"><br></p><p><strong>4、</strong><span style="font-size: 18px;">快捷键n——可以对变量、函数或者其他标识进行重命名</span></p><p style="margin-top: 15px;"><strong><span style="font-size: 18px;">5、</span></strong><span style="font-size: 18px;">快捷键;——可以对某处位置添加备注</span></p><p><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;">IDA Pro的常用操作还有很多，这里就就不再一一列举了。下面是具体的分析过程：</span></p><p style="margin-top: 15px;"><span style="font-size: 20px;"><strong>首先</strong></span><span style="font-size: 18px;">，使用IDA Pro打开发生crash的so，并使用快捷键g跳转到crash的指令地址。</span></p><p style="margin-top: 15px;"><span style="font-size: 18px;">这里要注意的是，有些情况下需要对crash堆栈进行一些处理，利用模块加载基址进行地址换算，而这里的crash指令地址经过确认已经是该模块内的偏移地址，所以并不需要进行地址换算，但是在分析定位crash的真正位置时还是要进行一些判断，比如是否要将crash的指令地址减去模块加载基址，这些往往要根据实际情况来决定，不能一概而论。</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/a559d7e6b7df48fd0396921e5a68f610f90eb9af.png" style="width: 541px !important; height: 225px !important;"><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;">上图就是发生crash时代码的具体位置，从汇编代码中可以看出，当前指令是想访问R3寄存器中存放的内存地址，也因此可以基本断定crash是由于访问了空指针或者无效的内存地址导致的。</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/567e82f08993619c68b4c834c60be16fc7d98d71.png" style="width: 770px !important; height: 62.3201px !important;"><br></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/024bd7ec9ebe5a301d30261f79b35b98be65d732.png" style="width: 770px !important; height: 40.1619px !important;"><br></p><p style="margin-top: 15px;"><span style="font-size: 20px;"><strong>然后</strong></span><span style="font-size: 18px;">，使用快捷键F5查看对应的伪C代码，并根据变量的存放位置初步分析是在使用某个全局作用域的变量时出现了问题，由此推断可能是该变量没有进行初始化或者没有被正确赋值。</span></p><p style="margin-top: 15px;"><span style="font-size: 18px;">至于如何去关联对应的源代码，可以先查看对应的伪C代码的函数名，如果发现函数是sub_xxx之类的名字，则说明在编译的过程中并没有生成该函数的符号链接信息，这时候就需要使用快捷键x查看调用该函数的地方，如果调用者也是如此，则继续往上回溯，最后追溯到一个全局的数据结构中，具体信息如下图所示：</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/54971baf4dc4949d2fd62d23e2d2e66d193d6e67.png" style="width: 480px !important; height: 23px !important;"></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/ada871e5b94231d316228b65d5956dc482a77358.png" style="width: 388px !important; height: 78px !important;"></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/3fce210c34b6bc5aafa96c1c1d5e75c30eb59f2b.png" style="width: 770px !important; height: 96.9424px !important;"></p><p style="margin-top: 15px;"><span style="font-size: 18px;">从<span style="font-size: 20px;"><strong>最后</strong></span>的图中可以很明显的看出，这就是利用jni注册native方法时所需要用到的一个数据结构，而在这里也可以关联到具体的函数代码，此时再结合源码、伪C代码以及整个回溯过程进行倒推，就可以找到crash的源码了。</span></p><p style="margin-top: 15px;"><span style="font-size: 18px;">除此之外，对于一些由系统so所触发的native crash，在没有太多分析手段的时候，依然能够使用IDA Pro对crash进行一定程度上的分析，方法还是和前一个crash案例类似，需要对应的so，并且没有对应源码（当然一定程度上可以参考某些版本的系统源码），所以更多的是对汇编和伪C代码的分析。</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/3e490bb9c9204256f0e9d78c71ff6e4ee33bc575.png" style="width: 231px !important; height: 241px !important;"><br></p><p><span style="font-size: 18px;">上图就是一个发生在系统模块的crash分析，需要拿到对应的系统so才能进行具体的分析，否则将无法定位正确的crash指令地址。定位之后再去分析具体的汇编指令、查看伪C代码、参考对应版本的系统源码。</span><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;">如果静态分析无法定位问题根因的话，可以通过动态调试去获取一些运行时数据来帮助自己进一步分析问题。IDA Pro自带安卓调试器，支持动态调试安卓应用，可以调试应用加载的任何模块（包括系统模块在内）。下面就简单介绍一下</span></p><p style="margin-top: 20px; text-align: center;"><span style="font-size: 18px;"><strong>如何使用IDA Pro进行动态调试</strong></span></p><p style="margin-top: 20px;"><span style="font-size: 20px;"><strong>首先</strong></span><span style="font-size: 18px;">是一些调试环境的配置和调试前的准备工作，主要有以下几点：</span></p><p style="margin-top: 15px;"><strong><span style="font-size: 18px;">1、</span></strong><span style="font-size: 18px;">将IDA Pro自带的安卓调试器android_server放入被调试机器并通过控制台直接运行，这里可能需要使用chmod命令授予可执行权限。</span></p><p style="margin-top: 15px;"><strong><span style="font-size: 18px;">2、</span></strong><span style="font-size: 18px;">使用adb forward命令建立PC和Android之间的调试连接通道（adb forward tcp:23946 tcp:23946）。</span></p><p style="margin-top: 15px;"><strong><span style="font-size: 18px;">3、</span></strong><span style="font-size: 18px;">使用IDA Pro连接android_server（Debugger -&gt; Attach -&gt; Remote ARMLinux/Android debugger）。</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/afa59e68d434ee433476923a14f762fdf59ac9c4.png" style="width: 770px !important; height: 465.324px !important;"><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;"><strong>4、</strong>调试异常捕获设置中忽略可能的干扰信号，比如SIGILL信号和SIGTRAP信号。</span><br></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/c42c408e6cc5305f0cb01fa83017984ebf9b92b6.png" style="width: 405px !important; height: 246px !important;"><br></p><p style="margin-top: 15px;"><strong><span style="font-size: 18px;">5、</span></strong><span style="font-size: 18px;">附加到具体的进程进行调试。</span><br></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/61ffadd399441c198cebae1cd21044c460917063.png" style="width: 348px !important; height: 266px !important;"><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;">附加成功之后就可以开始调试了，下面介绍下</span></p><p style="margin-top: 20px; text-align: center;"><span style="font-size: 18px;"><strong>调试过程中一些窗口视图的使用</strong></span></p><p style="margin-top: 20px;"><strong><span style="font-size: 18px;">1、</span></strong><span style="font-size: 18px;">Modules窗口可以查看进程加载了哪些模块，以及模块的基址和大小，在Modules窗口可以选择我们想要调试的模块，点击之后就可以进入具体的模块视图。</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/8029f7cc109e566760e7d390e66831ffa4ab8495.png" style="width: 429px !important; height: 212px !important;"><br></p><p style="margin-top: 15px;"><strong><span style="font-size: 18px;">2、</span></strong><span style="font-size: 18px;">Registers窗口可以查看寄存器信息。</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/5a6741a28e4f430e5919b5a4e8e356a9a3674f9f.png" style="width: 322px !important; height: 349px !important;"><br></p><p style="margin-top: 15px;"><strong><span style="font-size: 18px;">3、</span></strong><span style="font-size: 18px;">Stack窗口可以查看当前函数的局部变量信息，这里需要根据汇编代码确定局部变量的存放位置。</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/5f4183fc52152d285ecd0137dc92c07979b349f0.png" style="width: 383px !important; height: 186px !important;"><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;">在调试的过程中，需要重点观察的一般就是函数参数、函数返回值以及函数局部变量。根据arm的调用约定，前四个参数都会通过R0 - R3寄存器进行传递，多出来的函数则会通过压栈的方式进行传递，而函数返回值则通过R0寄存器返回给caller，至于局部变量，则需要通过汇编代码确定其在栈中的位置之后再去栈中查看。</span></p><p style="margin-top: 5px;"><span style="font-size: 18px;"><br></span></p><p style="margin-top: 5px;"><span style="font-size: 24px;"><strong>四 / 结语</strong></span></p><p style="margin-top: 15px;"><span style="font-size: 18px;">在动态调试的</span><span style="font-size: 18px;">过程中也会遇到一些坑，以下是个人一些</span><strong style="font-size: 18px;">经验和总结</strong><span style="font-size: 18px;">：</span></p><p style="margin-top: 15px; white-space: normal;"><strong><span style="font-size: 18px;">1、</span></strong><span style="font-size: 18px;">需要根据调试的实际情况忽略某些信号的捕获，否则会有很多干扰信号影响调试。</span></p><p style="margin-top: 15px; white-space: normal;"><strong><span style="font-size: 18px;">2、</span></strong><span style="font-size: 18px;">一些会导致进程退出的信号（除非是正常退出，但大部分都是异常退出）不要传递给进程。</span></p><p style="margin-top: 15px; white-space: normal;"><strong><span style="font-size: 18px;">3、</span></strong><span style="font-size: 18px;">调试器中断暂停过程的时间不能太长，否则会有resume失败的风险。</span></p><p style="margin-top: 15px; white-space: normal;"><strong><span style="font-size: 18px;">4、</span></strong><span style="font-size: 18px;">调试器有时候会跑飞，断点停不下来，这里可能就需要反复调试。</span></p><p style="margin-top: 15px; white-space: normal;"><span style="font-size: 18px;"><br></span></p><p style="margin-top: 15px; white-space: normal;"><span style="font-size: 18px;"><br></span></p><p style="margin-top: 15px; white-space: normal;"><span style="font-size: 18px;"></span></p><p style="margin-top: 15px; white-space: normal;"><span style="color: rgb(0, 176, 240); font-family: 宋体; font-size: 14px; white-space: pre-wrap;">✎ 如果您想了解更多关于移动终端安全的内容，请收听我们的</span><strong style="color: rgb(0, 176, 240); font-family: 宋体; font-size: 14px; white-space: pre-wrap; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">微信公众号(终端安全那些事儿)</strong><span style="color: rgb(0, 176, 240); font-family: 宋体; font-size: 14px; white-space: pre-wrap;">，我们将定期为您分享；</span><br></p><p style="line-height: 25.6px; color: rgb(62, 62, 62); font-family: Verdana, 宋体, sans-serif; min-height: 1em; white-space: pre-wrap; border: 0px; list-style: none; word-break: normal; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="color: rgb(0, 176, 240); font-family: 宋体; line-height: 22.5px; word-break: normal; font-size: 14px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">✎ 如果您对移动终端安全有什么问题和建议，关注我们的公众账号后直接回复消息联系我们。</span></p><p style="line-height: 25.6px; color: rgb(62, 62, 62); font-family: Verdana, 宋体, sans-serif; min-height: 1em; white-space: pre-wrap; border: 0px; list-style: none; word-break: normal; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="color: rgb(0, 176, 240); font-family: 宋体; line-height: 22.5px; word-break: normal; font-size: 14px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br></span></p><p style="margin-bottom: 10px; white-space: normal; line-height: 25.6px; text-align: center;"><span style="max-width: 100%; color: rgb(0, 176, 240); box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 12px; box-sizing: border-box !important; word-wrap: break-word !important;">终端安全那些事儿&nbsp;</span></strong></span><span style="max-width: 100%; color: rgb(0, 176, 240); font-size: 12px; box-sizing: border-box !important; word-wrap: break-word !important;">汇聚最优影响力的安全技术文章</span></p><p style="white-space: normal; line-height: 25.6px; text-align: center;"><img src="/zhongduananquan/images/a1c02648331a7d53620c4031cfba35723042669a.png" style="width: 138px !important; height: 137px !important;"></p><p style="white-space: normal; line-height: 25.6px; text-align: center;"><span style="color: rgb(0, 176, 240); font-size: 11px;">▲长按二维码可识别关注</span></p><p style="margin-top: 15px; white-space: normal;"><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;"></span></p>
{% endraw  %}

