---
title: Android沙箱——在这个箱子里我们能够做什么？
author: 余浩农
date: '2017-01-13 00:00:00 +0000'

---

{% raw  %}
<p style="margin-top: 5px;"><span style="font-size: 20px;"><strong><span style="color: rgb(51, 51, 51); font-family: 宋体;">前言</span></strong></span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;">安全沙箱是系统中一个虚拟的箱子，在这个箱子里可以运行带有安全威胁或者其它用户希望控制的应用。</span><span style="color: rgb(51, 51, 51); font-family: 宋体;">将一个应用放在沙箱里运行，其绝大多数</span><span style="color: rgb(51, 51, 51); font-family: 宋体;">IO</span><span style="color: rgb(51, 51, 51); font-family: 宋体;">操作、系统服务请求、函数调用都可以被监控和拦截。</span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;">基于这样的特性可以衍生出很多应用，比如应用的双开和多开、安全策略定制、病毒和木马隔离、分屏和多窗口、隐私保护等。听起来似乎无所不能，但沙箱毕竟只是</span><span style="color: rgb(51, 51, 51); font-family: 宋体;">Android</span><span style="color: rgb(51, 51, 51); font-family: 宋体;">系统上的一个普通应用，所以也会受到系统权限和能力的制约。</span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;">沙箱的核心功能是对沙箱内应用的有效控制。一个沙箱的参考实现框图如下：</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/58e1bfa1be87936fa9f3abd626a4fd502118d877.png" style="color: rgb(51, 51, 51); font-family: 宋体; width: 770px !important; height: 391.826px !important; visibility: visible !important;"><br></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;">本文介绍沙箱启动一个app的主要过程和原理。整个流程跟Android系统安装和运行app的过程类似，主要包括解析apk信息、在沙箱内创建app数据目录、通过代理启动stub进程、执行各种hook和注入、创建app的Application对象并执行回调、创建app的launching Activity对象并执行其生命周期回调：</span><br></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/1a8d8fda4ba1f2a7bd341e067a127f3ce309771f.png" style="width: 422px !important; height: 887px !important;"></p><p style="margin-top: 15px;"><br></p><p style="margin-top: 15px;"><span style="font-size: 20px;"><strong><span style="color: rgb(51, 51, 51); font-family: 宋体;">一 / </span></strong></span><span style="font-size: 18px;"><strong><span style="color: rgb(51, 51, 51); font-family: 宋体;">想在沙箱里运行其它app，第一步要找到它的apk文件</span></strong></span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">这里有两种方法，一种是在沙箱里引导用户安装app。因为安装入口在沙箱，所以apk的下载和安装就受到沙箱的控制，沙箱自然也就能读到apk文件。但这种方法要求用户重新下载和安装app，用户体验较差，且重新安装的apk文件也会占用额外的存储空间。</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">另一种方法则是直接读取设备上已经安装好的apk文件。Android在安装非系统app的过程中会把apk文件拷贝到/data/app/目录下。以安装微信为例，系统会在/data/app目录下创建一个名为com.tencent.mm-1的文件夹（升级时会切换使用带-2后缀的文件夹），将apk拷贝到该文件夹下并命名为base.apk。该apk文件一般都是worldreadable的（Google Play上下载的收费应用除外），即任何人都有读权限：</span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;"><img src="/zhongduananquan/images/43c115912fbd9905a5978a39e794284437f6ebd8.png" style="width: 417px !important; height: 87px !important;"><br></span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;"><br></span></p><p style="margin-top: 15px;"><span style="font-size: 20px;"><strong><span style="color: rgb(51, 51, 51); font-family: 宋体;">二 /&nbsp;</span><span style="font-size: 18px; color: rgb(51, 51, 51); font-family: 宋体;">找到apk文件之后，如何解析apk文件信息？</span></strong></span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">apk文件的解析可以直接利用Android框架所用到的一些工具类，也可以参考android源码解析apk的过程自己重新实现一套。前者灵活性不如后者，也有一些Android版本兼容性的问题要处理，但是使用起来非常简单，关键步骤只有一个，即利用android.content.pm.PackageParser类的parsePacakge方法：</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/43d1474d7bfc15b5549bda74b459d738db7dc91e.png" style="width: 345px !important; height: 51px !important;"><br><span style="color: rgb(51, 51, 51); font-family: 宋体;">如此即可解析得到一个包含apk各种内外部信息的PackageParser.Package对象。这里有一点要注意，PackageParser这个类并不是公开的，而是带有@hide注释，即为隐藏的API，我们无法通过android SDK直接访问。此时可以通过修改Android框架源码，去掉hide属性重新编译出一个android.jar包，或者通过Java反射的方法来访问带有hide注释的API。</span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;"><br></span></p><h2 style="margin-top: 15px;"><strong style="font-size: 20px;"><span style="font-family: 宋体; color: rgb(51, 51, 51);">三 / </span></strong><span style="font-size: 18px;"><strong><span style="font-family: 宋体; color: rgb(51, 51, 51);">有了apk文件信息，如何在沙箱中给它创造一个可执行环境？</span></strong></span></h2><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">Android系统安装app的主要过程，可以概括为以下三步：</span></p><p style="margin-top: 15px;"><strong><span style=";font-family:宋体;color:#333333">1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检查：</span></strong><span style=";font-family:宋体;color:#333333">解析apk的AndroidManifest.xml文件、执行签名校验等</span></p><p style="margin-top: 15px;"><strong><span style=";font-family:宋体;color:#333333">2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;登记：</span></strong><span style=";font-family:宋体;color:#333333">保存apk文件的相关内容，记录应用和组件的各种信息</span></p><p style="margin-top: 15px;"><strong><span style=";font-family:宋体;color:#333333">3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;入住：</span></strong><span style=";font-family:宋体;color:#333333">在data目录下给app分配私有空间/data/data/packageName</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">其中最后一步相当于给app创造了一个独立的环境，真正赋予app以生命。然而，/data/data/目录下的文件是每个app所私有的，不同UID的应用之间无法互相访问数据。从沙箱的角度出发，想要在沙箱的进程中运行其它app代码，自然需要将app的本地数据读写重定位到沙箱有权限读写的地方。最直观的方法，就是在沙箱自己的data目录下模拟系统给每个在沙箱中运行的app重新创造一个data目录。这里涉及到IO重定向的问题，后文详细介绍。</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">在真正运行app之前，我们还需要先在app的data目录下提前准备好一些东西。比如lib目录，该目录用于存放app的本地so库，系统在安装apk的过程会把apk文件lib目录下的so文件拷贝到app data文件夹下对应的lib目录。app在加载so文件的时候会到该目录下查找，如果找不到so文件app很大概率会crash。所以沙箱也要模拟系统在虚拟的data目录下提前放好东西。拷贝lib的过程同样可以利用Android框架隐藏的工具类com.android.internal.content.NativeLibraryHelper：</span></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/02fbee6fdb438036a02d8a1c1f603dbd9b9d479b.png" style="width: 410px !important; height: 52px !important;"><br><span style="color: rgb(51, 51, 51); font-family: 宋体;">NativeLibraryHelper的具体使用方法和原理可查看android源码。</span></p><h2 style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333"><br></span></h2><h2 style="margin-top: 15px;"><span style="font-size: 20px;"><strong><span style="font-family: 宋体; color: rgb(51, 51, 51);">四 / <span style="font-size: 18px; font-family: 宋体; color: rgb(51, 51, 51);">准备好app在沙箱中的运行环境，那么入口在哪呢？</span></span></strong></span></h2><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">我们知道一个普通app的入口是intent-filter带有action为"android.intent.action.MAIN"且category为"android.intent.category.LAUNCHER"的activity。正常情况下，通过PackageManager的getLaunchIntentForPackage(packageName)方法即可得到用于启动app main activity的intent。如果在沙箱里也这么做，当然也可以启动app，但是这样启动的app就像脱缰的野马，跟沙箱半毛钱关系没有。</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">Android的activity属性都是写死在AndroidManifest.xml里边，每个activity属于哪个package哪个进程在apk安装的时候就已经决定了。沙箱无法修改其它appactivity的属性，但是，沙箱可以获取到appactivity的所有属性并且访问到该activity类。毕竟app的activity也只不过是一个类，存于dex文件中，而沙箱既然能访问base.apk文件，自然就可以访问到包含于其中的dex文件从而获取class信息（除非apk经过加固处理等）。Android activity实例的创建和生命周期回调都在应用程序进程中进行，主要由android.app包下的ActivityThread、Instrumentation和Activity三个类协同完成，并不依赖于系统提供的各种service：</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333"><img src="/zhongduananquan/images/879ff8e156de3b01a73c664bb3df4e65ed44dc99.png" style="width: 770px !important; height: 1291.23px !important;"></span><span style="color: rgb(51, 51, 51); font-family: 宋体;">这样看来activity本身似乎跟系统没什么关系，沙箱完全可以在自己的进程中对app的activity进行各种操作。然而，activity并不是一个孤立的存在，Android还要处理activity之间的关系，比如activity的跳转、task、activity stack管理等。当然所有这些沙箱都可以模拟系统自己也实现一套，从而完全接管app的activity管理，代价则是实现成本高、代码量大。折中的方案就是依然把activity的管理交给系统，而沙箱在本地做一层代理，从而实现在沙箱进程中运行appactivity，监控appactivity的同时保证activity的表现在系统层面和用户层面都跟其它普通应用一样。一个参考实现过程如下：</span><span style=";font-family:宋体;color:#333333"><br></span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;"><img src="/zhongduananquan/images/aa5debaae3bbbfbbd3de78e4d3562cfff79d6a63.png" style="width: 718px !important; height: 562px !important;"></span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;">简单概括就是沙箱自己先声明一个stubActivity，该activity携带目标activity的信息，利用该activity完成和系统的交互（注册、验证）之后把自己替换回目标activity，从而在沙箱进程中启动目标activity的生命周期。其中最关键的一步是hook掉ActivityThread的mH成员（其实质就是一个主线程的Handler）。hook的实现比较简单，直接用反射替换掉mH的mCallback成员即可。mCallback可以拦截Handler的handleMessage()，这从Handler的dispatchMessage方法即可看出：</span><span style="color: rgb(51, 51, 51); font-family: 宋体;"><br></span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">&nbsp;<img src="/zhongduananquan/images/57587fcb3a30e7b03c81b482f15bcf6613d7c153.png" style="width: 417px !important; height: 199px !important;"><br></span><span style="color: rgb(51, 51, 51); font-family: 宋体;">mH是ActivityThread的消息处理中心，android四大组件的启动、创建或者安装都由mH的handleMessage()分配到不同的函数进行实际处理。所以控制了mH的mCallback也就相当于控制了Android组件在应用端的启动。Android系统服务和应用之间传递组件信息都由一个结构体来描述（见下表），沙箱只需在hook的mH消息处理函数中将代理组件的信息替换回app的组件即可绕过系统的注册和校验过程。</span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;"><br></span></p><table cellspacing="0" cellpadding="0"><tbody><tr><td width="189" style="border-color: windowtext; border-width: 1px; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">组件</span></p></td><td width="189" style="border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-style: none; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">结构体</span></p></td><td width="189" style="border-top-color: windowtext; border-right-color: windowtext; border-bottom-color: windowtext; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-style: none; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">关键字段</span></p></td></tr><tr><td width="189" style="border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-top-style: none; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">Activity</span></p></td><td width="189" style="border-top-style: none; border-left-style: none; border-bottom-color: windowtext; border-bottom-width: 1px; border-right-color: windowtext; border-right-width: 1px; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">ActivityClientRecord</span></p></td><td width="189" style="border-top-style: none; border-left-style: none; border-bottom-color: windowtext; border-bottom-width: 1px; border-right-color: windowtext; border-right-width: 1px; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">intent, activityInfo</span></p></td></tr><tr><td width="189" style="border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-top-style: none; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">Service</span></p></td><td width="189" style="border-top-style: none; border-left-style: none; border-bottom-color: windowtext; border-bottom-width: 1px; border-right-color: windowtext; border-right-width: 1px; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">CreateServiceData</span></p></td><td width="189" style="border-top-style: none; border-left-style: none; border-bottom-color: windowtext; border-bottom-width: 1px; border-right-color: windowtext; border-right-width: 1px; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">intent, info (ServiceInfo类)</span></p></td></tr><tr><td width="189" style="border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-top-style: none; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">ContentProvider</span></p></td><td width="189" style="border-top-style: none; border-left-style: none; border-bottom-color: windowtext; border-bottom-width: 1px; border-right-color: windowtext; border-right-width: 1px; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">ProviderInfo</span></p></td><td width="189" style="border-top-style: none; border-left-style: none; border-bottom-color: windowtext; border-bottom-width: 1px; border-right-color: windowtext; border-right-width: 1px; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">authority</span></p></td></tr><tr><td width="189" style="border-right-color: windowtext; border-bottom-color: windowtext; border-left-color: windowtext; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-top-style: none; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">BroadcastReceiver</span></p></td><td width="189" style="border-top-style: none; border-left-style: none; border-bottom-color: windowtext; border-bottom-width: 1px; border-right-color: windowtext; border-right-width: 1px; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">ReceiverData</span></p></td><td width="189" style="border-top-style: none; border-left-style: none; border-bottom-color: windowtext; border-bottom-width: 1px; border-right-color: windowtext; border-right-width: 1px; padding: 0px 7px;"><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">intent, info (ActivityInfo类)</span></p></td></tr></tbody></table><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">&nbsp;</span><span style="color: rgb(51, 51, 51); font-family: 宋体;">Service、ContentProvider和BroadcastReceiver的具体代理过程跟Activity类似，主要通过（借助mH）hook掉ActivityThread的handleLaunchActivity、handleCreateService、handleServiceArgs、handleBindService、handleInstallProvider、handleReceiver以及（借助Binder Hook) hook掉ActivityManager的registerReceiver等方法来实现。沙箱通过代理的方法绕过android组件的注册和校验过程，至此可实现android app的基本运转。</span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;"><br></span></p><h2 style="margin-top: 15px;"><strong><span style="font-family: 宋体; color: rgb(51, 51, 51); font-size: 20px;">五 / <span style="font-size: 18px;">然而，app的真正入口并不是Activity！</span></span></strong><br></h2><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">从应用的角度看，入口应该是Application的attachBaseContext()方法。一个app可能会实现自己的Appilcation并在其生命周期回调attachBaseContext()和onCreate()中做一些应用初始化操作。所以，沙箱在创建app的启动activity之前，还需要先创建app的Application并执行其回调。可以利用ActivityThread和LoadedApk这两个Android框架类来实现，参考代码如下:</span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;"><img src="/zhongduananquan/images/f7490b5267945ce38e6c98f6568233bd7dacd9e8.png" style="width: 417px !important; height: 102px !important;"><br></span><span style="color: rgb(51, 51, 51); font-family: 宋体;">其中makeApplication传入了沙箱宿主的Instrumentation作为参数，该Instrumentation对象会在app Application实例化和attach之后调用Application的onCreate回调。</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">既然Application是app的入口，沙箱只要在调用makeApplication之前对所有需要修改的属性进行反射替换，对所有需要进行监控或修改的方法进行hook操作，即可实现对app的有效控制。本文接下来对沙箱中涉及到的Hook技术和IO重定向进行简要介绍。</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333"><br></span></p><blockquote><h2 style="margin-top: 15px;"><span style="font-size: 18px;"><strong><span style="font-family: 宋体; color: rgb(51, 51, 51);">Binder Hook</span></strong></span></h2></blockquote><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">Binder Hook，顾名思义就是把Binder接口给Hook掉。我们知道Android的IPC通信主要基于Binder来实现，Android框架基本上都是通过Binder接口为app提供各种服务，比如常见的AMS，PMS，WMS等。把app所用到的Binder引用替换掉，沙箱也就控制了app与系统服务的交互。</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">一个实现的思路，就是找到app的Binder引用缓存，通过反射替换成沙箱自己构造的Binder对象。那么怎么找到Binder缓存呢？</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">查看AOSP源码，可以发现Android框架提供的Service主要都是通过ServiceManager的getService方法获取：</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333"><img src="/zhongduananquan/images/3df6ceac1156963651638c97958832529b400d7e.png" style="width: 290px !important; height: 151px !important;"></span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;">其中，sCache用于存放service名字到IBinder接口的映射，也就是我门要找的Binder缓存。我们通过反射就能轻松替换掉IBinder，以activity service为例，参考代码：</span><span style=";font-family:宋体;color:#333333"><br></span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;"><img src="/zhongduananquan/images/f579fdea4c588f591cc3ad208d4b2ca3d29c5b85.png" style="width: 333px !important; height: 66px !important;"></span></p><p style="margin-top: 15px;"><span style="color: rgb(51, 51, 51); font-family: 宋体;">采用类似的方法，逐一对需要hook的Binder进行处理即可。但具体的Binder还需要具体分析，比如IPackageManager除了在sCache中有一份根缓存之外，在ContextImpl和ActivityThread中还各有一份不同形式的缓存（mPackageManager和sPackageManager），间接的持有IPackageManager的Binder缓存，所以也要一起替换或者清掉缓存。否则，app通过Context或ActivityThread中的API访问PacakgeManager时可能使用的依然是原来的Binder。</span></p><blockquote><h2 style="margin-top: 15px;"><strong><span style="font-family: 宋体; color: rgb(51, 51, 51); font-size: 18px;">Java Method Hook</span></strong></h2></blockquote><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">目前关于Java methodhook的研究已经比较多，其中比较著名的当属Rovo大神的</span><a style="font-family: 宋体; color: rgb(51, 51, 51); text-decoration: underline;"><span style=";font-family:宋体;color:#333333">Xposed框架</span></a><span style=";font-family:宋体;color:#333333">。</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">基本原理：修改Java Mehod在虚拟机中的定义，将其标识为native方法，修改其方法指针nativeFunc，使其指向自己定义的一个native函数。这样对该方法的调用都会跳转到自定义的一个分发函数中，通过分发函数作为钩子，即可注册任意的函数作为替换。</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">利用Xposed框架注入到其它应用进程的前提是获取root权限。而在安全沙箱中，因为app是运行在沙箱自己创建的进程，所以沙箱不需要root即可修改虚拟机中的方法定义，从而hook掉app调用的java方法。</span></p><blockquote><h2 style="margin-top: 15px;"><strong><span style="font-family: 宋体; color: rgb(51, 51, 51); font-size: 18px;">Native Hook</span></strong></h2></blockquote><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">Native Hook有GOT Hook、InlineHook和ptrace等方法，比较著名的框架是</span><a style="font-family: 宋体; color: rgb(51, 51, 51); text-decoration: underline;"><span style=";font-family:宋体;color:#333333">Cydia Substrate</span></a><span style=";font-family:宋体;color:#333333">。</span></p><blockquote><h3 style="margin-top: 15px;"><strong><span style="font-family: 宋体; color: rgb(51, 51, 51); font-size: 18px;">GOT Hook</span></strong></h3></blockquote><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">在ELF文件中，GOT (Global Offset Table) section用于存放静态链接阶段无法解析的全局变量、外部函数地址等。在Android中，当so被加载(dlopen)之后，dynamiclinker (/system/bin/linker) 会解析它的GOT表项里的外部函数地址并填好。通过找到外部函数对应的GOT表项，修改其内容使其指向自定义函数，即可实现hook so外部函数调用的目的。</span></p><blockquote><h3 style="margin-top: 15px;"><strong><span style="font-family: 宋体; color: rgb(51, 51, 51); font-size: 18px;">Inline Hook</span></strong></h3></blockquote><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">显然GOT Hook只能hook外部函数，对于so内部的函数调用则无能为力，这时就需要通过inline hook的方法，即修改so内部函数入口处的指令，使其跳转到自定义函数，然后（如有必要）跳回原来的函数继续执行。在执行inlinehook之前需先找到内部函数的地址，对于so导出的函数符号，通过dlsym()即可获取该符号地址。</span></p><blockquote><h3 style="margin-top: 15px;"><strong><span style="font-family: 宋体; color: rgb(51, 51, 51); font-size: 18px;">ptrace</span></strong></h3></blockquote><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">如果app以汇编指令的方式直接执行系统调用，以上方法将无法进行拦截，这种情况可以借助ptrace来解决。ptrace是linux内核提供的一个系统调用，利用ptrace可以观察和控制另一个进程的执行，跟踪其所有的系统调用。沙箱中运行的app所在进程由沙箱控制，所以沙箱主体可以用ptraceattach到app进程，实现系统调用监控和拦截的目的。</span></p><blockquote><h2 style="margin-top: 15px;"><strong><span style="font-family: 宋体; color: rgb(51, 51, 51); font-size: 18px;">IO重定向</span></strong></h2></blockquote><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">利用前面提到的这些Hook方法即可实现IO重定向的目的，使app的本地读写都被重定向到沙箱为其创建的data目录下。这里需要hook的文件读写和访问方法比如有mkdir、open、access、rename等。除了这些IO系统调用之外，沙箱还需要修改应用和组件的data路径相关信息，比如ApplicationInfo的dataDir和LoadedApk的mDataDir、mDataDirFile等。</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333"><br></span></p><h2 style="margin-top: 15px;"><strong><span style="font-family: 宋体; color: rgb(51, 51, 51); font-size: 20px;">总结</span></strong></h2><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">沙箱的技术原理简单概括就是：反射、代理、各种Hook。对照着android框架源码搞清楚android apk的安装、加载和运行过程，弄明白Android组件的创建、运行和生命周期管理，好像也就那么回事。但是所有这些过程如果没有对Java虚拟机和Linux可执行文件的深入学习，理解起来可能就会有偏差，开发过程中也会踩不少坑。所以，所以就写到这里了，赶紧回去补习功课。</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333">&nbsp;</span></p><p style="margin-top: 15px; white-space: normal;"><span style="color: rgb(0, 176, 240); font-family: 宋体; font-size: 14px; white-space: pre-wrap;">✎ 如果您想了解更多关于移动终端安全的内容，请收听我们的</span><strong style="color: rgb(0, 176, 240); font-family: 宋体; font-size: 14px; white-space: pre-wrap; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">微信公众号(终端安全那些事儿)</strong><span style="color: rgb(0, 176, 240); font-family: 宋体; font-size: 14px; white-space: pre-wrap;">，我们将定期为您分享；</span><br></p><p style="white-space: normal; line-height: 25.6px; color: rgb(62, 62, 62); font-family: Verdana, 宋体, sans-serif; min-height: 1em; border: 0px; list-style: none; word-break: normal; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="color: rgb(0, 176, 240); font-family: 宋体; line-height: 22.5px; word-break: normal; font-size: 14px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">✎ 如果您对移动终端安全有什么问题和建议，关注我们的公众账号后直接回复消息联系我们。</span></p><p style="white-space: normal; line-height: 25.6px; color: rgb(62, 62, 62); font-family: Verdana, 宋体, sans-serif; min-height: 1em; border: 0px; list-style: none; word-break: normal; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="color: rgb(0, 176, 240); font-family: 宋体; line-height: 22.5px; word-break: normal; font-size: 14px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br></span></p><p style="margin-bottom: 10px; white-space: normal; line-height: 25.6px; text-align: center;"><span style="max-width: 100%; color: rgb(0, 176, 240); box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 12px; box-sizing: border-box !important; word-wrap: break-word !important;">终端安全那些事儿&nbsp;</span></strong></span><span style="max-width: 100%; color: rgb(0, 176, 240); font-size: 12px; box-sizing: border-box !important; word-wrap: break-word !important;">汇聚最优影响力的安全技术文章</span></p><p style="white-space: normal; line-height: 25.6px; text-align: center;"><img src="/zhongduananquan/images/a1c02648331a7d53620c4031cfba35723042669a.png" style="width: 138px !important; height: 137px !important;"></p><p style="white-space: normal; line-height: 25.6px; text-align: center;"><span style="color: rgb(0, 176, 240); font-size: 11px;">▲长按二维码可识别关注</span></p><p style="margin-top: 15px;"><span style=";font-family:宋体;color:#333333"></span><br></p><p><br></p>
{% endraw  %}

