---
title: 多线程与Android虚拟机，那些设计缺陷带来的坑
author: 黄伟旭
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1496017539&src=3&ver=1&signature=1Hp-JGX68UwholXKdYsHgKVkk83cY4LBMd982dPwQuCaDb-l1yYuTEJ56htJ5OGTqWkv2fNke-En-Z0kHYd18DpmsOs45UzTAhXLzz3ooL*2NgzkuppHgD6vSCCLr1-sbWh0h9L--iWQo7WkBz8Z4baoU7SKTZT6DboAxOGasBI=
date: '2017-05-26 00:00:00 +0000'

---

{% raw  %}
<p style="white-space: normal; text-size-adjust: auto;"><strong style="font-size: 22px;">一 /&nbsp;问题背景</strong></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">KingRoot在最近几个版本中出现crash率飙升的问题，峰值居然高达7%，要知道5.0正式版的时候crash率才0.8%，我们先看看上报问题列表：</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/e38879bf92484a71c04a0fa6b344d949b764dd38.png" style="width: 770px !important; height: 325.701px !important; visibility: visible !important;"></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">这满屏的段错误是几个意思？随便打开几个看看，发现native层的堆栈都是一样一样的，堆栈调用如下：</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/3bd0415d6ed5ec74af8bec8e72bdbec615f6a60b.png" style="width: 770px !important; height: 469.096px !important; visibility: visible !important;"></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">光这点堆栈信息肯定分析不下去，于是想到以前做Rom时解决native crash的好朋友<strong>addr2line</strong>，但是addr2line需要有Rom的源码， 这意味着我们需要AOSP的机型。<br></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">万幸我们找到Nexus 5的crash log，用源码addr2line反一下看看，还原下调用栈是这样滴：</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/8ea20d2aff3ad5b52baff367576678ac4285a6ef.png" style="width: 770px !important; height: 75.7547px !important;"></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">大概意思是虚拟机去查找一个class的时候，发现这个class存在异常，本来是要抛个异常让Java去处理，然而在抛异常过程中有字符串转换的过程：</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/1f5319aa305f6f11ee2bb0152f86978a908f206a.png" style="width: 770px !important; height: 352.124px !important;"></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">在判断时，由于传入的描述符字符串数组是空值，导致了段错误crash，回下传入参数的地方，最终统一在这里：</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/cc915269b815f47fde9d0225eaaf605d1d550702.png" style="width: 770px !important; height: 505.582px !important;"></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">两处调用的地方都是使用了<strong>ClassObject-&gt;descriptor</strong>变量，即ClassObject内部的成员变量为空导致了问题，ClassObject内部成员被清空了<br></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">我们遍查代码上下文，发现虚拟机中只有一处会对ClassObject内容会主动清空&nbsp;：&nbsp;<br></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/41f5751cb9b5742137ca58d9958e4ef773a3ad1d.png" style="width: 770px !important; height: 571.217px !important;"><br></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">从注释可知，这个函数会清除ClassObject中的任何内容但<strong>不会清除ClassObject本身</strong>，而将ClassObject本身的清除工作交给GC<br></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">总结起来我们的问题：</p><ol class="list-paddingleft-2" style="width: 528.188px; white-space: normal; text-size-adjust: auto;"><li><p style="margin-top: 5px;">加载类过程中发生的异常</p></li><li><p style="margin-top: 5px;">加载的ClassObject状态为Error</p></li><li><p style="margin-top: 5px;">加载的ClassObject已经调用dvmFreeClassInnards清除了内部数据</p></li></ol><p style="white-space: normal; text-size-adjust: auto;"><br></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><strong><span style="font-size: 22px;">二 / Dalvik虚拟机加载类过程&nbsp;</span></strong></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">因为这里需要Dalivk虚拟机加载class的知识点，所以我们简单的深入浅出下虚拟机的加载原理<br></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/a6bcdc1be2fd1c91561a2a6cefcd270771e94f0c.png" style="width: 770px !important; height: 416.833px !important;"><br></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">dex文件加载重点：</p><ol class="list-paddingleft-2" style="width: 528.188px; white-space: normal; text-size-adjust: auto;"><li><p style="margin-top: 5px;">dex文件对比class文件的特点就是多个class文件合并放到同一个dex文件中</p></li><li><p style="margin-top: 5px;">dex文件通过mmap映射到内存，并通过创建<strong>DexFIle</strong>数据结构进行管理</p></li><li><p style="margin-top: 5px;">类的查找似通过Class名称去找，因此会在DexFile中创建<strong>pClassLookup</strong>哈希表以加快查找</p></li><li><p style="margin-top: 5px;">pClassLookup里面存着表示各个类信息在DexFile文件中的索引信息</p></li></ol><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/3fb68f35c9360dcc0f8b876894ca5d89eeb7658d.png" style="width: 770px !important; height: 339.943px !important;"></p><p style="white-space: normal; text-size-adjust: auto;"><br></p><p style="white-space: normal; text-size-adjust: auto;">关于ClassObject的重点：</p><ol class="list-paddingleft-2" style="width: 528.188px; white-space: normal; text-size-adjust: auto;"><li><p style="margin-top: 5px;">dalvik虚拟机执行时会从dex文件读取类信息，创建ClassObject并保存读取到的类信息</p></li><li><p style="margin-top: 5px;">通过super指针递归加载超类</p></li><li><p style="margin-top: 5px;">创建的ClassObject会被缓存到<strong>gDvm.loadedClasses</strong>哈希表</p></li></ol><p style="white-space: normal; text-size-adjust: auto;"><br></p><p style="white-space: normal; text-size-adjust: auto;">重点来了，那么一个类是怎么从dex文件中加载到内存去执行呢？</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/01e2bd472d6a0c818b2d19908481a1b71f51bc7d.png" style="width: 770px !important; height: 343.466px !important;"><br></p><p style="white-space: normal; text-size-adjust: auto;"><br></p><p style="white-space: normal; text-size-adjust: auto;">ClassLoader通过一系列调用后，在native层调用findClassNoInit在dex文件中查找目标类具体的类查找实现都在findClassNoInit实现findClassNoInit在加载类过程中是最关键的步骤。</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">我们接着看看findClassNoInit流程：</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/3459393b17c57fc7c2f994efbe516235f86a987c.png" style="width: 704px !important; height: 1266px !important;"></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">关键点在于采用递归查找父类的方式将一个类的完整信息加载，如果过程发现任何类找不到（自己或者祖先类），就会清除类数据并标记失败，然后向Java层抛出一个异常。<br></p><p style="white-space: normal; text-size-adjust: auto;"><br></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><strong><span style="font-size: 22px;">三 /&nbsp;问题分析&nbsp;</span></strong></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">关于类的加载过程我们就分析到此，回到我们的问题：什么情况下会导致查找一个状态为Error且内容被清空的ClassObject？</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">再看看相关的logcat，在发生异常之前经常出现一个log：</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/fd2d4a9eb79b8094689322a4b5db03a804409291.png" style="width: 770px !important; height: 110.473px !important;"></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">这里的KCheckServiceJob继承了Android 5.0之后新增的一个类<strong>JobService</strong>，所以Android Kitkat机器每次尝试去实例化KCheckServiceJob时都会由于找不到父类而抛出一个ClassNotFoundException，检查下这个异常的代码：</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/9af36a20ff9458730309346135b7b115ddccb313.png" style="width: 770px !important; height: 658.633px !important;"></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">在多线程环境中尝试将KCheckJobService这个组件的名字用Class.forName转成Class对象</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">结合我们刚刚描述的类加载流程，当递归加载到KCheckJobService的父类时，由于找不到父类（Android Kitkat以下版本SDK不包含这个类）会导致KCheckJobService的加载过程中止，清除掉这个类的内容并向Java层抛出一个ClassNotFound Exception。</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">由于虚拟机加载类失败后并不会直接将类对象清除，而是留给GC去处理。如果多线程下有没有可能存在数据污染的问题？</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">我们来做个试验，demo代码如下:</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/9e33aede911b7825b0f9839c39a81d5ff157d70b.png" style="width: 770px !important; height: 753.203px !important;"></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">代码很简单，开启多个线程去异步Class.forName加载一个必定失败的类（Android4.4以下父类不存在），果然，相同的异常再次出现。</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">经过一番在AOSP虚拟机中添加log，测试demo重现，分析...再添加log，重现，分析...最后的原因终于大白天下：</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><img src="/zhongduananquan/images/134315cbd75e74f2fa4707f4534b237ae2a49152.png" style="width: 770px !important; height: 580.41px !important;"></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">当线程A发现加载的类存在问题（例如加载父类不存在），虽然会清除掉类ClassObject内部的成员并标记为错误，但是不会清除ClassObject本身。如果<strong>线程B由于已经持有了这个ClassObject，访问内部成员就会由于内部空指针导致段错误，典型的多线程数据污染问题。</strong><br></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><strong><br></strong></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;"><strong><span style="font-size: 22px;">四 / 总结&nbsp;</span></strong></p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">多线程竞争导致数据污染问题也是比较常见的问题，在这里由于dalvik虚拟机本身对数据同步存在缺陷，导致了这个比较隐蔽的native crash，后续修改为同一线程同步调用Class.forName即修复了此问题。</p><p style="margin-top: 15px; white-space: normal; text-size-adjust: auto;">引申到我们平时开发中对于多线程中数据同步的重要性，多线程环境下缺乏保护的数据访问常常会导致各种隐蔽难以查找的问题。</p><p style="white-space: normal; text-size-adjust: auto;"><br></p><p style="margin-top: 15px; white-space: normal;"><span style="color: rgb(0, 176, 240); font-family: 宋体; font-size: 14px; white-space: pre-wrap;">✎ 如果您想了解更多关于移动终端安全的内容，请收听我们的</span><strong style="color: rgb(0, 176, 240); font-family: 宋体; font-size: 14px; white-space: pre-wrap; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">微信公众号(终端安全那些事儿)</strong><span style="color: rgb(0, 176, 240); font-family: 宋体; font-size: 14px; white-space: pre-wrap;">，我们将定期为您分享；</span><br></p><p style="white-space: normal; line-height: 25.6px; color: rgb(62, 62, 62); font-family: Verdana, 宋体, sans-serif; min-height: 1em; border-width: 0px; border-style: initial; border-color: initial; list-style: none; word-break: normal; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="color: rgb(0, 176, 240); font-family: 宋体; line-height: 22.5px; word-break: normal; font-size: 14px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">✎ 如果您对移动终端安全有什么问题和建议，关注我们的公众账号后直接回复消息联系我们。</span></p><p style="white-space: normal; line-height: 25.6px; color: rgb(62, 62, 62); font-family: Verdana, 宋体, sans-serif; min-height: 1em; border-width: 0px; border-style: initial; border-color: initial; list-style: none; word-break: normal; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="color: rgb(0, 176, 240); font-family: 宋体; line-height: 22.5px; word-break: normal; font-size: 14px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br></span></p><p style="margin-bottom: 10px; white-space: normal; line-height: 25.6px; text-align: center;"><span style="max-width: 100%; color: rgb(0, 176, 240); box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 12px; box-sizing: border-box !important; word-wrap: break-word !important;">终端安全那些事儿&nbsp;</span></strong></span><span style="max-width: 100%; color: rgb(0, 176, 240); font-size: 12px; box-sizing: border-box !important; word-wrap: break-word !important;">汇聚最优影响力的安全技术文章</span></p><p style="white-space: normal; line-height: 25.6px; text-align: center;"><img src="/zhongduananquan/images/a1c02648331a7d53620c4031cfba35723042669a.png" style="width: 138px !important; height: 137px !important;"></p><p style="white-space: normal; line-height: 25.6px; text-align: center;"><span style="color: rgb(0, 176, 240); font-size: 11px;">▲长按二维码可识别关注</span></p><p><br></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1496017539&src=3&ver=1&signature=1Hp-JGX68UwholXKdYsHgKVkk83cY4LBMd982dPwQuCaDb-l1yYuTEJ56htJ5OGTqWkv2fNke-En-Z0kHYd18DpmsOs45UzTAhXLzz3ooL*2NgzkuppHgD6vSCCLr1-sbWh0h9L--iWQo7WkBz8Z4baoU7SKTZT6DboAxOGasBI=">微信地址</a>
{% endraw  %}

