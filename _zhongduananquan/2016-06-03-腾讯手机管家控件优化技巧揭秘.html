---
title: 腾讯手机管家控件优化技巧揭秘
author: 陈炎福
date: '2016-06-03 00:00:00 +0000'

---

{% raw  %}
<h1 style="margin-top: 5px;"><strong><span style="font-size: 24px;">一 /&nbsp;前言</span></strong></h1><p style="margin-top: 15px;">在进鹅厂之前，楼主去某公司面试，面试官想听Android View绘制相关的内容。乍听窃喜，这还不简单吗？重点来了，面试官毫无表情地说：“不要跟我背源代码，我自己会看源码，不要跟我讲测量，布局，绘制三个过程……这些人人都讲，我都听到吐了，讲点新的。”</p><p style="margin-top: 15px;">于是乎，我讲了双重缓冲和三重缓存技术。那么，今天在这里，也是要讲双重缓冲和三重缓存技术吗？估计大家也听得烦了，那就再讲点新的，常规的UI优化已经有很多人讲过了，那就挑个冷门一点的<a name="_GoBack"></a>——自定义View的性能优化。</p><p><br></p><h2 style="margin-top: 15px;"><strong><span style="font-size: 20px;">60fps和16ms</span></strong></h2><p style="margin-top: 15px;">12fps大概类似手动快速翻动书籍的帧率，这明显是可以感知到卡顿的。24fps使得人眼感知的是连续线性的运动，这其实是归功于人眼的视觉暂留（Persistence of vision）效果。</p><p style="margin-top: 15px;">24fps是电影胶圈通常使用的帧率。但是低于30fps是无法顺畅表现绚丽的画面内容的，此时就需要用到60fps来达到想要的效果，人眼与大脑之间的协作无法感知超过60fps的画面更新。因此我们以能否达到60fps作为App的性能的衡量标准。</p><p style="margin-top: 15px;">开发app的性能目标就是保持60fps，这意味着每一帧你只有16ms=1000/60的时间来处理所有的任务。为了能够使得App流畅，我们需要在每一帧16ms以内处理完所有的CPU与GPU计算，绘制，渲染等等操作。</p><p><br></p><h2 style="margin-top: 15px;"><span style="font-size: 20px;"><strong>渲染性能问题</strong></span></h2><p style="margin-top: 15px;">为了提高UI的流畅度，Google陆续推出了双重缓冲和三重缓存技术，关于这两个技术，网上已经有很详细的介绍，这里不再赘述，附上传送门：</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;"><span style="color: rgb(13, 153, 252);">http://article.yeeyan.org/view/37503/304664</span></p></li><li><p style="margin-top: 15px;"><span style="color: rgb(13, 153, 252);">http://djt.qq.com/article/view/987</span></p></li></ul><p><br></p><p style="margin-top: 5px;">大多数用户感知到的卡顿等性能问题的主要根源都是因为渲染性能。在日常开发的过程中，设计往往会追求各种酷炫的效果，他们希望APP能够有更多复杂的动画动画、精致的图片来实现流畅的用户体验，但是Android系统很可能无法及时完成那些复杂的界面渲染操作。</p><p style="margin-top: 15px;">系统每隔16ms就会发出VSYNC信号，触发对UI的渲染操作。如果每次渲染成功，这样很好，能够达到流畅的画面所需要的60fps。</p><p style="text-align: center; margin-top: 15px;"><img src="/zhongduananquan/images/dfde26b9d26781ceb7107401acdd5acc2a18cbff.png" style="width: 485px !important; height: 214px !important;"><br></p><p style="margin-top: 15px;">如果你的某个操作耗时超过了16ms，例如花费了24ms，系统在得到VSYNC信号的时候就无法进行正常的渲染。这样就发生了丢帧现象，用户在32ms内看到的会是同一帧画面。</p><p style="text-align: center; margin-top: 15px;"><img src="/zhongduananquan/images/e0029657aeb662953192d9ae85792b363a3a55a2.png" style="width: 482px !important; height: 341px !important;"><br></p><p style="margin-top: 15px;">&nbsp;</p><h2 style="white-space: normal; margin-top: 15px;"><strong><span style="font-size: 24px;">二 / 自定义View优化</span></strong></h2><p style="margin-top: 15px;">Android系统有提供超过70多种标准的View，例如TextView，ImageView，Button等等。在某些时候，这些标准的View无法满足我们的需要，那么就需要我们自己来实现一个View。</p><p style="margin-top: 15px;">通常来说，针对自定义的View，我们可能会犯下面的三个错误：</p><p style="margin-top: 15px;"><strong>1. 多次无效调用OnDraw()。</strong></p><p style="margin-top: 15px;">调用View.invalidate()会触发View的重绘，但是必须遵循两个原则。第一个是仅仅在View的内容发生改变的时候才去触发invalidate()方法；第二个是尽量使用Canvas.ClipRect()等方法来提高绘制的性能。</p><p style="margin-top: 15px;"><strong>2. 频繁重绘。</strong></p><p style="margin-top: 15px;">我们需要尽量避免重绘。</p><p style="margin-top: 15px;"><strong>3. 浪费CPU时间片。</strong></p><p style="margin-top: 15px;">不在屏幕上的元素，可以使用Canvas.quickReject()把他们给剔除，避免浪费CPU资源。另外尽量使用GPU来进行UI的渲染，这样能够极大的提高程序的整体表现性能。</p><p><br></p><p style="margin-top: 15px;">除了上述容易犯的问题，在做自定义View优化的时候开可以从下面的几方面入手：</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;">优化布局，避免过度绘制</p></li><li><p style="margin-top: 15px;">检测耗时操作，避免无法进行正常渲染，导致丢帧</p></li><li><p style="margin-top: 15px;">优化内存，避免内存抖动</p></li></ul><p style="margin-top: 15px;">下面会从上述几方面，一一跟大家分享一下。</p><p><br></p><h2 style="margin-top: 15px;"><span style="font-size: 20px;"><strong>二 / 一 布局与过度绘制</strong></span></h2><blockquote><p style="margin-top: 15px;"><strong>过度绘制(Overdraw)</strong></p><p style="margin-top: 15px;">描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。</p></blockquote><p style="margin-top: 15px;">个人切身体会，当设计上追求更加华丽的视觉效果的时候，我们就容易陷入采用越来越多的层叠组件来实现这种视觉效果的怪圈。其实这样会导致很大的性能问题，布局的层次越多，渲染耗时越长，里面的每个元素的变化都很容易导致过度绘制的问题。</p><p style="margin-top: 15px;">在多层次的UI结构中，由自定义View引发过度绘制的case主要有以下几点：</p><p style="margin-top: 15px;"><strong>1. 自定义View的大小、位置不停在发生变化。</strong></p><p style="margin-top: 15px;">View的大小、位置发生变化之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作；如果是修改View的位置则会触发HierarchView重新计算其他View的位置。如果布局很复杂，这就会很容易导致严重的性能问题。</p><p style="margin-top: 15px;"><strong>2. 绘制了不可见的组件。</strong></p><p style="margin-top: 15px;"><strong>3. 每层都设置了background等等。</strong></p><p><br></p><p style="margin-top: 15px;">避免过度绘制主要有以下几招：</p><p style="margin-top: 15px;"><strong>1. 自定义View里面，首先要控制好帧频。</strong></p><p style="margin-top: 15px;">有些同学会说，我的这个自定义动画效率非常高，可以到120fps。这么高的fps确实值得吹嘘一番，不过上面已经说过了，人眼无法感知超过60fps的画面更新，所以我们追求60fps是个不错的选择，可以减轻CPU负荷，最重要的是避免过度绘制。</p><p style="margin-top: 15px;">通常我们实现自定义动画的方式有两个</p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/c3ec74a54494440b35adb5e1f2da774d6ae602ce.png" style="width: 770px !important; height: 146.799px !important;"><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;">SurfaceView版：</p></li></ul><p style="margin-top: 15px;"><img src="/zhongduananquan/images/5a074f2c5ef9a691389b51ac061d76e148501e78.png" style="width: 770px !important; height: 530.414px !important;"><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;">普通View版：</p></li></ul><p style="margin-top: 15px;"><img src="/zhongduananquan/images/f1028feb656ec99ebbee197e8ef32c7edb9b4b8b.png" style="width: 770px !important; height: 782.464px !important;"><br></p><p style="margin-top: 15px;"><strong>2. 合理选择控件容器。</strong></p><p style="margin-top: 15px;">自定义的View也会有依附的父View，因此也会面临控件容器的选择问题。在表达界面的时候，作为一个有前瞻性的开发，要根据实际情况来选择合适容器控件，在保证性能的同时，尽量避免Overdraw。</p><p style="margin-top: 15px;">避免多层LinearLayout嵌套来实现占位的目的，推荐直接使用RelativeLayout。在绘制效率和计算效率上，RelativeLayout是高于LinearLayout的，这种优势，布局深度越深，优势越明显。</p><p style="margin-top: 15px;"><strong>3. 去掉window的默认背景和其他不必要的背景。</strong></p><p style="margin-top: 15px;">当我们使用了Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局时又添加了一张背景图或者设置背景色，那么DecorView的background此时对我们来说是无用的，但是它会产生一次Overdraw，带来绘制性能损耗。</p><p style="margin-top: 15px;">去掉window的背景可以在onCreate()中setContentView()之后调用：</p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/8b6d300519937afb66796b773e5401ae9cad15c1.png" style="width: 770px !important; height: 76.1691px !important;"><br></p><p style="margin-top: 15px;">或者在theme中添加：</p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/fab3e1cb420359e323f06a0986291c5aca884328.png" style="width: 770px !important; height: 78.9388px !important;"><br></p><p style="margin-top: 15px;">另外，有时候为了方便会先给Layout设置一个整体的背景，再给子View设置背景，这里也会造成重叠，如果子View宽度mach_parent，可以看到完全覆盖了Layout的一部分，这里就可以考虑下这个背景能不能分段设置在子View上，而不是图方便直接设置在根View上。</p><p style="margin-top: 15px;"><strong>4. ClipRect &amp; QuickReject</strong></p><p style="margin-top: 15px;">自定义View绘制时避免重叠部分的绘制，可以使用：</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;">canvas.clipRect();</p></li></ul><p style="margin-top: 15px;">裁剪canvas，这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect()方法还可以帮助节约CPU与GPU资源，在clipRect()区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;">canvas.quickReject();</p></li></ul><p style="margin-top: 15px;">判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。</p><p style="margin-top: 15px;"><strong>5. 避免过度设计。</strong></p><p style="margin-top: 15px;">Overdraw会给APP带来不好的体验，Overdraw产生的原因无外乎：复杂的Layout层级，重叠的View，重叠的背景。开发人员无节制的View堆砌，究其根本很可能是产品无节制的需求设计。这就需要产品设计也要有一个权衡，在复杂的业务逻辑与简单易用的界面展现中做一个平衡，而不是一味的追求华丽的设计，酷炫的动画。</p><p><br></p><p style="margin-top: 15px;">一个好的开发，在做完UI的开发工作时，都会关注一下UI的流畅度以及性能问题，特别需要关注的是过度绘制问题，在此借助<strong>工具</strong>来定位、优化过度绘制问题：</p><p style="margin-top: 15px;"><strong>1. 开发者模式提供的选项</strong></p><p style="margin-top: 15px;">Android系统提供了测量Overdraw的选项，在开发者选项－调试GPU过度绘制（Show GPU Overdraw），打开选项就可以看到当前页面Overdraw的状态。</p><p style="text-align: center; margin-top: 15px;">&nbsp;<img src="/zhongduananquan/images/1d383afc945823cee2c3f4128d24f7c12c3749b2.jpeg" style="width: 382px !important; height: 424px !important;"><br></p><p><br></p><p style="margin-top: 15px;"><strong>2. Hierarchy Viewer</strong></p><p style="margin-top: 15px;">HierarchyViewer能够可视化的角度直观地查看Activity的布局，各个View的属性、measure、layout、draw的时间，帮助我们优化布局设计。如果耗时较多会用红色标记，否则显示绿色。作为我们优化程序的工具之一，它是Android自带的非常有用的工具，可以帮助我们更好地检视和设计用户界面(UI)，绝对是UI检视的利器。</p><p style="margin-top: 15px;"><strong>3. Lint</strong></p><p style="margin-top: 15px;">Lint是Android提供的一个静态扫描应用源码并找出其中的潜在问题的一个强大工具。</p><p style="text-align: center; margin-top: 15px;"><img src="/zhongduananquan/images/961c6245f538643e474bc6191a966b5ef47dee5f.jpeg" style="width: 770px !important; height: 477.788px !important;"><br></p><p style="margin-top: 15px;">例如，如果我们在onDraw方法里面执行了new对象的操作，Lint就会提示我们这里有性能问题，并提出对应的建议方案。</p><p style="margin-top: 15px;">使用Eclipse可以按下图操作：</p><p style="text-align: center; margin-top: 15px;"><img src="/zhongduananquan/images/59991e8bbba2f1bd25e9cdf4240c1af2676670dc.png" style="width: 361px !important; height: 351px !important;"><br></p><p style="margin-top: 15px;">如果是使用Android Studio的同学，我们可以点击工具栏的Analysis -&gt; Inspect Code，触发Lint开始工作，并把结果输出到底部的工具栏，我们可以逐个查看原因并根据指示做相应的优化修改。</p><p><br></p><h2 style="white-space: normal; margin-top: 15px;"><span style="font-size: 20px;"><strong>二 / 二&nbsp;</strong></span><span style="font-size: 20px;"><strong>减少耗时操作</strong></span></h2><p style="margin-top: 15px;">为了保证16ms内完整绘制工作，我们必须让onDraw()的工作更加纯粹，不能在绘制的方法里面执行任何的耗时操作。常见的耗时操作有：</p><p style="margin-top: 15px;"><strong>1. 网络操作。</strong>发送网络请求、创建Socket连接，下载图片、文件等（Android3.0+&nbsp;系统会在运行时直接报异常）。</p><p style="margin-top: 15px;"><strong>2.</strong> <strong>读写SD卡文件，读写数据库，数据库查询，从SD卡加载图片等。</strong></p><p style="margin-top: 15px;"><strong>3. 增加统计点、上报。</strong></p><p style="margin-top: 15px;"><strong>4. 进行大量的、重复的运算。</strong></p><p style="margin-top: 15px;">绘制需要的数据只能在onDraw()方法之外的地方初始化好，涉及网络的操作、文件读写的操作必须用异步线程去完成，不能阻塞UI线程。</p><p style="margin-top: 15px;">对于自定义View中，实时计算元素的大小、位置的操作往往是无可避免的，这种情况，我们建议能够最大限度的利用上一次的运算结果，减少运算次数。</p><p style="margin-top: 15px;">判断方法是否耗时，我们通常会借助TraceView工具来分析各方法的耗时情况，具体使用方法就不再赘述了。奉上传送门地址：<span style="color: rgb(13, 153, 252);">http://www.oschina.net/news/56500/traceview-android</span></p><p style="margin-top: 15px;">除了TraveView工具，我们还有一个更加便捷的方式，具体操作步骤如下：</p><p style="margin-top: 15px;">在DDMS视图下，选中需要监测的进程。</p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/8df56154eeb3330f2fa1731814520491f742cba7.png" style="width: 770px !important; height: 307.446px !important;"><br></p><p style="margin-top: 15px;">点击图标<img src="/zhongduananquan/images/cbd1c9136da4320c3912708ed87c8ba2598b489b.png" style="width: 31px !important; height: 26px !important;">(Update Threads)，然后点击<img src="/zhongduananquan/images/26da6c9f7b935929c187849a6f004eff8947cd0c.png" style="width: 24px !important; height: 21px !important;">(Start Method Profiling)，接着点击<img src="/zhongduananquan/images/16b5350427d48d301aebf6ddd93c02f1f6a2932d.png" style="width: 26px !important; height: 23px !important;">(Stop Method Profiling)</p><p style="margin-top: 15px;">最后在弹出的窗口中，我们就可以得到导入TraceView生成的数据文件一样的界面了，从而可以开始分析方法的耗时情况了。</p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/978a87ab884358d04be0d4f573c4fc6c36c93d22.png" style="width: 770px !important; height: 278.363px !important;"><br></p><p><br></p><h2 style="white-space: normal; margin-top: 15px;"><span style="font-size: 20px;"><strong>二 / 三 内存优化</strong></span></h2><p style="margin-top: 15px;">在Android系统，当我们感觉手机变卡的时候，我们通常就会发射小火箭，或者依靠第三方应用不停的清理手机内存。</p><p style="text-align: center; margin-top: 15px;"><span style="font-size: 18px; text-decoration: none;">/ 手机变卡&nbsp;= 内存不足？/</span></p><p style="margin-top: 15px;">其实这是大多数人存在的误区。实际上，<strong>手机卡不卡和内存大小没有关系，直接影响手机流畅度的是CPU，只有当CPU超负荷运行时，手机才会变卡。</strong>（当然，大部分CPU超负荷运行的时候，内存也满载，这是引起误解的原因，但有时即使你清理了内存，手机卡shit依旧）。</p><p style="margin-top: 15px;">到这里或许会有人问：“照你所说，内存就跟UI流程度没有关系咯？”</p><p style="margin-top: 15px;">内存跟UI流畅度显然是有关系的，属于<strong>间接</strong>的关系。</p><h3 style="margin-top: 15px;"><span style="font-size: 18px;"><strong>1. GC与UI流程度的关系</strong></span></h3><p style="margin-top: 15px;">我们都知道应该避免在onDraw()方法里面执行导致内存分配的操作，下面讲解下为何需要这样做。</p><p style="margin-top: 15px;">首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。</p><p style="margin-top: 15px;">GC是由谁来做的呢？CPU。最重要的是，当进行GC时，其他所有线程都会被暂停，虽然系统已经尽力让GC的时间变短，但当大量的GC操作发生时，依然会影响到界面流畅度。</p><p style="margin-top: 15px;">众所周知，与C/C++需要通过手动编码来申请以及释放内存有所不同，Android里面是一个三级Generation的内存模型，最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后到Permanent Generation区域。</p><p style="text-align: center; margin-top: 15px;"><img src="/zhongduananquan/images/a067fe731774daeada41484c2a031e1d6d33c06d.png" style="width: 428px !important; height: 322px !important;"><br></p><p style="margin-top: 15px;">每一个级别的内存区域都有固定的大小，此后不断有新的对象被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阀值时，会触发GC的操作，以便腾出空间来存放其他新的对象。</p><p style="text-align: center; margin-top: 15px;"><img src="/zhongduananquan/images/ba21d27b1a33b1a4bdb061eaf9d739af81148619.png" style="width: 498px !important; height: 378px !important;"><br></p><p style="margin-top: 15px;">执行GC操作的时候，所有线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行。</p><p style="text-align: center; margin-top: 15px;"><img src="/zhongduananquan/images/6b2880aa0b6fd27c74f80d78920abe4ca00c39b2.png" style="width: 426px !important; height: 261px !important;"><br></p><p style="margin-top: 15px;">GC所占用的时间和它是哪一个Generation也有关系。Young Generation的每次GC操作时间是最短的，Old Generation其次，Permanent Generation最长。执行时间的长短也和当前Generation中的对象数量有关。</p><p style="text-align: center; margin-top: 15px;"><img src="/zhongduananquan/images/66df98b0cbc0e8d4857ebbb70afa245a680a6b56.png" style="width: 424px !important; height: 318px !important;"><br></p><p style="margin-top: 15px;">在2.3之前GC操作是同步的，也就是系统正在进行GC，那么应用程序就只能阻塞住等待GC结束。而自2.3之后，GC操作改成了并发的方式进行，就是说GC的过程中不会影响到应用程序的正常运行，但是在GC操作的开始和结束的时候会短暂阻塞一段时间。</p><p style="margin-top: 15px;">导致GC频繁执行有两个原因：</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;">内存抖动（Memory Churn）</p></li></ul><p style="margin-top: 15px;">内存抖动是因为大量的对象被创建又在短时间内马上被释放，比如在for循环中创建许多临时对象。</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;">瞬间产生大量的对象，严重占用Young Generation的内存区域。</p></li></ul><p style="margin-top: 15px;">当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到fps，并使得用户感知到性能问题。</p><p><br></p><p style="margin-top: 15px;">回到上面的讨论，为什么要避免在onDraw()方法里面执行导致内存分配的操作？</p><p style="margin-top: 15px;">因为设备有一定的刷新频率，导致View的onDraw()方法会被频繁的调用，如果onDraw()方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。如果在onDraw()里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，进一步引发更加严重性能问题。</p><p style="margin-top: 15px;">那么简单解决频繁分配内存的方法就是把分配操作移动到onDraw()方法外面，通常情况下，我们会把onDraw()里面用到的paint移动到外面初始化，如下面所示：</p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/475be92108df8ad094f94230e2cdd630005752ea.png" style="width: 770px !important; height: 401.619px !important;"><br></p><p style="margin-top: 15px;">由此也可以看出内存不足，引发频繁GC，因而CPU负荷加重，从而导致UI绘制不及时，最终UI卡顿。</p><h3 style="margin-top: 15px;"><span style="font-size: 18px;"><strong>2. 使用合适的图片</strong></span></h3><p style="margin-top: 15px;">我们通常会通过自定义View的方式来实现不规则形状的图标、表达非常复杂的动画等UI需求。这些，当然通常都离不开图片资源的使用。</p><p style="margin-top: 15px;">图片的质量往往会很直接地影响到自定义View的流畅度。毫无疑问，高质量的图片占用更多的内存，容易引发内存不足，频繁GC，甚至OOM等问题。</p><p style="margin-top: 15px;">因此，在做这方面的优化的时候，我们需要合理的平衡图片的质量以及占用内存的关系，最大限度地减低图片的内存占用，提高自定义View的流畅度。</p><p style="margin-top: 15px;">先要强调：</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;">不要在onDraw()方法里面加载图片，用时才加载的策略在这里不适用；</p></li><li><p style="margin-top: 15px;">不要在onDraw()里面对图片做处理，如果要对图片进行旋转、缩放，可以通过canvas来进行</p></li></ul><p><br></p><p style="margin-top: 15px;"><strong>1) 不同目的的图片需求，使用不同的图片解码格式</strong></p><p style="margin-top: 15px;">PNG，JPEG，WEBP等格式的图片在加载到内存的时候选择不同的解码格式，不同的解码格式对内存的占用是有很大差别的。在不影响到画质的前提下尽量减少内存的占用，这能够显著提升应用程序的操作体验、性能。</p><p style="margin-top: 15px;">Android为图片提供了4种解码格式：</p><blockquote><p style="margin-top: 15px;"><strong>ARGB_8888</strong></p><p style="margin-top: 5px;">32Bit，高质量的图片格式。</p></blockquote><blockquote><p style="margin-top: 15px;"><strong>RGB_565</strong></p><p style="margin-top: 5px;">16Bit&nbsp;，对于没有透明和半透明颜色的图片来说，该格式的图片能够达到比较的呈现效果，相对于ARGB_8888来说也能减少一半的内存开销，是一个不错的选择。另外我们通过android.content.res.Resources来取得一张图片时，它也是以该格式来创建BitMap的。</p><p style="margin-top: 5px;">从&nbsp;Android4.0&nbsp;开始，该选项无效。即使设置为该值，系统仍然会采用ARGB_8888&nbsp;来构造图片。</p></blockquote><blockquote><p style="margin-top: 15px;"><strong>ARGB_4444</strong></p><p style="margin-top: 5px;">16Bit，不推荐使用。</p></blockquote><blockquote><p style="margin-top: 15px;"><strong>ALPHA_8</strong></p><p style="margin-top: 5px;">8Bit&nbsp;，此时图片只有alpha值，没有RGB值。</p></blockquote><p style="margin-top: 15px;">解码格式不同，图片的清晰度会有所不同，我们需要针对实际的使用场景做不同的处理，大图跟小图可以使用不同的解码格式。可以通过下面的代码来设置解码格式：<br></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/0ee710a4f608d25015754f3bde31c29fc3d38fb5.png" style="width: 770px !important; height: 206.349px !important;"><br></p><p style="margin-top: 5px;">或</p><p style="margin-top: 5px;"><img src="/zhongduananquan/images/1e2900f14c11a3fd14e084cef4e4de56fab912a1.png" style="width: 770px !important; height: 175.881px !important;"><br></p><p style="margin-top: 15px;"><strong>2) 图片内存空间复用</strong></p><p style="margin-top: 15px;">我们知道bitmap会占用大量的内存空间，每次新创建出来的bitmap都会需要占用一块单独的内存区域，如下图所示：</p><p style="text-align: center; margin-top: 15px;"><img src="/zhongduananquan/images/9bde42eff612d2d5e4c71481ed118b1fabd9f37d.jpeg" style="width: 447px !important; height: 418px !important;"><br></p><p style="margin-top: 15px;">有一点需要重点说明一下：Android的Heap空间是不会自动做兼容压缩的，意思就是如果Heap空间中的图片被收回之后，这块区域并不会和其他已经回收过的区域做重新排序合并处理。那么当一个更大的图片需要放到heap之前，很可能找不到那么大的连续空闲区域，那么就会触发GC，使得heap腾出一块足以放下这张图片的空闲区域，如果无法腾出，就会发生OOM。</p><p style="margin-top: 15px;">为了解决上图所示的效率问题，Android在解码图片的时候引进了inBitmap属性，使用这个属性可以得到下图所示的效果：</p><p style="text-align: center; margin-top: 15px;"><img src="/zhongduananquan/images/d21d66d8e0e5ee2b5c2c24f28be363292db22b3a.jpeg" style="width: 444px !important; height: 399px !important;"><br></p><p style="margin-top: 15px;">inBitmap类似对象池的技术原理，避免内存的频繁的创建和销毁带来性能的损耗。使用inBitmap能高提升bitmap的循环效率。</p><p style="margin-top: 15px;">使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。</p><p style="margin-top: 15px;">下面是如何使用inBitmap的代码示例：</p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/ef1878cd39f8ee29b6eed4d8c6e55828703933ae.png" style="width: 770px !important; height: 141.259px !important;"><br></p><p style="margin-top: 15px;">需要注意的是inBitmap只能在3.0以后使用。2.3上，bitmap的数据是存储在native的内存区域，并不是在Dalvik的内存堆上。</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;">在SDK 11 -&gt; 18之间，重用的bitmap大小必须是一致的。</p></li></ul><p style="margin-top: 15px;">例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小。</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;">新申请的bitmap与旧的bitmap必须有相同的解码格式。</p></li></ul><p style="margin-top: 15px;">例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了。</p><p style="margin-top: 15px;">我们可以创建一个包含多种典型可重用bitmap的对象池，这样后续的bitmap创建都能够找到合适的“模板”去进行重用。如下图所示：</p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/06480166f8cb5454fd0327635fa19d2eb065b7af.jpeg" style="width: 403px !important; height: 325px !important;"><br></p><p style="margin-top: 15px;"><span style="font-size: 18px;"><strong>3. 对图片大小进行预缩放</strong></span></p><p style="margin-top: 15px;">对bitmap做缩放的意义很明显也很有效，提示显示性能，避免分配不必要的内存。</p><p style="margin-top: 15px;">Android提供了许多现成的bitmap缩放的API：</p><p style="margin-top: 15px;"><strong>1) 从已经存在的大图快速里面截取小图</strong>，使用createScaledBitmap()方法</p><p style="text-align: center; margin-top: 15px;"><img src="/zhongduananquan/images/83736bafb78bf462d7687d07e0378a95a64ff824.jpeg" style="width: 440px !important; height: 319px !important;"><br></p><p style="margin-top: 15px;"><strong>2) 不用先把原图加载进内存，直接生成等比缩放的图片</strong></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/2224112d18f0b8a177a6e67f426eafe130d44960.png" style="width: 770px !important; height: 139.874px !important;"><br></p><p style="margin-top: 15px;"><strong>3) 使用inScaled，inDensity，inTargetDensity的属性来对解码图片做处理</strong></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/d9ed4292df5482d828f67946e8194516a5469f13.png" style="width: 770px !important; height: 272.824px !important;"><br></p><p style="margin-top: 15px;"><strong>4) 不占内存就能获取图片的大小的方法</strong></p><p style="margin-top: 15px;"><img src="/zhongduananquan/images/c93b1d239f49161d20f618802b6e3c303fe9e865.png" style="width: 770px !important; height: 336.529px !important;"><br></p><p style="margin-top: 15px;"><strong>5) &nbsp;用完的图片记得recycle()</strong></p><p><br></p><h1 style="margin-top: 15px;"><strong><span style="font-size: 24px;">三 / 总结</span></strong></h1><p style="margin-top: 15px;">自定View的优化工作大体跟普通的UI优化原则相似，在许多细节上面有许多值得注意的点，可总结如下：</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="margin-top: 15px;">onDraw()方法里面不要执行耗时的操作。</p></li><li><p style="margin-top: 15px;">onDraw函数里尽量避免分配内存、创建对象，会导致频繁的垃圾回收降低性能。</p></li><li><p style="margin-top: 15px;">避免多次无效调用OnDraw()，有节制地调用View.invalidate()，不盲目追求fps，控制帧频</p></li><li><p style="margin-top: 15px;">追求扁平化布局，尽量压缩布局层次，采用更加合理的容器，避免嵌套太深</p></li><li><p style="margin-top: 15px;">尽量避免重叠不可见的元素的绘制</p></li></ul><p><br></p><p><br></p><p><br></p><p style="margin-top: 15px; white-space: normal;"><span style="font-size: 18px;"></span></p><p style="margin-top: 15px; white-space: normal;"><span style="color: rgb(0, 176, 240); font-family: 宋体; font-size: 14px; white-space: pre-wrap;">✎ 如果您想了解更多关于移动终端安全的内容，请收听我们的</span><strong style="color: rgb(0, 176, 240); font-family: 宋体; font-size: 14px; white-space: pre-wrap; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">微信公众号(终端安全那些事儿)</strong><span style="color: rgb(0, 176, 240); font-family: 宋体; font-size: 14px; white-space: pre-wrap;">，我们将定期为您分享；</span><br></p><p style="line-height: 25.6px; color: rgb(62, 62, 62); font-family: Verdana, 宋体, sans-serif; min-height: 1em; white-space: pre-wrap; border: 0px; list-style: none; word-break: normal; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="color: rgb(0, 176, 240); font-family: 宋体; line-height: 22.5px; word-break: normal; font-size: 14px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;">✎ 如果您对移动终端安全有什么问题和建议，关注我们的公众账号后直接回复消息联系我们。</span></p><p style="line-height: 25.6px; color: rgb(62, 62, 62); font-family: Verdana, 宋体, sans-serif; min-height: 1em; white-space: pre-wrap; border: 0px; list-style: none; word-break: normal; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="color: rgb(0, 176, 240); font-family: 宋体; line-height: 22.5px; word-break: normal; font-size: 14px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><br></span></p><p style="margin-bottom: 10px; white-space: normal; line-height: 25.6px; text-align: center;"><span style="max-width: 100%; color: rgb(0, 176, 240); box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="max-width: 100%; font-size: 12px; box-sizing: border-box !important; word-wrap: break-word !important;">终端安全那些事儿&nbsp;</span></strong></span><span style="max-width: 100%; color: rgb(0, 176, 240); font-size: 12px; box-sizing: border-box !important; word-wrap: break-word !important;">汇聚最优影响力的安全技术文章</span></p><p style="white-space: normal; line-height: 25.6px; text-align: center;"><img src="/zhongduananquan/images/a1c02648331a7d53620c4031cfba35723042669a.png" style="width: 138px !important; height: 137px !important;"></p><p style="white-space: normal; line-height: 25.6px; text-align: center;"><span style="color: rgb(0, 176, 240); font-size: 11px;">▲长按二维码可识别关注</span></p><p><span style="color: rgb(0, 176, 240); font-size: 11px;"><br></span></p><p><br></p>
{% endraw  %}

