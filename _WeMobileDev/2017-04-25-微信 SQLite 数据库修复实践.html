---
title: 微信 SQLite 数据库修复实践
author: guoling
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1493342728&src=3&ver=1&signature=L9XD8GAQyzHEmNm3CARkqYcY-1tt91kJ3HLZVT1k6u7wKZKQ98qt1hqUVXCUa6-6V4EO9WWLe4zs*3buVOAmtCPLUQ-6qpYijj8Cv2ZAs2nskT0*mA1*HRIK7NJ8Ms49lzZUy6LqLv4l4IzKK8Xo5cZ8OnwRdsDC1y62vIupBek=
date: '2017-04-25 00:00:00 +0000'

---

{% raw  %}
<h2 style=" -webkit-print-color-adjust: exact; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 24px; border-bottom: 1px solid rgb(204, 204, 204); font-family: Helvetica, arial, sans-serif; white-space: normal; ">1、前言</h2><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">众所周知，微信在后台服务器不保存聊天记录，微信在移动客户端所有的聊天记录都存储在一个 SQLite 数据库中，一旦这个数据库损坏，将会丢失用户多年的聊天记录。而我们监控到现网的损坏率是0.02%，也就是每 1w 个用户就有 2 个会遇到数据库损坏。考虑到微信这么庞大的用户基数，这个损坏率就很严重了。更严重的是我们用的官方修复算法，修复成功率只有 30%。损坏率高，修复率低，这两个问题都需要我们着手解决。</p><h2 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 24px; border-bottom: 1px solid rgb(204, 204, 204); font-family: Helvetica, arial, sans-serif; white-space: normal; ">2、SQLite 损坏原因及其优化</h2><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">我们首先来看 SQLite 损坏的原因，SQLite官网(<span style="color: rgb(172, 57, 255);">http://www.sqlite.org/howtocorrupt.html</span>)上列出以下几点：</p><ul style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; padding-left: 30px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;" class="list-paddingleft-2"><li><p>文件错写</p></li><li><p>文件锁 bug</p></li><li><p>文件 sync 失败</p></li><li><p>设备损坏</p></li><li><p>内存覆盖</p></li><li><p>操作系统 bug</p></li><li><p>SQLite bug</p></li></ul><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">但是我们通过收集到的大量案例和日志，分析出实际上移动端数据库损坏的真正原因其实就3个：</p><ul style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; padding-left: 30px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;" class="list-paddingleft-2"><li><p>空间不足</p></li><li><p>设备断电</p></li><li><p>文件 sync 失败</p></li></ul><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">我们需要针对这些原因一一进行优化。</p><h3 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 18px; font-family: Helvetica, arial, sans-serif; white-space: normal; ">2.1、优化空间占用</h3><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">首先我们来优化微信的空间占用问题。在这之前微信的部分业务也做了空间清理，例如朋友圈会自动删除7天前缓存的图片。但是总的来说对文件空间的使用缺乏一个全局把控，全靠各个业务自觉。我们需要做得更积极主动，要让开发人员意识到用户的存储空间是宝贵的。我们采取以下措施：</p><ul style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; padding-left: 30px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;" class="list-paddingleft-2"><li><p>业务文件先申请后使用，如果某个文件没有申请就使用了，会被自动扫描出来并删除；</p></li><li><p>每个业务文件都要申明有效期，是一天、一个星期、一个月还是永久存储；</p></li><li><p>过期文件会被自动清理。</p></li></ul><p><img src="/WeMobileDev/images/a9b8add1aded1de5a4f6d330f90e6ac74fa14431.png" style="width: 770px !important; height: 78.1102px !important;"></p><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">对于微信之外的空间占用，例如相册、视频、其他App的空间占用，微信本身是做不了什么事情的，我们可以提示用户进行空间清理：&nbsp;</p><p><img src="/WeMobileDev/images/c345889a2b477dbfa1a6deb8e4c5b569bff72db2.png" style="width: 750px !important; height: 1334px !important;"></p><h3 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 18px; font-family: Helvetica, arial, sans-serif; white-space: normal; ">2.2、优化文件 sync</h3><h5 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 14px; font-family: Helvetica, arial, sans-serif; white-space: normal; ">2.2.1、synchronous = FULL</h5><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">设置SQLite的文件同步机制为全同步，亦即要求每个事物的写操作是真的flush到文件里去。</p><h5 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 14px; font-family: Helvetica, arial, sans-serif; white-space: normal; ">2.2.1、fullfsync = 1</h5><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">通过与苹果工程师的交流，我们发现在 iOS 平台下还有&nbsp;fullfsync&nbsp;(<span style="color: rgb(172, 57, 255);">https://www.sqlite.org/pragma.html#pragma_fullfsync</span>) 这个选项，可以严格保证写入顺序跟提交顺序一致。设备开发商为了测评数据好看，往往会对提交的数据进行重排，再统一写入，亦即写入顺序跟App提交的顺序不一致。在某些情况下，例如断电，就可能导致写入文件不一致的情况，导致文件损坏。</p><h3 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 18px; font-family: Helvetica, arial, sans-serif; white-space: normal; ">2.3、优化效果</h3><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">多管齐下之后，我们成功将损坏率降低了一半多；DB损坏还是无法完全避免，我们还是得提高修复成功率。&nbsp;</p><p><img src="/WeMobileDev/images/527b78854d775f5de9e143f1bf4ccd7de9be86e4.png" style="width: 770px !important; height: 1108.73px !important;"></p><h2 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 24px; border-bottom: 1px solid rgb(204, 204, 204); font-family: Helvetica, arial, sans-serif; white-space: normal; ">3、SQLite 修复逻辑优化</h2><h3 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 18px; font-family: Helvetica, arial, sans-serif; white-space: normal; ">3.1、master 表</h3><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">首先我们来看 SQLite 的架构。SQLite 使用 B+树 存储一个表，整个 SQLite 数据库就是这些 B+树 组成的森林。对于每个表的元数据（表名、根节点地址、表 scheme 等），都记录在一个叫 sql_master 的表中。这个 <span style="font-family: Helvetica, arial, sans-serif; font-size: 14px;">sql_master</span> 表(下简称 master 表) 本身也是一个 B+树 存储的普通表。</p><p><img src="/WeMobileDev/images/c489410c12b50438b2e1bcc1b6ae01a4994405b4.png" style="width: 770px !important; height: 450.57px !important;"></p><h3 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 18px; font-family: Helvetica, arial, sans-serif; white-space: normal; ">3.2、官方修复算法率低下原因</h3><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">官方修复算法是这样一个流程：从 master 表中读出一个个表的信息，根据根节点地址和创表语句来 select 出表里的数据，能 select 多少是多少，然后插入到一个新 DB 中。要注意的是 master 表他本身也是一个 B+树 形式的普通表，DB 第0页就是他的根节点。那么只要 master 表某个节点损坏，这个节点下面记录的表就都恢复不了。更坏的情况是 DB 第0页损坏，那么整个 master 表都读不出来，就导致整个DB都恢复失败。这就是官方修复算法成功率这么低的原因，太依赖 master 表了。</p><h3 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 18px; font-family: Helvetica, arial, sans-serif; white-space: normal; ">3.3、备份 master 表</h3><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">那么最自然的想法，自然是另外备份一份 master 表了，也不需要用B+树，直接用数组序列化存储就好。我们只需要每隔一段时间轮询 master 表，看看最近有没有增删 table，有的话就全量备份。</p><h4 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-family: Helvetica, arial, sans-serif; white-space: normal; ">3.3.1、备份时机</h4><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">这里有个担忧，就是普通数据表的插入会不会导致表的根节点发生变化，也就是说 master 表会不会频繁变化，如果变化很频繁的话，我们就不能简单地进行轮询方案了。通过分析源码，我们发现 SQLite 里面 B+树 算法的实现是&nbsp;<strong style="-webkit-print-color-adjust: exact;">向下分裂</strong>&nbsp;的，也就是说当一个叶子页满了需要分裂时，原来的叶子页会成为内部节点，然后新申请两个页作为他的叶子页。这就保证了根节点一旦定下来，是再也不会变动的。实际的代码调试也证实了我们这个推论。所以说 master 表只会在新创建表或者删除一个表时才会发生变化，我们完全可以采用定时轮询方案。</p><h4 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-family: Helvetica, arial, sans-serif; white-space: normal; ">3.3.2、备份文件有效性</h4><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">接下来的难题是既然 DB 可以损坏，那么这个备份文件也会损坏，怎么办呢？我们采用了&nbsp;<strong style="-webkit-print-color-adjust: exact;">双备份</strong>&nbsp;的机制。具体来说就是会有新旧两个备份文件，每个文件头都加上 CRC 校验；每次备份时，从两个备份文件中选出一个进行覆盖。具体怎么选呢？优先选损坏那个备份文件，如果两个都有效，那么就选相对较旧的。这就保证了即使本次写入导致文件损坏，还有另外一份备份可以用。这个做法跟 Realm 标榜的 MVCC（多版本并发控制）的做法有异曲同工之妙，相当于确认新写入的文件有效之后，才使用新写入的文件，否则还是继续用旧的有效的文件。</p><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">前面提到 DB 损坏的一个常见场景是空间不足，这种情况下还要分配文件空间给备份文件也是会失败的。为了解决这个问题，我们采取&nbsp;<strong style="-webkit-print-color-adjust: exact;">预先分配空间</strong>&nbsp;的做法，初始值是 32K，大约可存 750 个表的元信息，后续则按照32K的倍数进行增长。</p><h3 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 18px; font-family: Helvetica, arial, sans-serif; white-space: normal; ">3.4、优化效果</h3><p style="-webkit-print-color-adjust: exact; margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">通过备份 master 表，我们成功将修复成功率提高了一倍多。</p><p><img src="/WeMobileDev/images/009ee9fd431b42fd00ae2ee420ec361e2ea06d11.png" style="width: 770px !important; height: 929.198px !important;"></p><h2 style=" -webkit-print-color-adjust: exact; margin-top: 20px; margin-bottom: 10px; font-weight: bold; -webkit-font-smoothing: antialiased; cursor: text;  font-size: 24px; border-bottom: 1px solid rgb(204, 204, 204); font-family: Helvetica, arial, sans-serif; white-space: normal; ">4、其他</h2><p style="-webkit-print-color-adjust: exact; margin-top: 15px; font-family: Helvetica, arial, sans-serif; font-size: 14px; white-space: normal;">通过这些优化，我们提高了微信聊天记录存储的可靠性。这些优化实践，会同之前在并发性能方面的优化实践（<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286361&amp;idx=1&amp;sn=78bbcda7f41a14291ad71289e4821f71&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286361&amp;idx=1&amp;sn=78bbcda7f41a14291ad71289e4821f71&amp;scene=21#wechat_redirect">微信iOS SQLite源码优化实践</a>），将会合并到微信即将开源的 WCDB（WeChat Database）组件中。我们正在进行紧张的代码整理工作，争取在 2017 年年中开源 WCDB。</p><p><br></p><p><img src="/WeMobileDev/images/3a149c2d1c4dfd2fbd8c17a60b94502e13c071f0.png" style="width: 529px !important; height: 527px !important;"></p><p><br></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1493342728&src=3&ver=1&signature=L9XD8GAQyzHEmNm3CARkqYcY-1tt91kJ3HLZVT1k6u7wKZKQ98qt1hqUVXCUa6-6V4EO9WWLe4zs*3buVOAmtCPLUQ-6qpYijj8Cv2ZAs2nskT0*mA1*HRIK7NJ8Ms49lzZUy6LqLv4l4IzKK8Xo5cZ8OnwRdsDC1y62vIupBek=">微信地址</a>
{% endraw  %}

