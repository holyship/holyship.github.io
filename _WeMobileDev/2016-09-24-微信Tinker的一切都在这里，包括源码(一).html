---
title: 微信Tinker的一切都在这里，包括源码(一)
author: shwenzhang
date: '2016-09-24 00:00:00 +0000'

---

{% raw  %}
<p>最近半年以来，Android热补丁技术热潮继续爆发，各大公司相继推出自己的开源框架。Tinker在最近也顺利完成了公司的审核，并非常荣幸的成为github.com/Tencent上第一个正式公开的项目。</p><p><br></p><p>回顾这半年多的历程，这是一条跪着走完，坑坑不息之路。或许只有自己真正经历过，深入研究过, 才会真正的明白</p><blockquote data-anchor-id="trec" class="" style="padding: 10px 15px; margin-bottom: 20px; border-left-width: 10px; border-color: rgb(214, 219, 223); background: none 0px 0px repeat scroll rgba(102, 128, 153, 0.0470588);"><p style="line-height: 25px;">热补丁不是请客吃饭</p></blockquote><p data-anchor-id="4211" style="margin-bottom: 20px;">对热补丁技术本身，还是对使用者来说都是如此。我希望通过分享微信在这历程中的思考与经验，能帮助大家更容易的决定是否在自己的项目中使用热补丁技术，以及选择什么样方案。</p><h2 style="margin-top: 20px; margin-bottom: 10px; font-weight: bold; font-size: 24px; white-space: normal; border-width: 0px 0px 1px; -webkit-font-smoothing: antialiased; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204);">热补丁技术背景</h2><p style="margin-top: 5px; margin-bottom: 5px;">热补丁是什么以及它的应用场景介绍，大家可以参考文章<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286306&amp;idx=1&amp;sn=d6b2865e033a99de60b2d4314c6e0a25&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286306&amp;idx=1&amp;sn=d6b2865e033a99de60b2d4314c6e0a25&amp;scene=21#wechat_redirect">微信Android热补丁实践演进之路</a>。</p><p data-anchor-id="lsud">在笔者看来Android热补丁技术应该分为以下两个流派：</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p>Native，代表有阿里的Dexposed、AndFix与腾讯的内部方案KKFix；</p></li><li><p>Java，代表有Qzone的超级补丁、大众点评的nuwa、百度金融的rocooFix, 饿了么的amigo以及美团的robust。</p><p><br></p></li></ul><p data-anchor-id="nb31" style="margin-bottom: 20px;">Native流派与Java流派都有着自己的优缺点，它们具体差异大家可参考上文。事实上从来都没有最好的方案，只有最适合自己的。</p><p data-anchor-id="p3dj" style="margin-bottom: 20px;">对于微信来说，我们希望得到一个“高可用”的补丁框架，它应该满足以下几个条件：</p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p><span style="font-weight: 700;">稳定性与兼容性</span>；微信需要在数亿台设备上运行，即使补丁框架带来1%的异常，也将影响到数万用户。</p></li><li><p><span style="font-weight: 700;">性能</span>；补丁框架不能影响应用的性能，这里基于大部分情况下用户不会使用到补丁。其次补丁包应该尽量少，这关系到用户流量与补丁的成功率问题；</p></li><li><p><span style="font-weight: 700;">易用性</span>；我们同时希望补丁框架简单易用，并且可以全面支持，甚至可以做到功能发布级别。</p><p><br></p></li></ol><p data-anchor-id="r9p2">在“高可用”这个大前提下，微信对当时存在的两个方案做了大量的研究：</p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p>Dexposed/AndFix；最大挑战在于稳定性与兼容性，而且native异常排查难度更高。另一方面，由于无法增加变量与类等限制，无法做到功能发布级别；</p></li><li><p>Qzone；最大挑战在于性能，即Dalvik平台存在插桩导致的性能损耗，Art平台由于地址偏移问题导致补丁包可能过大的问题；</p><p><br></p></li></ol><p data-anchor-id="0nl4">在2016年3月，微信为了追寻“高可用”这个目标，决定尝试搭建自己的补丁框架—Tinker。</p><p data-anchor-id="0nl4"><br></p><p data-anchor-id="0nl4">Tinker框架的演绎并不是一蹴而就，它大致分为三个阶段，每一阶段需要解决的核心问题并不相同。而Tinker v1.0的核心问题是实现符合性能要求的Dex补丁框架。</p><h2 style="margin-top: 20px; margin-bottom: 10px; font-weight: bold; font-size: 24px; white-space: normal; border-width: 0px 0px 1px; -webkit-font-smoothing: antialiased; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204);">Tinker v1.0—性能极致追求之路</h2><p style="margin-bottom: 20px; margin-top: 5px;">为了稳定性与兼容性，微信选择了Java流派。当前最大难点在于如何突破Qzone方案的性能问题，通过研究Instant Run的冷插拔与buck的<a target="_blank" style="color: rgb(0, 136, 204);">exopackage</a>给了我们灵感。它们的思想都是全量替换新的Dex。</p><p><img src="/WeMobileDev/images/1ba0f41198b83eaa94498b359f7a843c72d9e539.png"><br><br></p><p>简单来说，我们通过完全使用了新的Dex，那样既不出现Art地址错乱的问题，在Dalvik也无须插桩。当然考虑到补丁包的体积，我们不能直接将新的Dex放在里面。但我们可以将新旧两个Dex的差异放到补丁包中，这里我们可以调研的方法有以下几个：<br></p><p style="margin-bottom: 20px;"><img src="/WeMobileDev/images/68555229c3640779d00674e8014aa19358d3e871.jpeg"><br></p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p><strong>BsDiff</strong>；它格式无关，但对Dex效果不是特别好，而且生成产物大小非常不稳定。当前微信对于so与部分资源，依然使用bsdiff算法；</p></li><li><p><strong>DexMerge</strong>；它主要问题在于合成时内存占用过大，一个12M的dex，峰值内存可能达到70多M；</p></li><li><p><strong>DexDiff</strong>；通过深入Dex格式，实现一套生成产物小，内存占用少以及支持增删改的算法。</p></li></ol><p><br></p><p data-anchor-id="96zm" style="margin-bottom: 20px;">如何选择？在“高可用”的核心诉求下，性能问题也尤为重要。非常庆幸微信在当时那个节点坚决的选择了自研DexDiff算法，这过程虽然有苦有泪，但也正是有它，才有现在的Tinker。</p><h3 data-anchor-id="yo2m" style="font-family: inherit; line-height: 40px; color: inherit; text-rendering: optimizeLegibility; font-size: 21px; margin-top: 5px; margin-bottom: 5px;"><strong>一. DexDiff技术实践</strong></h3><p>在不断的深入研究究<a>Dex格式</a>后，我们发现自己跳进了一个深坑，主要难点有以下三个：</p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p><strong>Dex格式复杂</strong>；Dex大致分为像StringID，TypeID这些Index区域以及使用Offset的Data区域。它们有大量的互相引用，一个小小的改变可能导致大量的Index与Offset变化；</p></li><li><p><strong>dex2opt与dex2oat校验</strong>；在这两个过程系统会做例如四字节对齐，部分元素排序等校验，例如StringID按照内容的Unicode排序，TypeID按照StringID排序...</p></li><li><p><strong>低内存，快速</strong>；这要求我们对Dex每一块做到一次读写，无法像baksmali与dexmerge那样完全结构化。</p></li></ol><p style="margin-bottom: 20px;"><img src="/WeMobileDev/images/e6614b69c6bb000a38a7c9c38dce88c0b5d73dc9.png"><br>现在回想起来，这的确是一条跪着走完的路。与研究Dalvik与Art执行一致，这是经历一次次翻看源码，一次次编Rom查看日志，一次次dump内存结构换来的结果。</p><p data-anchor-id="9iny" style="margin-bottom: 20px;">下面以最简单的Index区域举例：</p><p style="margin-bottom: 20px;"><img src="/WeMobileDev/images/deddca3149eb9b7e023c8785984ea2a00ee26b26.jpeg"><br>要想将从左边序列更改成右边序列，Diff算法的核心在于如何生成最小操作序列，同时修正Index与Offset，实现增删改的功能。</p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p><strong>Del 2</strong>；"b"元素被删除，它对应的Index是2，为了减少补丁包体积，除了新增的元素其他一律只存Index;</p></li><li><p>"c", "d", "e"元素自动前移，无须操作；</p></li><li><p><strong>Addf(5)</strong>; 在第五个位置增加"f"这个元素。</p></li></ol><p><br></p><p data-anchor-id="24kj" style="margin-bottom: 20px;">对于Offset区，由于每个Section可能有非常多的元素，这里会更加复杂。最后我们得到最终的操作队列，为什么DexDiff可以做到内存非常少？这是因为DexDiff算法是每一个操作的处理，它无需一次性读入所有的数据。DexDiff的各项数据如下：</p><p><img src="/WeMobileDev/images/753c5770affe8443268760fee5c879555ac9b323.png"><br>通过DexDiff算法的实现，我们既解决了Dalvik平台的性能损耗问题，又解决了Art平台补丁包过大的问题。但这套方案的缺点在于占Rom体积比较大，微信考虑到移动设备的存储空间提升比较快，增加几十M的Rom空间这个代价可以接受。</p><h3 data-anchor-id="n81q" style="font-family: inherit; line-height: 40px; color: inherit; text-rendering: optimizeLegibility; font-size: 21px; margin-top: 5px; margin-bottom: 5px;"><strong>二. Android N的挑战</strong></h3><p>信心满满上线后，却很快收到华为反馈的一个Crash：</p><p><img src="/WeMobileDev/images/619aa012cfe90a9d8171566f491568dab1e57eba.png"><br>而且这个Crash只在Android N上出现，在当时对我们震动非常大，难道Android N不支持Java方式热补丁了？难道这两个月的辛苦都白费了吗？一切想象都苍白无力，只有继续去源码里面找原因。</p><p><br></p><p data-anchor-id="a6rs" style="margin-bottom: 20px;">在之前的基础上，这一块的研究并没有花太多的时间，主要是Android N的混合编译模式导致。更多的详细分析可参考文章<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286341&amp;idx=1&amp;sn=054d595af6e824cbe4edd79427fc2706&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286341&amp;idx=1&amp;sn=054d595af6e824cbe4edd79427fc2706&amp;scene=21#wechat_redirect">Android N混合编译与对热补丁影响解析</a>。</p><h3 data-anchor-id="kiiv" style="font-family: inherit; line-height: 40px; color: inherit; text-rendering: optimizeLegibility; font-size: 21px; margin-top: 5px; margin-bottom: 5px;"><strong>三. 厂商OTA的挑战</strong></h3><p>刚刚解决完Android N的问题，还在沉醉在自己的胜利的愉悦中。前线很快又传来噩耗，小米反馈开发版的一些用户在微信启动时黑屏，甚至ANR.</p><p><img src="/WeMobileDev/images/9f8b17210383e9f6286d4f289f8308ebb63ed5e8.png"><br><br></p><p>当时第一反应是不可能，所有的DexOpt操作都是放到单独的进程，为什么只在Art平台出现？为什么小米开发版用户反馈比较多？经过分析，我们发现优化后odex文件存在有效性的检查：</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p>Dalvik平台：modtime/crc...</p></li><li><p>Art平台： checksum/image_checksum/image_offset...</p></li></ul><p><br></p><p data-anchor-id="b3wj" style="margin-bottom: 20px;">这就非常好理解了，因为OTA之后系统image改变了，odex文件用到image的偏移地址很可能已经错误。对于ClassN.dex文件，在OTA升级系统已完成重新dex2oat，而补丁是动态加载的，只能在第一次执行时同步执行。</p><p data-anchor-id="gzkm" style="margin-bottom: 20px;">这个耗时可能高达十几秒，黑屏甚至ANR也是非常好理解。那为什么只有小米用户反馈比较多呢？这也是因为小米开发版每周都会推送系统升级的原因。</p><p data-anchor-id="d6si" style="margin-bottom: 20px;">在当时那个节点上，我们重新的审视了全量合成这一思路，再次对方案原理本身产生怀疑，它在Art平台上面带来了以下几个代价：</p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p><strong>OTA后黑屏问题</strong>；这里或许可以通过loading界面实现，但并不是很好的方案；</p></li><li><p><strong>Rom体积问题</strong>；一个10M的Dex，在Dalvik下odex产物只有11M左右，但在Art平台，可以达到30多M；</p></li><li><p><strong>Android N的问题</strong>；Android N在混合编译上努力，被补丁全量合成机制所废弃了。这是因为动态加载的Dex，依然是全量编译。</p></li></ol><p><br></p><p data-anchor-id="5fgm">回想起来，Qzone方案它只把需要的类打包成补丁推送，在Art平台上可能导致补丁很大，但它肯定比全量合成的Dex少很多很多。在此我们提出分平台合成的想法，即在Dalvik平台合成全量Dex，在Art平台合成需要的小Dex。</p><p><img src="/WeMobileDev/images/e0822864eab94058d49a842f60f9f26133171301.png"><br><br></p><p>DexDiff算法已经非常复杂，事实上要实现分平台合成更加不容易。</p><p><img src="/WeMobileDev/images/3ca6c8eff426580cdbb212852e101ba17d1d63cc.jpeg"><br>主要难点有以下几个方面：</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><strong>small dex的类收集</strong>；什么类应该放在这个小的Dex中呢？</p></li><li><p><strong>ClassN处理</strong>；对于ClassN怎么样处理，可能出现类从一个Dex移动到另外一个Dex?</p></li><li><p><strong>偏移二次修正</strong>; 补丁包中的操作序列如何二次修正？</p></li><li><p><strong>Art.info的大小</strong>； 为了修正偏移所引入的info文件的大小？</p></li></ul><p><br></p><p data-anchor-id="hh9f" style="margin-bottom: 20px;">庆幸的是，面对困难我们并没有畏惧，最后实现了这一套方案，这也是其他全量合成方案所不能做到的：</p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p>Dalvik全量合成，解决了插桩带来的<span style="font-weight: 700;">性能损耗</span>；</p></li><li><p>Art平台合成small dex，解决了<span style="font-weight: 700;">全量合成方案占用Rom体积大, OTA升级以及Android N的问题</span>；</p></li><li><p>大部分情况下Art.info仅仅1-20K,&nbsp;<span style="font-weight: 700;">解决由于补丁包可能过大的问题</span>；</p></li></ol><p><br></p><p data-anchor-id="5f8b" style="margin-bottom: 20px;">事实上，DexDiff算法变的如此复杂，怎么样保证它的正确性呢？微信为此做了以下三件事情：</p><ol class="list-paddingleft-2" style="list-style-type: decimal;"><li><p>随机组成Dex校验，覆盖大部分case；</p></li><li><p>微信200个版本的随机Diff校验, 覆盖日常使用情况；</p></li><li><p>Dex文件合成产物有效性校验，即使算法出现问题，也只是编译不出补丁包。</p></li></ol><p><br></p><p data-anchor-id="6t45" style="margin-bottom: 20px;">每一次DexDiff算法的更新，都需要经过以上三个Test才可以提交，这样DexDiff的这套算法已完成了整个闭环。</p><h3 data-anchor-id="reo4" style="font-family: inherit; line-height: 40px; color: inherit; text-rendering: optimizeLegibility; font-size: 21px; margin-top: 5px; margin-bottom: 5px;"><strong>四. 其他技术挑战</strong></h3><p style="margin-bottom: 20px; margin-top: 5px;">在实现过程，我们还发现其他的一些问题：</p><p style="margin-bottom: 10px;">1. Xposed等微信插件; 市面上有各种各样的微信插件，它们在微信启动前会提前加载微信中的类，这会导致两个问题：</p><ol class="list-paddingleft-2" style="list-style-type: lower-alpha;"><li><p style="margin-bottom: 10px;">Dalvik平台：出现<span style="font-weight: 700;">Class ref in pre-verified class resolved to unexpected &nbsp;implementation</span>的crash；</p></li><li><p style="margin-bottom: 10px;">Art平台:出现部分类使用了旧的代码，这可能导致补丁无效，或者地址错乱的问题。</p></li></ol><p style="margin-bottom: 10px;"><span style="font-weight: 700;">微信在这里的处理方式是若crash时发现安装了Xposed，即清除并不再应用补丁。</span></p><p style="margin-bottom: 10px;">2. &nbsp;Dex反射成功但是不生效；部分三星android-19版本存在Dex反射成功，但 &nbsp; &nbsp; &nbsp;出现类重复时，查找顺序始终从base.apk开始。&nbsp;</p><p style="margin-bottom: 10px;"><span style="font-weight: 700;">微信在这里的处理方式是增加Dex反射成功校验，具体通过在框架中埋入某个类的isPatch变量为false。在补丁时，我们自动将这个变量改为true。通过这个变量最终的数值，我们可以知道反射成功与否。</span></p><h2 style="margin-top: 20px; margin-bottom: 10px; font-weight: bold; font-size: 24px; white-space: normal; border-width: 0px 0px 1px; -webkit-font-smoothing: antialiased; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204);">Tinker v1.0总结</h2><h3 data-anchor-id="z0mm" style="font-family: inherit; line-height: 40px; color: inherit; text-rendering: optimizeLegibility; font-size: 21px; margin-top: 5px; margin-bottom: 5px;"><strong>一. 关于性能</strong></h3><p style="margin-bottom: 20px; margin-top: 5px;">通过Tinker v1，0的努力，我们解决了Qzone方案的性能问题，得到一个符合“高可用”性能要求的补丁框架。</p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><strong>它补丁包大小非常少</strong>，通常都是10k以内；</p></li><li><p><strong>对性能几乎没有影响，</strong>2%的性能影响主要原因是微信运行时校验补丁Dex文件的md5导致(虽然文件在/data/data/目录，微信为了更高级别的安全)；</p></li><li><p><strong>Art平台通过革命性的分平台合成</strong>，既解决了地址偏移的问题，占Rom体积与Qzone方案一致。</p><p><br></p></li></ul><p><img src="/WeMobileDev/images/5d5b260538423756c0695c20ae89bf9e58523cd3.jpeg"><br><strong>二. 关于成功率</strong></p><p style="margin-bottom: 20px; margin-top: 5px;">也许有人会质疑微信成功率为什么这么低，其他方案都是99%以上。事实上，我们的成功率计算方式是：</p><blockquote data-anchor-id="onlj" class="" style="padding: 10px 15px; margin-bottom: 20px; border-left-width: 10px; border-color: rgb(214, 219, 223); background: none 0px 0px repeat scroll rgba(102, 128, 153, 0.0470588);"><p style="line-height: 25px;">应用成功率= 补丁版本转化人数/基准版本安装人数</p></blockquote><p data-anchor-id="jyn5" style="margin-bottom: 20px;">即三天后，94.1%的基础版本都成功升级到补丁版本，由于基础版本人数也是持续增长，同时可能存在基准或补丁版本用户安装了其他版本，所以本统计结果应略为偏低，但它能现实的反应补丁的线上总体覆盖情况。</p><p data-anchor-id="1hki" style="margin-bottom: 20px;">事实上，采用Qzone方案，3天的成功率大约为96.3%，这里还是有很多的优化空间。</p><h3 data-anchor-id="sh08" style="font-family: inherit; line-height: 40px; color: inherit; text-rendering: optimizeLegibility; font-size: 21px; margin-top: 5px; margin-bottom: 5px;"><strong>三. Tinker v2.0－稳定性的探寻之路</strong></h3><p style="margin-top: 5px; margin-bottom: 5px;">在v1.0阶段，大部分的异常都是通过厂商反馈而来，Tinker并没有解决“高可用”下最核心的稳定性与兼容性问题。</p><p style="margin-top: 5px; margin-bottom: 5px;">我们需要建立完整的监控与补丁回退机制，监控每一个阶段的异常情况。这也是Tinker v2.0的核心任务，由于边幅问题这部分内容将放在下一篇文章。</p><p style="margin-top: 5px; margin-bottom: 5px;"><br></p><hr><p>关注Tinker，来Github给我们star吧</p><blockquote data-anchor-id="xr4e" class="" style="padding: 10px 15px; margin-bottom: 20px; border-left-width: 10px; border-color: rgb(214, 219, 223); background: none 0px 0px repeat scroll rgba(102, 128, 153, 0.0470588);"><p style="line-height: 25px;"><a target="_blank" style="color: rgb(0, 136, 204);">https://github.com/Tencent/tinker</a></p></blockquote><p data-anchor-id="7kaf" style="margin-bottom: 20px;">查看Tinker项目源码，请点击「阅读原文」。</p>
{% endraw  %}

