---
title: 揭秘：微信如何用libco支撑8亿用户？
author: Leiffy
date: '2016-10-31 00:00:00 +0000'

---

{% raw  %}
<blockquote><p style="margin-bottom: 15px; border: 0px;"><span style="color: rgb(136, 136, 136);">正如tony所说“微信将会发展为数字社会的基础设置，做一个很好的产品，做一个很酷的产品，这个理念对于微信团队来说，已经不足够”。</span></p><p style="margin-bottom: 15px; border: 0px;"><span style="color: rgb(136, 136, 136);">在这里，微信的技术团队也希望更多的将我们的技术精神与积累分享出去。WeMobileDev是一种尝试，tinker是另外一种尝试。tinker在一个月内获得5000+的star是一个不错的开端，在未来微信终端将开源更多优秀的项目，例如12月底的跨平台组件<span style="color: rgb(136, 136, 136); line-height: 25.6000003814697px; white-space: pre-wrap;">mars</span>。<br></span></p><p style="margin-bottom: 15px; border: 0px;"><span style="color: rgb(136, 136, 136);">不仅仅微信终端，微信后台也开源了大量优秀的项目，phxsql、phxpaxos以及文中的libco。事实上，腾讯的开源也在大力发展中，当前也有超过6个项目正在审核的流程中。在不久的将来，我们可以在</span><a target="_blank" style="color: rgb(136, 136, 136); line-height: 25.6000003814697px; white-space: pre-wrap; border: 0px; text-decoration: none;"><span style="color: rgb(136, 136, 136);">https://github.com/tencent<span style="color: rgb(136, 136, 136); line-height: 25.6000003814697px; white-space: pre-wrap; border: 0px;">发现更多优秀的项目。</span></span></a></p></blockquote><p style="margin-bottom: 15px; border: 0px;">libco是微信后台大规模使用的c/c++协程库，2013年至今稳定运行在微信后台的数万台机器上。libco在2013年的时候作为腾讯六大开源项目首次开源，我们最近做了一次较大的更新，同步更新在<a target="_blank" style="border: 0px; color: rgb(65, 131, 196);">https://github.com/tencent/libco</a>上。libco支持后台敏捷的同步风格编程模式，同时提供系统的高并发能力。</p><h2 style="margin-top: 20px; margin-bottom: 10px; border-width: 0px 0px 1px; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 24px; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204); color: rgb(0, 0, 0);">libco支持的特性</h2><ul style="margin-top: 15px; margin-bottom: 15px; padding-left: 30px; border: 0px;" class="list-paddingleft-2"><li><p>无需侵入业务逻辑，把多进程、多线程服务改造成协程服务，并发能力得到百倍提升;</p></li><li><p>支持CGI框架，轻松构建web服务(New);</p></li><li><p>支持gethostbyname、mysqlclient、ssl等常用第三库(New);</p></li><li><p>可选的共享栈模式，单机轻松接入千万连接(New);</p></li><li><p>完善简洁的协程编程接口</p></li><ul style="list-style-type: square;" class="list-paddingleft-2"><li><p>类pthread接口设计，通过co<em style="border: 0px;">create、co</em>resume等简单清晰接口即可完成协程的创建与恢复;</p></li><li><p>类 _<em style="border: 0px;">thread的协程私有变量、协程间通信的协程信号量co</em>signal (New);</p></li><li><p>非语言级别的lambda实现，结合协程原地编写并执行后台异步任务 (New);</p></li><li><p>基于epoll/kqueue实现的小而轻的网络框架，基于时间轮盘实现的高性能定时器;</p></li></ul></ul><h2 style="margin-top: 20px; margin-bottom: 10px; border-width: 0px 0px 1px; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 24px; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204); color: rgb(0, 0, 0);">libco产生的背景</h2><p style="margin-top: 10px; margin-bottom: 15px; border: 0px;">早期微信后台因为业务需求复杂多变、产品要求快速迭代等需求，大部分模块都采用了半同步半异步模型。接入层为异步模型，业务逻辑层则是同步的多进程或多线程模型，业务逻辑的并发能力只有几十到几百。随着微信业务的增长，系统规模变得越来越庞大，每个模块很容易受到后端服务/网络抖动的影响。</p><h2 style="margin-top: 20px; margin-bottom: 10px; border-width: 0px 0px 1px; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 24px; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204); color: rgb(0, 0, 0);">异步化改造的选择</h2><p style="margin-top: 10px; margin-bottom: 15px; border: 0px;">为了提升微信后台的并发能力，一般的做法是把现网的所有服务改成异步模型。这种做法工程量巨大，从框架到业务逻辑代码均需要做一次彻底的改造，耗时耗力而且风险巨大。于是我们开始考虑使用协程。</p><p style="margin-top: 15px; margin-bottom: 15px; border: 0px;">但使用协程会面临以下挑战：</p><blockquote style="margin-top: 15px; margin-bottom: 15px; padding-right: 15px; padding-left: 15px; border-width: 0px 0px 0px 4px; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119);"><p style="border: 0px;">1、 业界协程在c/c++环境下没有大规模应用的经验; 2、 如何控制协程调度; 3、 如何处理同步风格的API调用，如Socket、mysqlclient等; 4、 如何处理已有全局变量、线程私有变量的使用;</p></blockquote><p style="margin-top: 15px; margin-bottom: 15px; border: 0px;">最终我们通过libco解决了上述的所有问题，实现了对业务逻辑非侵入的异步化改造。我们使用libco对微信后台上百个模块进行了协程异步化改造，改造过程中业务逻辑代码基本无修改。至今，微信后台绝大部分服务都已是多进程或多线程协程模型，并发能力相比之前有了质的提升，而libco也成为了微信后台框架的基石。</p><h2 style="margin-top: 20px; margin-bottom: 10px; border-width: 0px 0px 1px; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 24px; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204); color: rgb(0, 0, 0);">libco框架</h2><p style="margin-top: 10px; margin-bottom: 15px; border: 0px;">libco在框架分为三层，分别是接口层、系统函数Hook层以及事件驱动层。</p><p style="margin-top: 15px; margin-bottom: 15px; border: 0px;"><img src="/WeMobileDev/images/d91a41a3f00d05619cba7c2f0ba6010d2876ed59.png" style="width: 579px !important; height: 338px !important;"><br></p><h2 style="margin-top: 20px; margin-bottom: 10px; border-width: 0px 0px 1px; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 24px; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204); color: rgb(0, 0, 0);">同步风格API的处理</h2><p style="margin-top: 10px; margin-bottom: 15px; border: 0px;">对于同步风格的API，主要是同步的网络调用，libco的首要任务是消除这些等待对资源的占用，提高系统的并发性能。一个常规的网络后台服务，我们可能会经历connect、write、read等步骤，完成一次完整的网络交互。当同步的调用这些API的时候，整个线程会因为等待网络交互而挂起。</p><p style="margin-top: 15px; margin-bottom: 15px; border: 0px;">虽然同步编程风格的并发性能并不好，但是它具有代码逻辑清晰、易于编写的优点，并可支持业务快速迭代敏捷开发。为了继续保持同步编程的优点，并且不需修改线上已有的业务逻辑代码，libco创新地接管了网络调用接口(Hook)，把协程的让出与恢复作为异步网络IO中的一次事件注册与回调。当业务处理遇到同步网络请求的时候，libco层会把本次网络请求注册为异步事件，本协程让出CPU占用，CPU交给其它协程执行。libco会在网络事件发生或者超时的时候，自动的恢复协程执行。</p><p style="margin-top: 15px; margin-bottom: 15px; border: 0px;">大部分同步风格的API我们都通过Hook的方法来接管了，libco会在恰当的时机调度协程恢复执行。</p><h2 style="margin-top: 20px; margin-bottom: 10px; border-width: 0px 0px 1px; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 24px; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204); color: rgb(0, 0, 0);">千万级协程支持</h2><p style="margin-top: 10px; margin-bottom: 15px; border: 0px;">libco默认是每一个协程独享一个运行栈，在协程创建的时候，从堆内存分配一个固定大小的内存作为该协程的运行栈。如果我们用一个协程处理前端的一个接入连接，那对于一个海量接入服务来说，我们的服务的并发上限就很容易受限于内存。为此，libco也提供了stackless的协程共享栈模式，可以设置若干个协程共享同一个运行栈。同一个共享栈下的协程间切换的时候，需要把当前的运行栈内容拷贝到协程的私有内存中。为了减少这种内存拷贝次数，共享栈的内存拷贝只发生在不同协程间的切换。当共享栈的占用者一直没有改变的时候，则不需要拷贝运行栈。</p><p style="margin-top: 15px; margin-bottom: 15px; border: 0px;"><img src="/WeMobileDev/images/0a1047526942dd9f0458550ecc6bcf666673c23e.png" style="width: 603px !important; height: 407px !important;"><br><span style="line-height: 1.6;">libco协程的共享协程栈模式使得单机很容易接入千万连接，只需创建足够多的协程即可。我们通过libco共享栈模式创建1千万的协程（E5-2670 v3 @ 2.30GHz * 2, 128G内存），每10万个协程共享的使用128k内存，整个稳定echo服务的时候总内存消耗大概为66G,qps可达到210W+/s;</span></p><h2 style="margin-top: 20px; margin-bottom: 10px; border-width: 0px 0px 1px; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 24px; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204); color: rgb(0, 0, 0);">协程私有变量</h2><p style="margin-top: 10px; margin-bottom: 15px; border: 0px;">多进程程序改造为多线程程序时候，我们可以用_<em style="border: 0px;">thread来对全局变量进行快速修改，而在协程环境下，我们创造了协程变量 ROUTINE</em>VAR，极大简化了协程的改造工作量。</p><p style="margin-top: 15px; margin-bottom: 15px; border: 0px;">因为协程实质上是线程内串行执行的，所以当我们定义了一个线程私有变量的时候，可能会有重入的问题。比如我们定义了一个__thread的线程私有变量，原本是希望每一个执行逻辑独享这个变量的。但当我们的执行环境迁移到协程了之后，同一个线程私有变量，可能会有多个协程会操作它，这就导致了变量重入的问题。为此，我们在做libco异步化改造的时候，把大部分的线程私有变量改成了协程级私有变量。协程私有变量具有这样的特性：当代码运行在多线程非协程环境下时，该变量是线程私有的；当代码运行在协程环境的时候，此变量是协程私有的。底层的协程私有变量会自动完成运行环境的判断并正确返回所需的值。</p><p style="margin-top: 15px; margin-bottom: 15px; border: 0px;">协程私有变量对于现有环境同步到异步化改造起了举足轻重的作用，同时我们定义了一个非常简单方便的方法定义协程私有变量，简单到只需一行声明代码即可。</p><h2 style="margin-top: 20px; margin-bottom: 10px; border-width: 0px 0px 1px; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 24px; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204); color: rgb(0, 0, 0);">gethostbyname的Hook方法</h2><p style="margin-top: 10px; margin-bottom: 15px; border: 0px;">对于现网服务，有可能需要通过系统的gethostbyname API接口去查询DNS获取真实地址。我们在协程化改造的时候，发现我们hook的socket族函数对gethostbyname不适用，当一个协程调用了gethostbyname时会同步等待结果，这就导致了同线程内的其它协程被延时执行。我们对glibc的gethostbyname源码进行了研究，发现hook不生效主要是由于glibc内部是定义了__poll方法来等待事件，而不是通用的poll方法；同时glibc还定义了一个线程私有变量，不同协程的切换可能会重入导致数据不准确。最终gethostbyname协程异步化是通过Hook __poll方法以及定义协程私有变量解决的。</p><p style="margin-top: 15px; margin-bottom: 15px; border: 0px;">gethostbyname是glibc提供的同步查询dns接口，业界还有很多优秀的gethostbyname的异步化解决方案，但是这些实现都需要引入一个第三方库并且要求底层提供异步回调通知机制。libco通过hook方法，在不修改glibc源码的前提下实现了的gethostbyname的异步化。</p><h2 style="margin-top: 20px; margin-bottom: 10px; border-width: 0px 0px 1px; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 24px; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204); color: rgb(0, 0, 0);">协程信号量</h2><p style="margin-top: 10px; margin-bottom: 15px; border: 0px;">在多线程环境下，我们会有线程间同步的需求，比如一个线程的执行需要等待另一个线程的信号，对于这种需求，我们通常是使用pthread<em style="border: 0px;">signal 来解决的。在libco中，我们定义了协程信号量co</em>signal用于处理协程间的并发需求，一个协程可以通过co<em style="border: 0px;">cond<em style="border: 0px;">signal与co</em>cond</em>broadcast来决定通知一个等待的协程或者唤醒所有等待协程。</p><h2 style="margin-top: 20px; margin-bottom: 10px; border-width: 0px 0px 1px; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 24px; border-bottom-style: solid; border-bottom-color: rgb(204, 204, 204); color: rgb(0, 0, 0);">总结</h2><p style="margin-top: 10px; border: 0px;">libco是一个高效的c/c++协程库，提供了完善的协程编程接口、常用的Socket族函数Hook等，使得业务可用同步编程模型快速迭代开发。随着几年来的稳定运行，libco作为微信后台框架的基石发挥了举足轻重的作用。</p>
{% endraw  %}

