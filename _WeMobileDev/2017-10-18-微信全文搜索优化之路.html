---
title: 微信全文搜索优化之路
author: jiaminchen
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1512888793&src=3&ver=1&signature=0dsH*cvrb7sDcdE*f0PtKOs7A4HAIWdDeXlFBeeOv2PvU4ey6lhaX5jwMMbCe1wLX0D*rhIAbX*u*1NI7GPVaTLrPaZyC8hw36B5oEszR2PdhAdG99AViRh*zcPz6oV810*qirGdTl0Dor2g7DwfXeww2apzBHrzq1804TzKOcA=
date: '2017-10-18 00:00:00 +0000'

---

{% raw  %}
<blockquote><p>本文首次发表在《程序员》杂志 2017 年 09 月期。</p></blockquote><h3 cid="n0" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1.5em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.43;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" class="" style="box-sizing: border-box;">前言</span></h3><hr style="box-sizing: content-box;border-top-width: 0px;border-right-width: 0px;border-left-width: 0px;border-style: none none solid;border-bottom-color: rgb(221, 221, 221);height: 4px;margin-top: 16px;margin-bottom: 16px;background-color: rgb(231, 231, 231);"><p cid="n2" mdtype="paragraph" class="" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n3" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">基于本地数据的全文搜索（Full-Text-Search，FTS）在移动应用上扮演着重要的角色。与基于服务端提供的搜索服务不同，移动端受硬件条件限制，尤其在数据量相对较大的情况下，搜索性能问题表现得十分突出。本文以移动平台广泛采用的SQLite FTS Extension为例，介绍了移动平台FTS的基本原理，结合微信安卓客户端自身实践，重点讲述微信在FTS上的一些性能优化经验。</span></span></p><h3 cid="n339" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1.5em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.43;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" class="" style="box-sizing: border-box;">SQLite FTS Extension</span></h3><hr style="box-sizing: content-box;border-top-width: 0px;border-right-width: 0px;border-left-width: 0px;border-style: none none solid;border-bottom-color: rgb(221, 221, 221);height: 4px;margin-top: 16px;margin-bottom: 16px;background-color: rgb(231, 231, 231);"><p cid="n7" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n8" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">SQLite FTS Extension是SQLite为全文搜索开发的一个插件，它是内嵌在标准的SQLite分布版本当中，它具有如下的特点：</span></span></p><p cid="n9" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n10" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">搜索速度快：</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">使用倒排索引加速查找过程</span></span></p><p cid="n11" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n12" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">稳定性好：</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">目前SQLite在移动端的稳定性比较好，FTS Extension就是SQLite的基础上搭建的</span></span></p><p cid="n13" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n14" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">接入简单</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">：Android和IOS平台本身就支持SQLite，并且FTS Extension的使用就和正常使用SQLite表一样。</span></span></p><p cid="n15" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n16" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">兼容性好</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">：受益于SQLite本身兼容性很好，SQLite FTS Extension也有很好的兼容性。</span></span></p><p cid="n17" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n18" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">目前SQLiteFTSExtension发布了5个版本，我简单说下三个主流的版本。</span></span></p><p cid="n19" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n20" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">FTS3：</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">基础版本，具有完整的FTS特性，支持自定义分词器，库函数包括Offsets，Snippet。</span></span></p><p cid="n21" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n22" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">FTS4：</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">在FTS3的基础上，性能有较大优化，增加相关性函数计算MatchInfo。</span></span></p><p cid="n23" mdtype="paragraph" class="" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n24" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">FTS5：</span></strong></span><span md-inline="plain" class="" style="box-sizing: border-box;">和FTS4有较大变动，储存格式上有较大改进，最明显就是Instance-List的分段存储，能够支持更大的Instance-List的存储；并且开放ExtensionApi，支持自定义辅助函数。FTS5发布于2015年中。</span></span></p><h3 cid="n347" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1.5em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.43;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" class="" style="box-sizing: border-box;">存储架构</span></h3><hr style="box-sizing: content-box;border-top-width: 0px;border-right-width: 0px;border-left-width: 0px;border-style: none none solid;border-bottom-color: rgb(221, 221, 221);height: 4px;margin-top: 16px;margin-bottom: 16px;background-color: rgb(231, 231, 231);"><p cid="n28" mdtype="paragraph" class="" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n29" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">微信全文搜索在2014 年底上线，最初主要服务于联系人和聊天记录的业务搜索。在方案设计之初，为了让这个功能有很好的体验，同时考虑到未来接入业务的会不断增多，我们设计目标是：</span></span></p><h4 cid="n30" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1.25em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.4;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" style="box-sizing: border-box;">1. 搜索速度快</span></h4><p cid="n31" mdtype="paragraph" class="" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n32" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">微信全文搜索使用SQLite FTS4 Extension，通过倒排索引提高搜索速度。</span></span></p><h4 cid="n33" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1.25em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.4;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" style="box-sizing: border-box;">2. 业务独立性</span></h4><p cid="n34" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n35" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">微信的核心业务是联系人和消息，而微信全文搜索无论是在建立索引、更新索引或者删除索引时，都需要处理大量数据，为了使得全文搜索不影响微信的核心业务，采用如下的存储架构：</span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtlJPtHsnae5PZrzIOWNB4HB1sIwsDByIQE73sMpPpqh4hfUXBPhFKnQ/0?wx_fmt=png" style="width: 556px !important; height: 325.103px !important;"></p><p cid="n38" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n39" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">独立DB、读写分离：</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">微信全文搜索在整体架构上独立于主业务，搜索DB也是独立于主业务DB；当主业务数据发生更新时，主业务通过EventBus方式通知搜索对应的业务数据处理模块，业务数据处理模块会通过一个独立的ReadOnly数据库连接接访问主业务数据库，不和主业务存储层共享数据库连接。</span></span></p><p cid="n40" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n41" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">减少数据库操作：</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">在搜索模块中，会有专门处理业务数据的模块，对一些复杂的数据结构做一些特殊的处理。例如对于一个500成员的群聊，如果把500个群成员分次插入搜索DB当中，会造成过多的数据库操作。所以，微信会把所有的群成员拼接为单个字符串，插入搜索DB中。</span></span></p><p cid="n42" mdtype="paragraph" class="" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n43" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">热数据延迟更新：</span></strong></span><span md-inline="plain" style="box-sizing: border-box;"> 针对更新频率非常高的热数据，采用延迟更新的策略。所有的索引数据分为正常数据和脏数据。当数据发生更新时，先把对应的数据标记为脏数据，然后有一个定时器，每隔10分钟，把数据更新到索引中。</span></span></p><h4 cid="n44" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1.25em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.4;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" class="" style="box-sizing: border-box;">3. 可扩展性高</span></h4><p cid="n45" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n46" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">高可扩展性要求搜索表结构和业务解耦。SQLite FTS官网上的例子，都是以单索引表的方式，每一列对应业务的某一个属性，当对应业务发生变化，需要修改索引表的结构。为了解决业务变化而带来的表结构修改问题，微信把业务属性数字化，设计如下的表结构：</span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtaKJv7cEiaickZpIMF9LsDr3g84Pn6vJtv9Orsicc9bZgiaKCzsibqoiacMZQ/0?wx_fmt=png" style="width: 556px !important; height: 381.171px !important;"></p><p><span class="" cid="n48" mdtype="line" style="box-sizing: border-box;display: block;"><span style="color: rgb(51, 51, 51);">IndexTable负责全文搜索的索引建立，它和逻辑无关，当搜索关键词时，只需要找到对应的DocId即可。MetaTable负责业务逻辑的过滤，通过Type和SubType来过滤对应业务的数据，最后输出BusItemId。</span></span></p><h3 cid="n98" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1.5em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.43;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" class="" style="box-sizing: border-box;">搜索优化</span></h3><hr style="box-sizing: content-box;border-top-width: 0px;border-right-width: 0px;border-left-width: 0px;border-style: none none solid;border-bottom-color: rgb(221, 221, 221);height: 4px;margin-top: 16px;margin-bottom: 16px;background-color: rgb(231, 231, 231);"><p cid="n99" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n100" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">微信全文搜索于2014年1月26日5.4版本上线，到2017年春节后的6.5.7版本，总体用户量从4亿增加到9亿，重度用户数量也大幅度增长，微信本地搜索的数据量也大幅度增长，造成了搜索速度不断下降，用户投诉不断增加。我们统计过，从微信5.4版本到6.5.7版本，微信全文搜索各个任务的平均搜索时间增长超过10倍，给微信全文搜索带来巨大挑战。</span></span></p><p cid="n101" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n102" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">为了优化搜索时长，先看下搜索的流程图：</span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtkNdgyx9ibNMsXKZaFKFPLKEdbHjpkJP0CBwXgurcb6PDCic6u2icSX2nw/0?wx_fmt=png" style="width: 556px !important; height: 580.858px !important;"></p><p><span class="" cid="n48" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;color: rgb(51, 51, 51);">通过每个阶段的耗时，发现在取数据阶段，时间占比达到</span><span md-inline="strong" class="" style="box-sizing: border-box;color: rgb(51, 51, 51);"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">80%</span></strong></span><span md-inline="plain" style="box-sizing: border-box;color: rgb(51, 51, 51);">以上，并且搜索的结果集数据量越大，时间占比越高，最高可以达到95%。取数据阶段是一个循环的过程，所以优化一个循环需要从两方面着手，减少单次循环耗时和减少总体循环次数。</span></span></p><h4 cid="n107" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1.25em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.4;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" class="" style="box-sizing: border-box;">减少单次循环执行耗时</span></h4><p cid="n108" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n109" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">深入SQLite FTS4 Extension源码，发现FTS4的库函数Offsets耗时占单次循环执行耗时70%以上，并且数据量越大耗时越长。</span></span></p><p cid="n110" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n111" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">FTS4库函数Offsets：</span></strong></span><span md-inline="plain" class="" style="box-sizing: border-box;">用于把词语偏移转为字节偏移，微信当中使用字节做结果排序和结果高亮。</span></span></p><p cid="n112" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n113" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">函数输入：</span></span></p><ul class="list-paddingleft-2" cid="n114" mdtype="list" data-mark="-" style=""><li><p cid="n116" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.5rem;margin-bottom: 0.5rem;width: inherit;"><span class="" cid="n117" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">Query：用户查找的关键词</span></span></p></li><li><p cid="n119" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.5rem;margin-bottom: 0.5rem;width: inherit;"><span class="" cid="n120" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">命中Doc：关键词所命中的文档。文档就是全文搜索中的基本单位，可以是一个网页，一篇文章或者是一条聊天记录</span></span></p></li><li><p cid="n122" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.5rem;margin-bottom: 0.5rem;width: inherit;"><span class="" cid="n123" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">目标词语偏移：在搜索阶段，通过关键词查找搜索索引可以拿到目标词语偏移</span></span></p></li></ul><p cid="n124" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n125" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">函数输出：</span></span></p><ul class="list-paddingleft-2" cid="n126" mdtype="list" data-mark="-" style=""><li><p cid="n128" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.5rem;margin-bottom: 0.5rem;width: inherit;"><span class="" cid="n129" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">目标字节偏移：表示关键词在命中Doc中的字节偏移。</span></span></p></li></ul><p cid="n130" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n131" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">例如：</span></span></p><p cid="n132" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n133" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">Query</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">=我 </span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">命中Doc</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">=我和我弟弟去逛街 </span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">目标词语偏移</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">=0、2</span></span></p><p cid="n134" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n135" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">把命中Doc经过分词器分词，可以得到下表：</span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPttNwPB9uhIAeLFIuicakmR9CWScxD9TA14skaKutDwrJkIZpkrrkMvUQ/0?wx_fmt=png" style="width: 770px !important; height: 124.712px !important;"></p><p cid="n167" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n168" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">最后计算可以得出</span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">目标字节偏移</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">=0、6</span></span></p><p cid="n169" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n170" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">下图是Offsets函数处理命中Doc字节数和耗时的关系：</span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtDrbveFaZxbAf3wgGHQqF79ovoYUkciaZ3ysaDkJibxY1KwCPM3TnQdGw/0?wx_fmt=jpeg" style="width: 770px !important; height: 330.458px !important;"></p><p cid="n173" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n174" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">Offsets函数的处理过程中包括分词，所以第一步就优化分词器。</span></span></p><p cid="n175" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n176" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">要优化分词器，分词规则是重中之重。</span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">微信的分词规则</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">为英文和数字合并分词，非英文和数字单独分词。举个例子，如对于昵称“Hello520中国”，分词结果为“Hello”、“520”、“中”、“国”。这个分词规则的原因主要是在微信对全文搜索的结果排序需求主要是其他的属性排序，并非依据文档的相关性排序。即，全文搜索部分只需要找到存在关键词的文档，并不关心文档中存在几个关键词。而且用户的输入Query大部分情况都不能组成词语，存在方言，所以把整个词语全部拆开建立索引是符合需求的。</span></span></p><p cid="n177" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n178" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">微信全文搜索最早开发于2013年底，FTS4是SQLite FTS Extension的最高版本，但是FTS4自带的分词器不能很好的支持中文，只能使用ICU分词器，当时ICU分词器的接入比较简单，对中文支持较好，所以使用了ICU分词器。</span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtCoveY1chdo7FKVSeaduAnYaw6oOibANrmtL3Dia2bBUsGVvnBjjibeWSQ/0?wx_fmt=png" style="width: 556px !important; height: 134.554px !important;"></p><p><span class="" cid="n48" mdtype="line" style="box-sizing: border-box;display: block;"><span style="color: rgb(51, 51, 51);">对于昵称“Hello520中国”输出分词器中，开始是UTF8编码，分词器会做一次转化为Unicode编码，接着查找词典，最后进行后处理得到分词结果。从输入输出中可以发现，转化编码和查找词典这两步其实是多余的，所以微信舍弃ICU分词器，自定义了Simple分词器。</span></span><span class="" cid="n48" mdtype="line" style="box-sizing: border-box;display: block;"><span style="color: rgb(51, 51, 51);"></span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtibATnrWF2N0QwX80SKngUxzurlMKqdWeNZntyZB9SFznYkHyZPiakNVg/0?wx_fmt=png" style="width: 556px !important; height: 217.848px !important;"></p><p><span class="" cid="n48" mdtype="line" style="box-sizing: border-box;display: block;"><span style="color: rgb(51, 51, 51);">Simple分词直接处理的UTF8编码的Doc内容，通过单个char，判断当前字符的Unicode编码范围和Unicode编码长度，根据不同的情况做出不同的处理。</span><span style="color: rgb(51, 51, 51);"></span><br></span><span class="" cid="n48" mdtype="line" style="box-sizing: border-box;display: block;"><span style="color: rgb(51, 51, 51);"></span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtNYs0NXicnXRFlmDP5D9zCc5XXibhPw2c2XcRibkNMX1icjO0JxMsqMtU6Q/0?wx_fmt=jpeg" style="width: 770px !important; height: 332.597px !important;"></p><p><span class="" cid="n48" mdtype="line" style="box-sizing: border-box;display: block;"><span style="color: rgb(51, 51, 51);">经过分词器优化后Offsets函数耗时在处理10万Byte的耗时降低为21ms，但是这样的优化还不够，当处理超过10个10W结果Doc时，仍然会超过200ms，所以有了下一步的优化。</span><span style="color: rgb(51, 51, 51);"></span><br></span></p><p cid="n191" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n192" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">在移动端由于屏幕的限制，往往在最后显示搜索结果时，只会高亮少量命中的关键词，而Offsets函数会计算命中Doc中所有目标词语偏移，所以需要对Offsets函数进行改造。</span></span></p><p cid="n193" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n194" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">最开始我尝试的方案是直接修改Offsets函数源码，发现FTS4对API的封装比较难使用，Offsets函数的依赖也比较多，修改出来的代码很难维护，可读性也不好，所以需要寻找新的方法来优化。在一番研究以后，我发现FTS5支持自定义辅助函数，并且有比较好的API的封装，所以最后使用FTS5自定义辅助函数(MMHighLight)重新实现Offsets函数的功能，并加入优化逻辑。</span></span></p><p cid="n195" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n196" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">输入：</span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">Query</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">=我 </span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">命中Doc</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">=我和我弟弟去逛街 </span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">目标词语偏移</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">=0、2 </span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">目标返回个数</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">=1</span></span></p><p cid="n197" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n198" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">分词器分步回调，当分词器第一次返回“我”，符合目标词语偏移的第一个0，并且此时已经满足目标返回个数1个，函数直接返回</span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">目标字节偏移</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">=0。</span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtjECaic1VZ4Dq3Ch6RvbpAghOcb0AsBgInTVOMHgqS2aUPvybGjhLL2w/0?wx_fmt=jpeg" style="width: 770px !important; height: 334.736px !important;"></p><h4 cid="n408" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1.25em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.4;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" class="" style="box-sizing: border-box;">减少总体循环次数</span></h4><p cid="n204" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n205" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">减少取数据阶段的总体循环次数，比较容易想到的就是在SQL层做数据的</span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">分页返回</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">，分页返回就意味着需要在</span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">DB层排序</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">，在DB层排序的决定因素就是</span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">排序因子</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">。但是微信全文搜索面对的业务排序因子多并且复杂，无法直接使用SQL中的ORDER BY，所以需要通过一个</span><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">中间函数转化</span></strong></span><span md-inline="plain" class="" style="box-sizing: border-box;">，把所有的排序因子通过一个可比较的数字体现，最后再使用ORDER BY排序。</span></span></p><p cid="n206" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n207" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">这里简单说下，比较复杂的排序因子如下：</span></span></p><p cid="n208" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n209" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">时间分段排序：</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">时间范围在半年内，排序因子取决于下一级排序因子，时间范围在半年外，取决于时间的远近。</span></span></p><p cid="n210" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n211" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="strong" class="" style="box-sizing: border-box;"><strong style="box-sizing: border-box;"><span md-inline="plain" style="box-sizing: border-box;">函数结果排序</span></strong></span><span md-inline="plain" style="box-sizing: border-box;">：排序因子是一个函数计算的结果，不是一个直接的数据库Column，并且函数计算结果不可直接使用ORDER BY，例如字符串形式的数字。</span></span></p><p cid="n212" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n213" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">通过以上的分析，减少总体循环次数的核心点就在于，把Java层的排序转移到SQL层去做，优点如下：</span></span></p><ol class="list-paddingleft-2" start="" cid="n214" mdtype="list" style=""><li><p cid="n216" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.5rem;margin-bottom: 0.5rem;width: inherit;"><span class="" cid="n217" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">减少I/O</span></span></p></li><li><p cid="n219" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.5rem;margin-bottom: 0.5rem;width: inherit;"><span class="" cid="n220" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">减少C层到Java层的数据拷贝</span></span></p></li></ol><p cid="n221" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n222" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">所以这里关键的实现点在于中间转化函数的实现，微信的中间转化函数MMRank是通过FTS5的辅助函数实现的。</span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtVWbpLPCic5Rt4kDpv0kjo9uXAMUvq6WlMDFLkzKv6IoTxico4AUAG48A/0?wx_fmt=png" style="width: 556px !important; height: 178.155px !important;"></p><p cid="n225" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n226" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">MMRank的实现原理就是通过把所有的排序因子转化到一个64位的Long数值当中，高优先级的排序因子置高位，低优先级的排序因子置低位。最后的SQL如下：</span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtDYXRnuqVJCehRiaVLeAicIxv7UmlczsTicJ8Nw4NZoItufUibbHbfPo05A/0?wx_fmt=png" style="width: 770px !important; height: 122.578px !important;"></p><p><span style="font-size: 1.25em;font-weight: bold;">特殊优化——聊天记录搜索优化</span></p><p cid="n231" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n232" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">微信全文搜索中有一个比较特殊的搜索任务，就是聊天记录。</span></span></p><p cid="n233" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n234" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">如图所示：</span></span><span class="" cid="n234" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;"></span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtQ8C1nP1hTROhf0ZRCicT9Kribe3DK0ElcAntA2FukH6wZS99ommaxz8w/0?wx_fmt=png" style="width: 770px !important; height: 735.559px !important;"></p><p><span class="" cid="n234" mdtype="line" style="box-sizing: border-box;display: block;"><span style="color: rgb(51, 51, 51);">图中的红色圈内的数字表示，此会话中，包含关键字“我”的聊天记录的个数，而会话的排序规则就是会话的活跃时间。</span><span md-inline="plain" style="box-sizing: border-box;"></span><br></span></p><p cid="n239" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n240" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">微信聊天记录的搜索有一下两个特点：</span></span></p><ol class="list-paddingleft-2" start="" cid="n241" mdtype="list" style=""><li><p cid="n243" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.5rem;margin-bottom: 0.5rem;width: inherit;"><span class="" cid="n244" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">有统计属性</span></span></p></li><li><p cid="n246" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.5rem;margin-bottom: 0.5rem;width: inherit;"><span class="" cid="n247" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">数量非常多（单关键词命中最高可达到20万条）</span></span></p></li></ol><p cid="n248" mdtype="paragraph" class="" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n249" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">从搜索流程图中可以看出，微信最初采用的方案是在Java层统计个数和排序，此方法在大数据的情况下不可取。鉴于之前分析过减少循环次数可以通过分页返回，其核心点在于把排序从Java层转移到SQL层，所以就有了优化方案一。</span></span></p><h5 cid="n250" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.4;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" class="" style="box-sizing: border-box;">优化方案一：Group By</span></h5><p cid="n251" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n252" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;"></span></span></p><p cid="n251" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n252" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">实现SQL如下：</span></span><span class="" cid="n252" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;"></span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtDibfS1dDmbfgMvpQ54FloCQ2hcftoyCMbBoy7DfFEZGmW6ibzwq59dIg/0?wx_fmt=png" style="width: 770px !important; height: 164.752px !important;"></p><p><span class="" cid="n252" mdtype="line" style="box-sizing: border-box;display: block;">此方案通过Group By在SQL层直接统计出命中聊天记录的个数，并按照最近的时间排序，但是也有明显的缺陷：</span></p><ol class="list-paddingleft-2" start="" cid="n256" mdtype="list" style=""><li><p cid="n258" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.5rem;margin-bottom: 0.5rem;width: inherit;"><span class="" cid="n259" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">无法使用索引加速：当GroupBy和OrderBy同时使用是，OrderBy中必须包含GroupBy的字段才可以命中索引，原因是使用GroupBy会生成中间子表。</span></span></p></li><li><p cid="n261" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.5rem;margin-bottom: 0.5rem;width: inherit;"><span class="" cid="n262" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">全量计算：GroupBy在SQL层统计命中聊天记录个数是统计了所有会话，上图中只需要统计3个会话，浪费了大量资源。</span></span></p></li></ol><h5 cid="n263" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.4;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" class="" style="box-sizing: border-box;">优化方案二：分步计算</span></h5><p cid="n264" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n265" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;"></span></span></p><p cid="n264" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n265" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">鉴于方案一全量计算的问题，采用分步计算的方式。</span></span></p><p cid="n266" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n267" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">第一步：找出最近</span>活跃的3个会话</span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPt65XEmpMBCyDvNCjkex7heSVZpaEOUPRgnicdacg8Hu9QxSatzDicARAQ/0?wx_fmt=png" style="width: 770px !important; height: 126.599px !important;"></p><p><span class="" cid="n267" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">得到会话conv1,conv2,conv3，然后执行以下SQL，可以分别得到三个会话的命中</span>个数</span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtlggjujIelkksXYaRdugBjleVxX7bGSniazgaOJGzXCWH5b1hRdtGt5w/0?wx_fmt=png" style="width: 770px !important; height: 277.338px !important;"></p><p><span class="" cid="n267" mdtype="line" style="box-sizing: border-box;display: block;">但是这种方法也存在问题，需要执行多条SQL。</span></p><p><span class="" cid="n270" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;"></span></span></p><h5 cid="n274" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.4;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" class="" style="box-sizing: border-box;">优化方案三：MessageCount</span></h5><p cid="n275" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n276" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">鉴于方案二需要多条SQL的问题，可以通过自定义聚合函数实现一次性统计。执行步骤如下：</span></span></p><p cid="n277" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n278" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;"></span></span><span md-inline="plain" class="" style="box-sizing: border-box;">第一步：找出最近</span>活跃的3个会话</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtyCjWQlZviaGweuqsibj98pKA5XkBT3m4unkCUVvurmYPsMYQDYf1DTiaw/0?wx_fmt=png" style="width: 770px !important; height: 130.068px !important;"></p><p cid="n277" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);">得到会话conv1,conv2,conv3，然后执行以下SQL</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPticHO6IWQLyjXn22zxF384k4VJMMMOY9Aic3qGgbg8FQUfV7IB8wrCLiaw/0?wx_fmt=png" style="width: 770px !important; height: 158.172px !important;"></p><p cid="n277" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);">可以一次性得到三个会话的命中个数。</p><p cid="n283" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n284" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;"><span style="color: rgb(51, 51, 51);"></span></span></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/csvJ6rH9McsmjJ7gn2Lk8894EQDJ7WPtA0emCZwrdLUF4PZwjAUghHKwCHmXcjwSJu9XjjguA1fnyg4vZl3yyg/0?wx_fmt=jpeg" style="width: 770px !important; height: 343.292px !important;"></p><h3 cid="n438" mdtype="heading" class="" style="box-sizing: border-box;font-size: 1.5em;margin-top: 1rem;margin-bottom: 1rem;font-weight: bold;line-height: 1.43;cursor: text;width: inherit;color: rgb(51, 51, 51);"><span md-inline="plain" class="" style="box-sizing: border-box;">最后</span></h3><hr style="box-sizing: content-box;border-top-width: 0px;border-right-width: 0px;border-left-width: 0px;border-style: none none solid;border-bottom-color: rgb(221, 221, 221);height: 4px;margin-top: 16px;margin-bottom: 16px;background-color: rgb(231, 231, 231);"><p cid="n290" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n291" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">经过优化后，微信全文搜索全体用户各个任务平均耗时都在50ms以下，而重度用户各个任务的平均搜索耗时都在200ms以下，平均时间优化的幅度达到5倍以上。</span></span></p><p cid="n292" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n293" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" style="box-sizing: border-box;">后续还有很多值得优化的地方，例如，在计算高亮时，如果在DocList的数据结构中，直接加入字节偏移，那么还可以节省一部分时间。</span></span></p><p cid="n294" mdtype="paragraph" style="box-sizing: border-box;-webkit-margin-before: 1rem;-webkit-margin-after: 1rem;margin-top: 0.8em;margin-bottom: 0.8em;width: inherit;color: rgb(51, 51, 51);"><span class="" cid="n295" mdtype="line" style="box-sizing: border-box;display: block;"><span md-inline="plain" class="" style="box-sizing: border-box;">最后希望我的分享能够对大家有些价值，欢迎留言交流。</span></span></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1512888793&src=3&ver=1&signature=0dsH*cvrb7sDcdE*f0PtKOs7A4HAIWdDeXlFBeeOv2PvU4ey6lhaX5jwMMbCe1wLX0D*rhIAbX*u*1NI7GPVaTLrPaZyC8hw36B5oEszR2PdhAdG99AViRh*zcPz6oV810*qirGdTl0Dor2g7DwfXeww2apzBHrzq1804TzKOcA=">微信地址</a>
{% endraw  %}

