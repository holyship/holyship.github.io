---
title: WCDB 的 WAL 模式和异步 Checkpoint
author: johnwhe
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1515989662&src=3&ver=1&signature=yyLj*6br2FUtW3BtBE3siO2oBl7-LTTBZRFPhrotzYqfUx-VDDQOrcWk4b*CpSdMKBSI1l7h4hynUSi4oQ7A3IKSinu*MLLaspU25xfrQCwgCeCcLzxjp7ZAfRZwJY74Ixa5zavYiGCwINPnw*f0Q91nDIY89vGpx4C3-7AfEH8=
date: '2018-01-14 00:00:00 +0000'

---

{% raw  %}
<p class="" style="color: rgb(30, 30, 30);" data-line="2"><span style="font-size: 16px;">WAL 模式是 SQLite 3.7.0 版本推出的改进写性能和并发性的功能，至今已经7年多了，但由于WAL是默认关闭的，可能有相当多的应用并没有用上，仍然使用性能较差的传统模式。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="2"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="4"><span style="font-size: 16px;">微信 APP 开启了 WAL 模式，同时还针对 WAL 做了一点改进 —— 异步 Checkpoint。通过 A/B Test，最终相比传统 Rollback 模式写耗时减少 70% 以上，还稍稍降低了 DB 损坏率。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="4"><br></p><h2 class="" style="color: rgb(30, 30, 30);" data-line="6"><strong><span style="font-size: 20px;">WAL 和异步 Checkpoint</span></strong></h2><p><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="8"><span style="font-size: 16px;">SQLite 实现&nbsp;<strong>原子性提交和回滚操作</strong>&nbsp;的默认方法是 rollback journal。当对 DB 进行写操作的时候，SQLite 首先将准备要修改部分的原始内容（以 Page 为单位）拷贝到“回滚日志”中，用于后续可能的 Rollback 操作以及 Crash、断电等意外造成写操作中断时恢复 DB 的原始状态，回滚日志存放于名为“DB文件名-journal”的独立文件中（以下简称“-journal”）。对原始内容做备份后，才能写入修改后的内容到 DB 主文件中，当写入操作完成，用户提交事务后，SQLite 清空 -journal 的内容，至此完成一个完整的写事务。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="8"><br></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McvS92BHTVe6wHjHTCRbyvgw6KHUSYDRcI6x3LurNwynwiaiaicqjG3ZPD99nfmGQ3md1VGJPzQoFIW6w/0?wx_fmt=png" style="width: 711px !important; height: 551px !important; visibility: visible !important;"></p><p style="text-align: center;"><span style="font-size: 14px;">图：Rollback journal 工作模式</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="12"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="12"><span style="font-size: 16px;">Rollback 模式中，每次拷贝原始内容或写入新内容后，都需要确保之前写入的数据真正写入到磁盘，而不是缓存在操作系统中，这需要发起一次&nbsp;<strong>fsync 操作</strong>，通知并等待操作系统将缓存真正写入磁盘，<strong>这个过程十分耗时。</strong></span></p><p class="" style="color: rgb(30, 30, 30);" data-line="12"><span style="font-size: 16px;"><strong><br></strong></span></p><p class="" style="color: rgb(30, 30, 30);" data-line="14"><span style="font-size: 16px;">除了耗时的 fsync 操作，写入 -journal 以及 DB 主文件的时候，是需要独占整个 DB 的，否则别的线程/进程可能读取到写到一半的内容。这样的设计使得写操作与读操作是互斥的，并发性很差。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="14"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="16"><span style="font-size: 16px;">WAL 模式则改变了上述流程，写操作不直接写入 DB 主文件，而是写到“DB文件名-wal”文件（以下简称“-wal”）的末尾，并且通过 -shm 共享内存文件来实现 -wal 内容的索引。读操作时，将结合 DB 主文件以及 -wal 的内容返回结果。由于读操作只读取 DB 主文件和 -wal 前面没在写的部分，不需要读取写操作正在写到一半的内容，WAL 模式下读与写操作的并发由此实现。WCDB 的多线程并发，也是基于 WAL 模式下实现连接池实现的。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="16"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="18"><span style="font-size: 16px;">WAL 写操作除了上面的流程，还增加了一步：<strong>Checkpoint，即将 -wal 的内容与合并到 DB 主文件。</strong>&nbsp;由于写操作将内容临时写到 -wal 文件，-wal 文件会不断增大且拖慢读操作，因此需要定期进行 Checkpoint 操作将 -wal 文件保持在合理的大小。Checkpoint 操作比较耗时且会阻塞读操作，但由于时效性要求较低，遇到堵塞可以暂时放弃继续 DB 读写操作，不至于太过影响读写性能。SQLite 官方默认的 Checkpoint 阈值是 1000 page，即当 -wal 文件达到 1000 page 大小时，写操作的线程在完成写操作后同步进行 Checkpoint 操作；Android Framework 的 Checkpoint 阈值是 100 page。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="18"><br></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McvS92BHTVe6wHjHTCRbyvgwsDoFScIY0VMuib06xwYBL4ZcL3UKsc1vumAXcj8oE4xIDw541eXx8bw/0?wx_fmt=png" style="width: 711px !important; height: 553px !important;"></p><p style="text-align: center;"><span style="font-size: 14px;">图：WAL 工作模式</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="22"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="22"><span style="font-size: 16px;">基于 WAL 的基本工作方式，我们很容易想到两个优化点：</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="22"><span style="font-size: 16px;"><br></span></p><ul class="list-paddingleft-2" style=""><li><p>写入 -wal 文件时不进行 fsync 操作，因为 -wal 文件损坏只影响新写入的没 Checkpoint 部分数据而非整个数据库损坏，影响相对小</p></li><li><p>将需要进行 fsync 的 Checkpoint 操作放到独立线程执行，让写操作能尽快返回</p><p><br></p></li></ul><p class="" style="color: rgb(30, 30, 30);" data-line="27"><span style="font-size: 16px;">这个就是异步 Checkpoint 的基本思路，减少和转移耗时较多而且性能不稳定的 fsync 操作，增加写操作性能和减少突然卡顿的可能性，同时不增加 DB 损坏率。基本思路确定了，就剩下参数上的调整了，Checkpoint 操作多频繁比较好？怎样的策略能得到最佳性能和损坏率的平衡？这些都是我们需要考虑的问题。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="27"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="29"><span style="font-size: 16px;">关于 WAL 模式和 Checkpoint 其他资料，可以参考&nbsp;</span><span style="font-size: 16px;">SQLite 官方文档</span><span style="font-size: 16px;">。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="29"><span style="font-size: 16px;"><br></span></p><h2 class="" style="color: rgb(30, 30, 30);" data-line="31"><strong><span style="font-size: 20px;">策略选择与 A/B Test</span></strong></h2><p><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="33"><span style="font-size: 16px;">异步 Checkpoint 策略中，最关键的点为 Checkpoint 的阈值。通过前面的先验知识，我们推测：<strong>阈值越低，Checkpoint 越频繁，写磁盘次数越多，-wal 大小越小，非阻塞时读性能越好（-wal 大小影响索引速度）；阈值越高，则相反。</strong></span></p><p class="" style="color: rgb(30, 30, 30);" data-line="33"><strong><br></strong></p><p class="" style="color: rgb(30, 30, 30);" data-line="35"><span style="font-size: 16px;">考虑到我们在独立线程做 Checkpoint，频繁 Checkpoint 的耗时可以掩盖掉，而维持 -wal 较小的话可以最优化读速度，所以首先尝试的策略是将阈值设为0，也就是一有任何提交，马上尝试 Checkpoint。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="35"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="37"><span style="font-size: 16px;">然而这个策略很快就发现问题了：如果一直有读写请求，频繁尝试 Checkpoint 会一直失败，以至 -wal 文件不断增大最终严重影响性能。现实中 APP 可能没有 Demo 中的情况极端，但也不能排除这种情况存在。为了解决这个问题，我们多引入了一个阻塞阈值，如果 Checkpoint 一直没有完成导致 -wal 堆积的 page 数达到阻塞阈值，则会阻塞其他读写操作让 Checkpoint 优先完成。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="37"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="37"><span style="font-size: 16px;">引入了阻塞阈值之后，经过线下测试，阻塞阈值设置在 100 ~ 300 左右在高压极端情况下性能损失较少，也不至于一直阻塞做 Checkpoint，最后我们选择普通阈值 0，阻塞阈值 100 的配置，记作 ACP(0/100)【ACP = Asynchronous Checkpoint】。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="37"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="37">另一组策略是，引入异步 Checkpoint 但维持普通阈值在 100，这样 Checkpoint 频率会和 Android WAL 默认策略差不多。阻塞阈值则设置为 300，靠近高压下的性能拐点。这个策略记作 ACP(100/300)。</p><p class="" style="color: rgb(30, 30, 30);" data-line="37"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="39"><span style="font-size: 16px;">由于每次 Commit 都会 Checkpoint，每次 Checkpoint 前 SQLite 都会做 fsync 操作，因此写操作也做 fsync 就浪费了，基于这一点考虑，我们设置了&nbsp;</span><code style=";"><span style="font-size: 16px;">PRAGMA SYNCHRONOUS=NORMAL</span></code><span style="font-size: 16px;">，在写操作时不做 fsync。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="39"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="41"><span style="font-size: 16px;">线上 A/B Test，使用 WCDB for Android 1.0.5 版本，一开始选取了三种不同配置：传统 Rollback 模式、默认 WAL 模式、WAL + ACP(0/100)。关注点主要是<strong>读写性能以及 DB 损坏概率 DB 损坏概率</strong>。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="41"><br></p><h2 class="" style="color: rgb(30, 30, 30);" data-line="43"><strong><span style="font-size: 20px;">性能数据对比</span></strong></h2><p><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="45"><span style="font-size: 16px;">性能数据采集上，我们使用了两个指标：</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="45"><br></p><ul class="list-paddingleft-2" style=""><li><p><strong>操作时间</strong>，即排除等待锁后 SQLite 真正处理读写请求的时间，主要反映&nbsp;<strong>操作本身的性能</strong>；</p></li><li><p><strong>等待时间</strong>，即真正进行操作前花在等待锁等步骤的平均时间，主要反映&nbsp;<strong>并发能力</strong>。</p><p><br></p></li></ul><p class="" style="color: rgb(30, 30, 30);" data-line="50"><span style="font-size: 16px;">我们在灰度版本中挑选部分用户分别使用不同的模式，分别统计每个模式的读和写操作的操作时间和等待时间（单位：毫秒），汇总后得出统计数据。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="50"><span style="font-size: 16px;"><br></span></p><p><br></p><table><thead><tr><th style="text-align: left;border-color: rgba(0, 0, 0, 0.69);">配置</th><th style="text-align: right;border-color: rgba(0, 0, 0, 0.69);">写耗时</th><th style="text-align: right;border-color: rgba(0, 0, 0, 0.69);">写等待</th></tr></thead><tbody><tr><td>Rollback</td><td style="text-align: right;">13.022</td><td style="text-align: right;">0.246</td></tr><tr><td style="border-color: rgba(0, 0, 0, 0.18);">WAL</td><td style="border-color: rgba(0, 0, 0, 0.18);text-align: right;">5.894</td><td style="border-color: rgba(0, 0, 0, 0.18);text-align: right;">0.160</td></tr><tr><td style="border-color: rgba(0, 0, 0, 0.18);">ACP</td><td style="border-color: rgba(0, 0, 0, 0.18);text-align: right;">3.577</td><td style="border-color: rgba(0, 0, 0, 0.18);text-align: right;">0.269</td></tr></tbody></table><p><br></p><p><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="58"><span style="font-size: 16px;">其中，ACP 的数据是 ACP(0/100) 与 ACP(100/300) 的混合，由于 ACP(100/300) 是后续上线的，没能将 ACP(0/100) 与 ACP(100/300) 分开收集。线下测试 ACP(100/300) 由于 Checkpoint 次数少因此造成的阻塞场景也少，写等待性能优于 ACP(0/100) ，写耗时差距不大。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="58"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="60"><span style="font-size: 16px;">从统计数据分析得出，使用 WAL 模式默认配置平均比 Rollback 模式写耗时减少 50% 以上；开启异步 Checkpoint 后比 WAL 模式默认配置还能再优化约 40%。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="60"><br></p><table><thead><tr><th style="text-align: left;border-color: rgba(0, 0, 0, 0.69);">配置</th><th style="text-align: right;border-color: rgba(0, 0, 0, 0.69);">读耗时</th><th style="text-align: right;border-color: rgba(0, 0, 0, 0.69);">读等待</th></tr></thead><tbody><tr><td>Rollback</td><td style="text-align: right;">1.294</td><td style="text-align: right;">0.239</td></tr><tr><td style="border-color: rgba(0, 0, 0, 0.18);">WAL</td><td style="border-color: rgba(0, 0, 0, 0.18);text-align: right;">1.394</td><td style="border-color: rgba(0, 0, 0, 0.18);text-align: right;">0.025</td></tr><tr><td style="border-color: rgba(0, 0, 0, 0.18);">ACP</td><td style="border-color: rgba(0, 0, 0, 0.18);text-align: right;">1.436</td><td style="border-color: rgba(0, 0, 0, 0.18);text-align: right;">0.025</td></tr></tbody></table><p class="" style="color: rgb(30, 30, 30);" data-line="68"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="68"><span style="font-size: 16px;">读性能则如官方文档所说，WAL 模式单线程性能要稍稍差于 Rollback 模式，但由于 WAL 模式支持读写并发，WCDB 也开启了线程池，因此 WAL 模式的并发性要远远好于 Rollback 模式。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="68"><br></p><h2 class="" style="color: rgb(30, 30, 30);" data-line="70"><strong><span style="font-size: 20px;">损坏率对比</span></strong></h2><p><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="72"><span style="font-size: 16px;">性能指标以外，DB 损坏率也是我们关注的重点，SQLite 一些性能选项会影响到 DB 损坏的概率，提高性能的同时牺牲 DB 稳定性和损坏率的话，我们是不能接受的。损坏率的测量我们选用了一个指标是&nbsp;<strong>每百亿次写操作损坏次数</strong>，由于不同配置的使用场景是完全一样的，因此我们认为写操作次数和使用人数是成正比关系的，用发生损坏与写操作次数的比值作比较，可以大致得出每种配置的损坏率比例关系。</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="72"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="74"><span style="font-size: 16px;">经过多天的测量，不同配置的损坏率如图所示：</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="74"><span style="font-size: 16px;"><br></span></p><p class="" style="color: rgb(30, 30, 30);" data-line="74"><span style="font-size: 16px;"></span></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McvS92BHTVe6wHjHTCRbyvgw94XuQAwvy9vCMYdlO68Sl1y54GQX1lylfjM2sicVh35JW16JH43iaJTg/0?wx_fmt=png" style="width: 770px !important; height: 324.143px !important;"></p><p style="text-align: center;"><span style="font-size: 14px;">图：不同配置损坏率分布</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="74"><span style="font-size: 16px;"></span><br></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McvS92BHTVe6wHjHTCRbyvgwSHpK1CY9RvmibdV7qISqTKzNCnSynu09OyCLBMwPq3CoMAYaU54yHzw/0?wx_fmt=png" style="width: 770px !important; height: 367.39px !important;"></p><p style="text-align: center;"><span style="font-size: 14px;">图：不同配置损坏率比值</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="76"><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="79"><span style="font-size: 16px;">可以看出不同配置的损坏率，<strong>WAL 和 ACP(100/300) 处于同等级水平，Rollback 和 ACP(0/100) 分别是前者的 1.5 ~ 2 倍和 3 ~ 4 倍。</strong></span></p><p class="" style="color: rgb(30, 30, 30);" data-line="79"><span style="font-size: 16px;"><strong><br></strong></span></p><p class="" style="color: rgb(30, 30, 30);" data-line="79">通过不同配置损坏率的比例和全网人数可以算出<span style="display: inline !important;float: none;background-color: transparent;color: rgb(30, 30, 30);" left="left" sans="sans" helvetica="helvetica" px="px" none="none" normal="normal" yahei="yahei" gb="gb" neue="neue">每天按人数算的损坏率</span>，损坏最低的 WAL 和 ACP(100/300) 约为 1/30,000；最高的 ACP(0/100) 约为 1/10,000。</p><p class="" style="color: rgb(30, 30, 30);" data-line="79"><span style="font-size: 16px;"><strong><br></strong></span></p><p class="" style="color: rgb(30, 30, 30);" data-line="81"><span style="font-size: 16px;">上面四种不同配置，对 DB 主文件的写操作和 fsync 操作频率是有明显区别的：</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="81"><br></p><ul class="list-paddingleft-2" style=""><li><p>Rollback 模式每个事务，首先要将改动前数据写入 -journal 文件，再将改动后数据写入 DB 主文件，均进行 fsync；</p></li><li><p>WAL 模式默认使用&nbsp;<code style=";">SYNCHRONOUS = FULL</code>，每次事务都写入 -wal 文件并且 fsync，当 -wal 累计够阈值（100 page）后进行 Checkpoint 写入 DB 主文件并且 fsync。</p></li><li><p>ACP 情况与 WAL 默认相似，只是 Checkpoint 操作交给另外的线程进行；ACP(100/300) 的 Checkpoint 频率和 WAL 默认配置相似，ACP(0/100) 则要高不少。</p><p><br></p></li></ul><p class="" style="color: rgb(30, 30, 30);" data-line="87"><span style="font-size: 16px;">SQLite 进行 fsync 操作目的是保证 fsync 成功后，达到原子性操作边界的 page 完整确切地写入了磁盘，但从上面损坏率的比例我们可以定性推测，<strong>操作系统上的 fsync 返回时并不能保证数据真正 100% 写到磁盘</strong>，因此对 DB 主文件的写操作越多，因为突然关机或操作系统 Crash 等场景导致 DB 文件处于中间状态而中断写入的概率就越高，因此损坏率越高。即&nbsp;<strong>对 DB 主文件进行写操作的次数与 DB 损坏率正相关。</strong></span></p><p class="" style="color: rgb(30, 30, 30);" data-line="87"><strong><br></strong></p><h2 class="" style="color: rgb(30, 30, 30);" data-line="89"><strong><span style="font-size: 20px;">在 WCDB 中使用 WAL 和异步 Checkpoint</span></strong></h2><p><br></p><p class="" style="color: rgb(30, 30, 30);" data-line="91"><span style="font-size: 16px;">WAL 和异步 Checkpoint 是微信客户端数据库组件 WCDB 的重要优化点之一。iOS 版本默认开启 WAL 与异步 Checkpoint；Android 版本由于要保持与官方接口一致，默认不开启 WAL 与 Checkpoint，可以通过以下方式开启。从 Rollback 模式迁移到 WAL + 异步 Checkpoint 不需要做数据迁移，<strong>建议使用 WCDB 的 Android App 均尝试打开 WAL + 异步 Checkpoint。</strong></span></p><p class="" style="color: rgb(30, 30, 30);" data-line="91"><strong><br></strong></p><pre class="" style="overflow-x: auto;color: rgb(77, 77, 76);padding: 0.5em;white-space: pre-wrap;font-size: 14px;"><code style=";"><p><span class="" style="color: rgb(142, 144, 140);">// 以 WAL 模式打开 DB<br></span>SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabaseInWalMode(path, password, cipher, <span class="" style="color: rgb(137, 89, 168);">null</span>);<br><br><span class="" style="color: rgb(142, 144, 140);">// 开启异步 Checkpoint<br></span>db.setAsyncCheckpointEnabled(<span class="" style="color: rgb(137, 89, 168);">true</span>);</p></code></pre><p class="" style="color: rgb(30, 30, 30);" data-line="100"><span style="font-size: 16px;"><br></span></p><p class="" style="color: rgb(30, 30, 30);" data-line="100"><span style="font-size: 16px;">或</span></p><p class="" style="color: rgb(30, 30, 30);" data-line="100"><span style="font-size: 16px;"><br></span></p><pre class="" style="overflow-x: auto;color: rgb(77, 77, 76);padding: 0.5em;white-space: pre-wrap;font-size: 14px;"><code style=";"><p><span class="" style="color: rgb(142, 144, 140);">// 在 SQLiteOpenHelper 中打开 WAL<br></span>SQLiteOpenHelper helper = <span class="" style="color: rgb(137, 89, 168);">new</span> SQLiteOpenHelper() { &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(142, 144, 140);">// 重载 onCreate 等方法<br></span>};
helper.setWriteAheadLoggingEnabled(<span class="" style="color: rgb(137, 89, 168);">true</span>);<br> &nbsp; &nbsp;<br><span class="" style="color: rgb(142, 144, 140);">// 获取 DB 对象，然后开启异步 Checkpoint<br></span>SQLiteDatabase db = helper.getWritableDatabase();
db.setAsyncCheckpointEnabled(<span class="" style="color: rgb(137, 89, 168);">true</span>);</p></code></pre><p class="" style="color: rgb(30, 30, 30);" data-line="2"><br></p><p><code style=";"></code></p><p><code style=";"><br></code></p><p><br></p><p><strong>欢迎点击【阅读原文】到我们的 Github 页面关注 WCDB 数据库组件。</strong></p><p><br></p><p><br></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1515989662&src=3&ver=1&signature=yyLj*6br2FUtW3BtBE3siO2oBl7-LTTBZRFPhrotzYqfUx-VDDQOrcWk4b*CpSdMKBSI1l7h4hynUSi4oQ7A3IKSinu*MLLaspU25xfrQCwgCeCcLzxjp7ZAfRZwJY74Ixa5zavYiGCwINPnw*f0Q91nDIY89vGpx4C3-7AfEH8=">微信地址</a> | <a href="https://github.com/Tencent/wcdb/">阅读原文</a>
{% endraw  %}

