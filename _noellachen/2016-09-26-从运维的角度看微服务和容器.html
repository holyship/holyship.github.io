---
title: 从运维的角度看微服务和容器
author: 陈爱珍
date: '2016-09-26 00:00:00 +0000'

---

{% raw  %}
<section label="Copyright © 2015 playhudong All Rights Reserved." donone="shifuMouseDownCard('shifu_c_040')" style="padding: 20px 8px 15px; color: rgb(62, 62, 62); font-size: 1em; white-space: normal; width: 670px; text-decoration: inherit; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><section class="" style="padding: 5px 5px 5px 10px; line-height: 1.5em; font-family: 微软雅黑; border-left-width: 3px; border-left-style: solid; border-color: rgb(6, 167, 225); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">单体应用 VS 微服务</strong><span style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">&nbsp;</span></section></section><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">让我们先从运维的真实场景出发，来看一下单体应用存在的问题。这里先分享两个真实的生产案例。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">案例一是某核心业务系统，所有的业务逻辑代码都打包在同一个 WAR 包里部署，运行了将近几百个同构的实例在虚拟机上。某次因为应用包中的一个功能模块出现异常，导致实例挂起，整个应用都不能用了。因为它是一个单体，所以尽管有几百个实例在运行，但是这几百个实例都是异常的。业务系统是经过多年建设起来的，排查起来也很复杂，最终整个业务系统瘫痪了近六个小时才恢复。同时，因为有多个前台系统也调用了这个后台系统，导致所有要调用的前台系统也都全部瘫痪了。设想一下，如果这个场景使用的是微服务架构，每个微服务都是独立部署的，那影响的也只是有异常的微服务和其他相关联的服务，而不会导致整个业务系统都不能使用。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">另外的案例是一个客服系统，这个系统有一个特点，早上八点的时候会有大量的客服登录。这个登录点是全天中业务并发量最高的时间点，登录时系统需要读取一些客户信息，加载到内存。后来一到早上客服登录时，系统经常出现内存溢出，进而导致整个客服系统都用不了。当时系统应对这种场景做架构冗余时，并不是根据单独的业务按需进行扩展，而是按照单体应用的长板进行冗余。比如说早上八点并发量最高，单点登陆模块业务需求非常大，为适应这个时间点这个模块的业务压力，系统会由原来的八个实例扩展到十六个实例，这时的扩展是基于整个系统的。但事实上，在其他时间段，这个单点登陆模块基本不使用，且监控的数据显示，主机的资源使用情况基本在&nbsp;40%&nbsp;以下，造成了很大的资源浪费。所以在一个大型的业务系统中，每个服务的并发压力不一样，如果都按压力最大的模块进行整体扩展，就会造成资源的浪费，而在微服务的模式下，每个服务都是按自身压力进行扩展的，就可以有效的提高资源利用率。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">从这两个例子中，我们可以看出，单体应用存在如下两个问题：一个是横向扩展时需要整体扩展，资源分配最大化，不能按需扩展和分配资源；另一个是如果单体中有一个业务模块出现问题，就会是全局性灾难，因为所有业务跑在同一个实例中，发生异常时不具备故障隔离性，会影响整个业务系统，整个入口都会存在问题。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">因此，我们当时考虑把综合业务拆分，进行更好的资源分配和故障隔离。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/d50c710901310a299d2b6b96f0ca8e9991567e00.jpeg" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 402px !important; height: 280px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 1&nbsp;</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">下面我们看一下单体应用和微服务的对比，如图 1 所示。这里从微服务带来的好处和额外的复杂性来讲。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">微服务的好处：</span></strong></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><ol class="list-paddingleft-2" style="color: rgb(62, 62, 62); font-size: 18px; white-space: normal; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><li><p style="min-height: 1em; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">局部修改，局部更新。当运维对一个单体应用进行修改时，可能要先把整个包给停了，然后再去修改，而微服务只需逐步修改和更新即可。</span></p></li><li><p style="min-height: 1em; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">故障隔离，非全局。单体应用是跑在一起，所以只要一个模块有问题，其他就都会有问题。而微服务的故障隔离性、业务可持续性都非常高。</span></p></li><li><p style="min-height: 1em; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">资源利用率高。单体应用的资源利用率低，而使用微服务，可以按需分配资源，资源利用率会非常高。</span></p></li></ol><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">&nbsp;</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">微服务带来的复杂性：</span></strong></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><ol class="list-paddingleft-2" style="color: rgb(62, 62, 62); font-size: 18px; white-space: normal; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><li><p style="min-height: 1em; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">微服务间较强的依赖关系管理。以前单体应用是跑在一起，无依赖关系管理，如果拆成微服务依赖关系该如何处理，比如说某个微服务更新了会不会对整个系统造成影响。</span></p></li><li><p style="min-height: 1em; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">部署复杂。单体应用是集中式的，就一个单体跑在一起，部署和管理的时候非常简单，而微服务是一个网状分布的，有很多服务需要维护和管理，对它进行部署和维护的时候则比较复杂。</span></p></li><li><p style="min-height: 1em; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">如何更好地利用资源。单体应用在资源分配时是整体分配，扩展时也是整体扩展，数量可控，而在使用微服务的情况下，需要为每一个微服务按需分配资源，那么该为每个微服务分配多少资源，启动多少个实例呢，这也是非常大的问题。</span></p></li><li><p style="min-height: 1em; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">监控管理难。以前我们用 Java ，就是一个单体应用，监控和管理非常简单，因为它就是一个 1 ，但是使用微服务它就是 N 个，监控管理变得非常复杂。另外是微服务之间还有一个协作的问题。</span></p></li></ol><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p><br></p><section label="Copyright © 2015 playhudong All Rights Reserved." donone="shifuMouseDownCard('shifu_c_040')" style="padding: 20px 8px 15px; color: rgb(62, 62, 62); font-size: 1em; white-space: normal; width: 670px; text-decoration: inherit; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><section class="" style="padding: 5px 5px 5px 10px; line-height: 1.5em; font-family: 微软雅黑; border-left-width: 3px; border-left-style: solid; border-color: rgb(6, 167, 225); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">基于容器构建微服务架构</strong></section></section><p><br></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">使用微服务，第一步是要构建一个一体化的 DevOps 平台，如图 2 。如果你不使用 DevOps 做微服务的话，整个环境会变得非常的乱、非常的糟糕。它会给你的整个开发、测试和运维增加很多成本，所以第一步我们是提高 DevOps 的能力，能够把它的开发、部署和维护进行很完美的结合，才可以说我们真正能够享受到微服务架构的福利。</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/eaf14050943f25f5691f7d886bbed35ed17883f1" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; width: 479px !important; height: 306px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 2</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">容器的出现给微服务提供了一个完美的环境，因为我们可以：</span></p><ol class="list-paddingleft-2" style="color: rgb(62, 62, 62); font-size: 18px; white-space: normal; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><li><p style="min-height: 1em; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">基于容器做标准化构建和持续集成、持续交付等。</span></p></li><li><p style="min-height: 1em; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">基于标准工具对部署在微服务里面的容器做服务发现和管理。</span></p></li><li><p style="min-height: 1em; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">透过容器的编排工具对容器进行自动化的伸缩管理、自动化的运维管理。</span></p></li></ol><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">所以说，容器的出现和微服务的发展是非常相关的，它们共同发展，形成了一个非常好的生态圈。下面详细讲下&nbsp;DevOps 的各个模块。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">持续集成与持续发布</span></strong></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></strong></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">持续集成的关键是完全的自动化，读取源代码、编译、连接、测试，整个创建过程自动完成。我们来看一下如何用 Docker ,&nbsp; Maven ,&nbsp; Jenkins 完成持续集成。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/d5e5558480702f80615ae2ea56e6b7340abfce5d" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; width: 515px !important; height: 381.586px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 3</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">如图 3 所示。首先是开发人员把程序代码更新后上传到&nbsp;Git&nbsp;，然后其他的事情都将由&nbsp;Jenkins&nbsp;自动完成。那&nbsp;Jenkins&nbsp;这边发生什么了呢？Git&nbsp;在接收到用户更新的代码后，会把消息和任务传递给&nbsp;Jenkins&nbsp;，然后&nbsp;Jenkins&nbsp;会自动构建一个任务，下载&nbsp;Maven&nbsp;相关的软件包。下载完成后，就开始利用&nbsp;Maven Build&nbsp;新的项目包，然后重建&nbsp;Maven&nbsp;容器，构建新的&nbsp;Image&nbsp;并&nbsp;Push&nbsp;到&nbsp;Docker&nbsp;私有库中。然后删除正在运行的&nbsp;Docker&nbsp;容器，再基于新的镜像重新把&nbsp;Docker&nbsp;容器拉起来，自动完成集成测试。整个过程都是自动的，这样就简化了原本复杂的集成工作，一天可以集成一次，甚至是多次。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">依赖关系管理</span></strong></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">前面讲到，当微服务多的时候，依赖关系管理也会比较复杂，现在比较流行的是基于消费者驱动的契约管理 。在开发一个微服务时，并不需要另外一个微服务开发完后再做集成测试，而是使用契约的方式。契约通过提供标准化的输出，说明请求的内容、回复的内容、交换的数据，开发微服务时符合契约里这些条件即可。</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/a8ec087c6c313910e49785b7943dbbb8ebc72b27.png" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 542px !important; height: 365.003px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图&nbsp;4&nbsp;</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">如图 4 所示，微服务 A 通过模拟与微服务Ｂ的交互，将交互内容保存在契约里，而微服务 B 开发时需满足这个契约里的条件，这样就不需要 A 和 B 完全完成了才能做测试。当很多微服务与微服务 B 关联时，每个微服务通过契约告诉微服务Ｂ请求的内容、正确的响应和请示的数据，然后微服务Ｂ通过契约模拟这个测试过程，而其他的微服务则需要满足这个契约。当微服务进行升级时，也是要先满足所有契约，这样微服务间的关系就可以更好的进行管理。</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">典型的微服务架构</span></strong></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 5 是典型的微服务架构模型，采用的是&nbsp;Kubernetes&nbsp;框架。把业务系统拆分成很多的微服务，然后通过服务注册的方式去发现整个生产环境中所有的微服务，通过负载均衡组件进行分发，再用服务调度去进行弹性伸缩，而客户端则只需要通过 API 网关访问微服务。除此之外，微服务的运维也很重要。开发是实现功能性需求，而在实际的生产环境中，我们更应该关心非功能性的需求。因为即使功能实现了，跑到生产上却不能用，功能开发再完美也没有用。</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/13ea6a3b07f04442dc1562e4de0b75d878389356.png" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 610px !important; height: 352.656px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图&nbsp;5</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">服务发现与负载均衡</span></strong></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">服务发现与负载均衡使用的是&nbsp;Kubernetes&nbsp;的架构，如图&nbsp;6&nbsp;。每一个微服务都有一个 IP 和 PORT ，当调用一个微服务时，只需要知道微服务的 IP&nbsp;，而不需要关心容器的 IP ，也不需要关心 pod 的&nbsp;IP&nbsp;。虽然每个&nbsp;pod&nbsp;也有&nbsp;IP 和 PORT，但当一个 pod&nbsp;启动时，就会把&nbsp;pod&nbsp;的IP 和 PORT&nbsp;注册到服务发现模块，再进行负载均衡。所以当多个&nbsp;pod&nbsp;启动时，对于用户来说还是只需要知道&nbsp;service&nbsp;的 IP ，不需要知道后端启动了多少&nbsp;pod&nbsp;、IP是多少，这就解决了网络的问题。</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/76be9dc5628c5d770346c4e035e538d8fcf9a4b0" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; width: 444px !important; height: 317.282px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 6</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">日志集中式管理</span></strong></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/694b73fb47b6594498f15e4a4f0d665593c4684e.png" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 523px !important; height: 325.241px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 7</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">以前单体的情况下，单体的数量少，日志数量也相应比较少，而在微服务架构下，因为拆分成了很多微服务，相应的日志会非常多且散，这种情况下需要对日志进行集中的管理。我们可以在每个容器里跑日志监控，把所有日志采集进行集中管理和存储，再通过简易操作的&nbsp;UI&nbsp;界面进行索引和查询。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">监控管理</span></strong></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/5687050cd73fc421ed3903af38c830edaed39da4.png" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 610px !important; height: 427.953px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 8&nbsp;</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">然后就是监控方面了。微服务的量是非常大的，这个时候如何有效地监控是极其重要的。我们刚开始做监控的时候，有几百个实例对同一个关键字进行监控，出故障后会收到几百条短信，因为每一个实例都会发一条短信。这时候严重的致命性的报警就会看不到，因为手机信息已经爆炸了，所以要对报警进行分级，精确告警，最重要的是尽量让故障在发生之前灭亡。因此，在做监控时要对故障提前进行判断，先自动化处理，再看是否需要人为处理，然后通过人为的干预，有效的把故障在发生之前进行灭亡。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">但如果所有事情都靠人为去处理，这个量也是非常大的，所以对故障进行自动化隔离和自动化处理也很重要。我们在写自动化故障处理的时候研究了很多常见的故障，写了很多算法去判断，精确到所有的故障，这样基本的常见的故障和可以策划处理的故障都可以自动化处理掉。之前没有出现的故障，出现之后我们就会去研究是否可以做成自动化处理。如果生产上做的不精确，对生产会是灾难性的，所以我们对生产的故障自动化处理也做了很多研究。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p><br></p><section label="Copyright © 2015 playhudong All Rights Reserved." donone="shifuMouseDownCard('shifu_c_040')" style="padding: 20px 8px 15px; color: rgb(62, 62, 62); font-size: 1em; white-space: normal; width: 670px; text-decoration: inherit; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><section class="" style="padding: 5px 5px 5px 10px; line-height: 1.5em; font-family: 微软雅黑; border-left-width: 3px; border-left-style: solid; border-color: rgb(6, 167, 225); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">七牛的微服务架构实践</strong><span style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">&nbsp;</span></section></section><p><br></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">前面讲了很多运维，下面来了解一下 Docker 和微服务在七牛云中的实践，以七牛的文件处理服务架构演变为例。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">文件处理服务是指，用户把原图存到七牛的云存储之后，然后使用文件处理服务，就可以把它变成自己想要的服务，比如剪裁、缩放和旋转等，如图 9 。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/381caae0a2a21bb09d53bd1a60e0d964cc8864da.png" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 355px !important; height: 278.453px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 9</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">过去为适应不同的场景，用户需要针对同一图片自行处理后上传所有版本，但如果使用七牛的文件处理服务，则只需提供原图就可以了，其他版本的图片都可以通过七牛进行处理。如图 10 所示，我们把一张原图放进去之后，只需要在原图后面加一个问号和参数，就可以呈现出想要的方式，比如说加水印、旋转、缩放和剪裁。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/938d3d5c8c5762dfa445d478c4756b399554d5ca" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; width: 431px !important; height: 308.378px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 10&nbsp;</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">文件处理服务的架构在早期是非常笨拙的,&nbsp;如图 11 所示。FopGate&nbsp;是业务的入口，通过&nbsp;work config&nbsp;静态配置实际进行计算的各种 worker 集群的信息，里面包含了图片处理、视频处理、文档处理等各种处理实例。集群信息在入口配置中写死了，后端配置变更会很不灵活，因为是静态配置，突发请求情况下，应对可能不及时，且&nbsp;FopGate&nbsp;成为流量穿透的组件（业务的指令流与数据流混杂在一起），比如说要读一张图片，这张图片会经过 FopGate 导过来。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/c081dcc241f8c05157f188d4abf192897f541da9.png" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 610px !important; height: 457.5px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 11</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">于是，我们自己组建了一个叫 Discovery 的服务，由它进行负载均衡和服务发现，用于集群中 worker 信息的自动发现，每个 worker 被添加进集群都会主动注册自己，FopGate&nbsp;从 Discovery 获取集群信息，完成对请求的负载均衡。同时在每个计算节点上新增 Agent 组件，用于向 Discovery 组件上报心跳和节点信息，并缓存处理后的结果数据（将数据流从入口分离），另外也负责节点内的请求负载均衡（实例可能会有多个）。此时业务入口只需负责分发指令流，但仍然需要对请求做节点级别的负载均衡。这是第二个阶段，如图 12 。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/71f39e781be4e92355337d14a63ff62eaa1e87a7.png" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 610px !important; height: 448.922px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 12</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">在第三个阶段，我们把文件处理架构迁移到了容器平台上，取消了业务的 Discovery 服务，转由平台自身的服务发现功能。每个 Agent 无需和 Discovery 维护心跳，也不再需要上报节点信息，每个 Agent 对应一个计算 worker，并按工种独立成 Service，比如 Image Service，Video Service，由于后端只有一个 worker&nbsp;，因此也不需要有节点内的负载均衡逻辑，业务入口无需负载均衡，只需请求容器平台提供的入口地址即可，如图 13 所示。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/01479cabdffdd902f22c1b2f5a2a05064b29305c.png" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 610px !important; height: 457.5px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 13</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">上一个阶段中，每个 Agent 仍然和计算实例绑定在一起，而这么做其实只是为了方便业务的无痛迁移，因为 Agent 本身的代码会有一些逻辑上的假设。在第四阶段中，如图 14 ，我们进一步分离了 Agent 和 worker，Agent 独立成一个 Service，所有的 worker 按工种独立成 Service。这么分离的目的在于，Agent 可能会有文件内容缓存，属于有状态的服务，而所有的 worker 是真正干活、无状态的服务。分离之后的好处在于，worker 的数量可以随时调整和伸缩，而不影响 Agent 中携带的状态。可以看到，相比于最早的架构，业务方只需集中精力开发业务本身，而无需重复造轮子，实现各种复杂的服务发现和各种负载均衡的代码。另外，自从部署到容器平台之后，平台的调度器会自动根据节点的资源消耗状况做实例的迁移，这样使得计算集群中每个节点的资源消耗更加均衡。&nbsp;&nbsp;&nbsp;</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/e09e509df3b84b929dda127cfc861c1a4266eb57.png" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 610px !important; height: 459.406px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 14</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">踩过的那些坑</span></strong></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><ul class="list-paddingleft-2" style="color: rgb(62, 62, 62); font-size: 18px; white-space: normal; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><li><p style="min-height: 1em; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">数据库连接风暴</span></inherit></p></li></ul><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/5547f11f4eb283ec20e6002407c3d1ba3a309bd5.png" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 494px !important; height: 369.728px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 15</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 15 所示的是单体应用访问后端数据库使用的数据库连接池，连接池里的连接是可以复用的，而单体中所有的业务模块都可以调用同一个池里的连接。这个数据库连接池可以进行动态的伸缩，但它连接到后端数据库的连接是有上限的。拆分成微服务之后，可能每一个微服务都要创建一个数据库连接池，微服务间的数据库连接池并不能共享。当对微服务进行弹性伸缩时，并不知道它会弹性到什么程度，这时就可能会对后端数据库造成连接风暴，比如原本只有五千个长连接，但是由于弹性伸缩（可能根据前台业务情况进行了非常大的伸缩），会对数据库发生连接风暴，对数据库造成非常大的压力。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">为了确保不会因某个服务的连接风暴把数据库拖垮，对其他服务造成影响，我们做了一些优化。首先是优化了我们的一些弹性算法，其次是限定了容器弹性伸缩的范围，因为没有限制的伸缩，可能会对后端数据库造成压力。另外一个是降低连接池初始化的大小，比如初始化设定为 10 ，它往数据库里面的长连接就是 100 个，如果设定为 1 ，往数据库里面长连接就只有 10 个&nbsp;，如果太多则可能会对数据库造成压力。还有就是数据库端进行一些限定，当连接达到一定数量就进行预警，限制弹性扩展。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><ul class="list-paddingleft-2" style="color: rgb(62, 62, 62); font-size: 18px; white-space: normal; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><li><p style="min-height: 1em; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">单体应用如何改造成微服务？</span></p></li></ul><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">我在传统企业工作了七八年，我们一直在探讨单体应用如何拆分成微服务。其实对传统企业来讲，他们的单体是非常大的，而且内部的耦合性是非常强的，内部调用非常多。如果我们冒冒失失地将单体拆分成微服务，会占用非常大的网络传输。如果在拆成微服务的时候，没有进行很好的架构设计，拆成微服务并不是享受它带来的好处，而是灾难。所以在拆的时候，比如说前端、后端的拆分、耦合性不是特别强的拆分，我们提倡先跑到容器里面，看一下运维容器的时候有什么坑，然后解决这些坑，然后不断完善。我们可以把耦合性不是那么高的拆成大的块，然后把信息密集型的进行拆分，慢慢拆分成我们理想的架构。这是一个循序渐进的过程，不可一蹴而就。</span></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><img src="/noellachen/images/c185e3bf01e9754886a6bdb72c53df8a3c119014.png" style="border: 0px; cursor: default; box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 437px !important; height: 317.508px !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; text-align: center; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 15px; color: rgb(136, 136, 136); max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 16&nbsp;</span></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><inherit style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><br style="max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"></inherit></p><p style="min-height: 1em; color: rgb(62, 62, 62); font-size: 18px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"><span style="font-size: 16px; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;">图 16 是微服务的一些设计准则，例如设计提倡最小化功能，小到不能再小。这时需要每一个服务标准化的提供出来，有一个标准化的接口和其他微服务进行通信。还需要是异步通信，如果是同步会造成堵塞。每个微服务都要有独立的数据存储。此外，服务还需要是无状态的，因为如果有状态，弹性伸缩时可能会有数据丢失，可以用一些其他的方法处理这些有状态的数据。</span></p><p><br></p>
{% endraw  %}

