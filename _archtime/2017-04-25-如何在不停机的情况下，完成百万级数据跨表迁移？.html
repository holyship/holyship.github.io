---
title: 如何在不停机的情况下，完成百万级数据跨表迁移？
author: Jacqueline Xu
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1493342526&src=3&ver=1&signature=L9XD8GAQyzHEmNm3CARkqcMusoI8ojEbzXFzYhHiUnQ5M1bhzDS*Wldo9ZnBHHO1cRF2e*cXWv4OEZy-4X8cpCSzVF4ogB5i6AJ2HLwQiybpUbu6RXwLME3CPuSpNECtPqxeYGgu1ve05fFZJqA3BNjpQeUlTYL1iJLRPn9ZJFU=
date: '2017-04-25 00:00:00 +0000'

---

{% raw  %}
<section style="color: rgb(63, 63, 63); font-size: 14px; font-family: Avenir, -apple-system-font, 微软雅黑, sans-serif; text-align: center; box-sizing: border-box;"><section class="" style="box-sizing: border-box; text-align: left;">
		<img src="/archtime/images/9fadf19027a2d982855628ae96b7176e83102a00.jpeg" style="border-radius: 4px; margin-bottom: 25px; width: 770px !important; height: 512.531px !important; visibility: visible !important;">
	</section><section class="" style="box-sizing: border-box; color: rgb(145, 145, 145); text-align: left; line-height: 1em; margin-top: 13px; padding-left: 14px;">
		作者｜Jacqueline Xu	</section><section class="" style="box-sizing: border-box; color: rgb(145, 145, 145); text-align: left; line-height: 1em; margin-top: 13px; padding-left: 14px;">
		编辑｜足下	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">技术团队面临的困难总是相似的：在业务发展到一定的时候，他们总是不得不重新设计数据模型，以此来支持更加复杂的功能。在生产环境中，这可能意味着要迁移几百万条活跃的数据，以及重构数以千行计的代码。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">Stripe的用户希望我们提供的API要具备可用性和一致性。这意味着在做迁移时，我们必须非常小心：存储在我们系统中的数据要有非常准确的值，而且Stripe的服务必须时刻保证可用。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">在这篇文章中，我们将分享我们是如何安全地完成了一次涉及上亿数据量的大迁移经历。</p><section class="" style="box-sizing: border-box; font-size: 20px;">
		<span style="margin-top: 38px; margin-bottom: 10px; height: 65px; line-height: 96px; color: rgb(60, 112, 198); background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0mibNX3qmFN7yvk787nW8d7gnP5z3M3vq8vzRZLQNicmvtdduXzmtLgTA/0?wx_fmt=png&quot;); background-position: 50% 50%; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; border-bottom: 2px solid rgb(27, 95, 160); background-size: 55px; display: inline-block;">为什么迁移总是这么难？</span>
	</section><section class="" style="box-sizing: border-box; font-size: 16px; text-align: left; margin-top: 30px; margin-left: 8px; color: rgb(60, 112, 198);"><span style="display: inline-block; width: 15px; height: 15px; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0fjar4tevccMUqPqlCY94AGCdqtLcdwFMk9ZI9OIicict3ICr5BKbl5tw/0?wx_fmt=png&quot;); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 100% 100%; margin-right: 10px;"></span>
		规模	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">Stripe有上亿规模的订阅数据。对于我们的生产数据库来说，做一次与所有这些数据都相关的大型迁移就意味着非常非常多的工作。想象一下，假如以一种顺序的方式，每迁移一条订阅数据要一秒钟，那要完成上亿条数据的迁移就要耗时超过三年。</p><section class="" style="box-sizing: border-box; font-size: 16px; text-align: left; margin-top: 30px; margin-left: 8px; color: rgb(60, 112, 198);"><span style="display: inline-block; width: 15px; height: 15px; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0fjar4tevccMUqPqlCY94AGCdqtLcdwFMk9ZI9OIicict3ICr5BKbl5tw/0?wx_fmt=png&quot;); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 100% 100%; margin-right: 10px;"></span>
		不能停机	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">Stripe上的业务一直在运行。我们升级所有东西都是不停机操作的，而不是可以在某个计划好的维护窗口内更新。因为在迁移过程中我们不能简单地中止订阅服务，所以我们必须100%地在所有服务都在线的情况下完成迁移操作。</p><section class="" style="box-sizing: border-box; font-size: 16px; text-align: left; margin-top: 30px; margin-left: 8px; color: rgb(60, 112, 198);"><span style="display: inline-block; width: 15px; height: 15px; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0fjar4tevccMUqPqlCY94AGCdqtLcdwFMk9ZI9OIicict3ICr5BKbl5tw/0?wx_fmt=png&quot;); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 100% 100%; margin-right: 10px;"></span>
		数据准确	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们很多的业务都用到了订阅数据表。如果我们想要一次改动订阅服务的几千行代码的话，那可以肯定地说我们一定会遗漏某些特殊场景。我们必须确保每个服务都能持续地操作准确的数据。</p><section class="" style="box-sizing: border-box; font-size: 20px;">
		<span style="margin-top: 38px; margin-bottom: 10px; height: 65px; line-height: 96px; color: rgb(60, 112, 198); background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0mibNX3qmFN7yvk787nW8d7gnP5z3M3vq8vzRZLQNicmvtdduXzmtLgTA/0?wx_fmt=png&quot;); background-position: 50% 50%; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; border-bottom: 2px solid rgb(27, 95, 160); background-size: 55px; display: inline-block;">在线迁移的模式</span>
	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">把数以百万计的数据从一张数据库表迁移到另一张中，这很困难，但对于许多公司来说这又是不得不做的事。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">在做类似的大型迁移时，有种大家非常容易接受的四步双写模式。这里是具体的步骤。</p><ol style="margin-top: 10px; line-height: 1em; text-align: left;" class="list-paddingleft-2"><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">向旧表和新表双重写入，以保持它们之间数据的同步；</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">把代码库中所有读数据的操作都指向新表；</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">把代码库中所有写数据的操作都指向新表；</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">把依赖旧数据模型的旧数据删掉。</p></li></ol><section class="" style="box-sizing: border-box; font-size: 20px;">
		<span style="margin-top: 38px; margin-bottom: 10px; height: 65px; line-height: 96px; color: rgb(60, 112, 198); background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0mibNX3qmFN7yvk787nW8d7gnP5z3M3vq8vzRZLQNicmvtdduXzmtLgTA/0?wx_fmt=png&quot;); background-position: 50% 50%; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; border-bottom: 2px solid rgb(27, 95, 160); background-size: 55px; display: inline-block;">我们的迁移案例</span>
	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">Stripe的订阅功能帮助像DigitalOcean和Squarespace这样的客户构建和管理他们用户的计费账单。在过去的几年里，我们持续不断地增加了许多功能，来支持他们越来越复杂的计费模型，比如多重订阅、试用、优惠券和发票等。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">在最开始时，每个Customer对象最多只会有一条订阅数据。所以我们的客户数据都保存成了单条记录。因为用户和订阅之间的映射关系非常直接，所以订阅信息就和用户数据保存在了一起。</p><pre style="margin: 30px 8px 0px; text-align: left; background-color: rgb(50, 50, 50); color: rgb(97, 180, 146);"><code style="color: #5BACEB;">class Customer
 &nbsp;Subscription subscription
end</code></pre><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">后来，我们发现有些客户希望他们创建的Customer对象可以对应多条订阅数据。于是我们决定把服务于单次订阅的单条订阅数据升级一下，换成一个订阅数组，以此来保存多条有效的订阅数据。</p><pre style="margin: 30px 8px 0px; text-align: left; background-color: rgb(50, 50, 50); color: rgb(97, 180, 146);"><code style="color: #5BACEB;">class Customer
 &nbsp;array: Subscription subscriptions
end</code></pre><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">在继续添加新功能的时候，这样的数据模型就出问题了。每一次对用户的订阅信息的改动都意味着要更新整条用户记录，以及查询用户数据的与订阅相关的检索语句。于是我们决定把这些订阅信息单独保存起来。</p><p><img src="/archtime/images/14f7387430d308ca29cb7bd9d6ebb8d4fd439320.jpeg" style="width: 770px !important; height: 343.75px !important;"></p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们重新设计的数据模型把订阅信息移到了它们自己的表里。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">复习一下，我们的四步迁移流程为：</p><ol style="margin-top: 10px; line-height: 1em; text-align: left;" class="list-paddingleft-2"><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">向旧表和新表<strong style="text-align: left;">双重写入</strong>，以保持它们之间数据的同步；</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">把代码库中所有<strong style="text-align: left;">读数据的操作</strong>都指向新表；</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">把代码库中所有<strong style="text-align: left;">写数据的操作</strong>都指向新表；</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">把依赖旧数据模型的<strong style="text-align: left;">旧数据删掉</strong>。</p></li></ol><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">接下来我们看看这理论上的四个阶段在我们的实际项目中是怎样实施的。</p><section class="" style="box-sizing: border-box; font-size: 16px; text-align: left; margin-top: 30px; margin-left: 8px; color: rgb(60, 112, 198);"><span style="display: inline-block; width: 15px; height: 15px; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0fjar4tevccMUqPqlCY94AGCdqtLcdwFMk9ZI9OIicict3ICr5BKbl5tw/0?wx_fmt=png&quot;); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 100% 100%; margin-right: 10px;"></span>
		第一部分：双重写入	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们在迁移之前先创建了一张新的数据表。第一步就是开启复制新写入的数据，这样它就可以写到新旧两张表里了。然后我们再把新数据表中缺失的数据慢慢地补充过来，这样新旧两张表里的数据就完全一致了。</p><p><img src="/archtime/images/aaf82fffe97e5fda1f10f28debf43464dd1ac389.jpeg" style="width: 770px !important; height: 478.226px !important;"></p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">所有新的写入都要更新两张数据表。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">在这个案例中，我们会把所有新生成的订阅信息都同时写入用户表和订阅表。在开始双重写入两张表之前，一定要认真考虑一下这一份额外的写入操作给生产库的性能带来的影响。有种减轻性能影响的方法就是慢慢地增大开启复制的数据量，这同时一定要仔细地盯着各项运营指标。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">到了这一步，所有新创建的数据就都同时存在于新旧两张表里了，而比较旧的数据只保存在旧表中。于是我们可以以一种缓慢的模式开始拷贝已有的订阅信息：每当有数据被更新的时候，就自动地把它们也拷到新的表中。这种方法让我们可以开始增量地迁移已有的订阅数据。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">最终，我们会把所有已有的用户订阅信息都补充到新的订阅表中去。</p><p><img src="/archtime/images/b095ad2dd591d3f5fb0306e48c00e8fc83f6330e.jpeg" style="width: 770px !important; height: 350.37px !important;"><img src="/archtime/images/b870cde20047341baa0a7430f9b22ca9c0a7175b.other" style="color: rgb(74, 74, 74); font-size: 16px; text-align: justify; white-space: pre-line; width: 770px !important; height: 11.1433px !important;"></p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们会把所有已有的用户订阅信息都补充到新的订阅表中去。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">在生产数据库里补充新数据表的操作，代价最大的部分其实就是要找出所有需要迁移的数据而已。通过检索数据库来找出所有这样的数据需要检索生产库很多次，这会花费很多时间。幸运的是，我们可以把这个代价转用一个离线的方式完成，因此对生产库就毫无影响了。我们会为数据生成快照，并上传到Hadoop集群中，然后就可以用MapReduce的方法来快速地以离线、并行、分布式的方式处理数据了。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们用Scalding来管理我们的MapReduce任务。Scalding是一个用Scala写成的非常有用的库，用它来写MapReduce任务非常容（写一个简单任务的话连十行代码都不用）。在这个案例中，我们用Scalding来找出所有的订阅数据。具体步骤如下：</p><ul style="margin-top: 10px; line-height: 1em; text-align: left;" class="list-paddingleft-2"><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">写个Scalding任务来生成所有需要迁移的订阅数据的ID列表；</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">做一次大型的、多线程的迁移操作，来并行地把所有需要迁移的订阅数据快速拷贝过去；</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">当迁移结束之后，再运行一次Scalding任务，确保所有旧订阅表中的订阅数据都迁移到了新表里，没有遗漏；</p></li></ul><section class="" style="box-sizing: border-box; font-size: 16px; text-align: left; margin-top: 30px; margin-left: 8px; color: rgb(60, 112, 198);"><span style="display: inline-block; width: 15px; height: 15px; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0fjar4tevccMUqPqlCY94AGCdqtLcdwFMk9ZI9OIicict3ICr5BKbl5tw/0?wx_fmt=png&quot;); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 100% 100%; margin-right: 10px;"></span>
		第二部分：切换所有的读操作	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">现在新旧两张数据表中的数据都处于同步状态了，下一步就是把所有的读操作都迁移到新数据表上来。</p><p><img src="/archtime/images/919eb38c7016605ba85db7903ff07bfe3efd8082.jpeg" style="width: 770px !important; height: 517.186px !important;"><img src="/archtime/images/b870cde20047341baa0a7430f9b22ca9c0a7175b.other" style="color: rgb(74, 74, 74); font-size: 16px; text-align: justify; white-space: pre-line; width: 770px !important; height: 11.1433px !important;"></p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">到这一步时，所有的读操作都仍然在使用旧的用户表：我们要切换到新的订阅表上来。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们要很确信可以从新的订阅表中正常读出数据，这也意味着我们的订阅数据必须是一致的。我们用GitHub的Scientist来帮我们做验证。Scientist是一个Ruby库，可以让我们执行测试，比较两段不同的代码的执行结果，如果在生产环境中两种表述会产生不同的结果，它就会发出警告。有了Scientist，我们就可以实时地为不同的结果产生告警和获得指标。万一测试用的代码产生了错误也没有关系，我们的程序的其它部分并不会受到影响。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们会做下面的验证：</p><ul style="margin-top: 10px; line-height: 1em; text-align: left;" class="list-paddingleft-2"><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">用Scientist去分别从订阅表和用户表中读出数据；</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">如果结果不同，就抛出错误，提醒技术人员数据不一致；</p></li></ul><p><img src="/archtime/images/4bff24e7ceb1cd2bd30405f695c704db0dda3ea3.jpeg" style="width: 770px !important; height: 497.793px !important;"></p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">GitHub的Scientist让我们可以同时从两张表中读出数据，并且比较结果。如果验证通过，所有数据都能对得上，我们就可以从新表中读入数据了。</p><p><img src="/archtime/images/e3549fed9d95bee244e03d74e1bee5e8b0b92535.jpeg" style="width: 770px !important; height: 506.816px !important;"><img src="/archtime/images/b870cde20047341baa0a7430f9b22ca9c0a7175b.other" style="color: rgb(74, 74, 74); font-size: 16px; text-align: justify; white-space: pre-line; width: 770px !important; height: 11.1433px !important;"></p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们的验证很成功：所有的读操作都使用新的订阅表了。</p><section class="" style="box-sizing: border-box; font-size: 16px; text-align: left; margin-top: 30px; margin-left: 8px; color: rgb(60, 112, 198);"><span style="display: inline-block; width: 15px; height: 15px; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0fjar4tevccMUqPqlCY94AGCdqtLcdwFMk9ZI9OIicict3ICr5BKbl5tw/0?wx_fmt=png&quot;); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 100% 100%; margin-right: 10px;"></span>
		第三部分：切换所有写操作	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">接下来，我们要把所有写操作切换到新的数据表上来。我们的目标是渐进式地推进这些变动，因此我们要采用非常细致的战术。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">到目前为止，我们一直在向旧数据表中写入数据，并复制到新表中：</p><p><img src="/archtime/images/fc5610342ed66777c2e005b3c2a453bcaf2bfcfa.jpeg" style="width: 770px !important; height: 110.967px !important;"></p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">现在我们想调换这个顺序：向新数据表中写入数据，并且同步到旧数据表中去。通过保持这两张数据表之间的数据一致，我们就可以不断地做增量更新，并且细致地观察每次改动的影响。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">把所有处理订阅数据的代码都重构掉，这一块应该是整个迁移过程中最有挑战性的了。Stripe处理订阅操作的逻辑分布在若干个服务的几千行代码中。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">成功重构的关键就在于我们的渐进式流程：我们会尽可能地把数据处理逻辑限制到最小的范围内，这样我们就可以很小心地应用每一次改动。在每个阶段里，我们的新旧两张表中的数据都会保持一致。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">对于每一处代码逻辑，我们都会用全面的方法来保证我们的改动是安全的。我们不能简单地用新数据替换旧数据：每一块逻辑都必须经过审重地考虑。不管我们漏掉了哪种特殊情况，都有可能会导致最终的数据不一致。幸运的是，我们可以在整个过程中不断地运行Scientist测试来提醒我们哪里可能会有不一致的情况发生。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们简化了的新写入方式大概是这样的：</p><p><img src="/archtime/images/4b157edd56df359b9c953da52f4703c1814f4608.jpeg" style="width: 770px !important; height: 116.331px !important;"></p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">到最后我们加入逻辑，如果有任何调用这样过期的订阅数据的情况发生，我们都会强制抛出一个错误。这样我们就可以保证再也没有代码会用到它了。</p><p><img src="/archtime/images/d758fc19b906796b0f65b9bfc9dcea0d29b7859e.jpeg" style="width: 770px !important; height: 212.552px !important;"></p><section class="" style="box-sizing: border-box; font-size: 16px; text-align: left; margin-top: 30px; margin-left: 8px; color: rgb(60, 112, 198);">
		第四部分：删除旧数据	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们最后也是最有成就感的一步，就是把写入旧数据表的代码删掉，最后再把旧数据表删掉。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">当我们确认再没有代码依赖已被淘汰的旧订阅数据模型时，我们就再也不用写入旧数据表中了：</p><p><img src="/archtime/images/493d95d3944c302cb324133206dd680fbbb23f4f.jpeg" style="width: 742px !important; height: 166px !important;"></p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">做了这些改动之后，我们的代码就再也不用使用旧数据表了，新的数据表就成了唯一的数据来源。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">然后我们就可以删除掉我们的用户对象中的所有订阅数据了，并且我们会慢慢地渐进式地做删除操作。首先每当我们加载订阅数据时，我们都会自动地清空数据，最后会再运行一次Scalding任务以及迁移操作，来找出所有遗漏的未被删除的数据。最终我们会得到期望的数据模型：</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);"><img src="/archtime/images/b870cde20047341baa0a7430f9b22ca9c0a7175b.other" style="width: 754px !important; height: 10.9117px !important;"></p><p><img src="/archtime/images/0bdbb3795cb7339f9a4d22053d5973bfc8f7e5b5.jpeg" style="width: 770px !important; height: 269.432px !important;"></p><section class="" style="box-sizing: border-box; font-size: 20px;">
		<span style="margin-top: 38px; margin-bottom: 10px; height: 65px; line-height: 96px; color: rgb(60, 112, 198); background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0mibNX3qmFN7yvk787nW8d7gnP5z3M3vq8vzRZLQNicmvtdduXzmtLgTA/0?wx_fmt=png&quot;); background-position: 50% 50%; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; border-bottom: 2px solid rgb(27, 95, 160); background-size: 55px; display: inline-block;">最后的结论</span>
	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">在迁移的同时还要保证Stripe的API是一致的，这事很复杂。我们有下面这些经验可以和大家分享：</p><ul style="margin-top: 10px; line-height: 1em; text-align: left;" class="list-paddingleft-2"><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">我们总结出了四阶段迁移策略，这让我们可以在生产环境中没有任何停机时间就可以完成数据切换操作。</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">我们采用Hadoop用离线的方式进行了数据处理，这让我们可以用MapReduce并行地处理大量数据，而不是依靠对生产库进行代价昂贵的检索操作。</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">我们所有的改动都是渐进式的。每一次我们改动的代码量都绝对不会超过几百行。</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">我们所有的改动都是高度透明和可观测的。哪怕生产环境中有一条数据不一致，Scientist测试都会立刻向我们告警。通过这种办法，我们可以确信我们的迁移操作是安全的。</p></li></ul><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们在Stripe已经做过许多次在线迁移了，经过实践检验这些经验非常有效。希望别的团队在做大规模数据迁移时，我们的这些经验也可以对他们有所帮助。</p><section class="" style="box-sizing: border-box; padding-top: 19px;">
		<h5 style="height: 51px; line-height: 52px; font-size: 18px; margin-top: 38px; color: rgb(60, 112, 198); background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj013rKTSNGxiaa0bX59KlwcGRULWPUJ8AonCpADVs9FAh9WGKLJibFQcqw/0?wx_fmt=png&quot;); background-position: center center; background-size: initial; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="display: inline-block; height: 51px; width: 37%; float: left; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0DNIYS3qJSN01Cny6ZAUOgMJ1LiaDuH1AIlUFdYibgZUqq8KP6xwqMJSQ/0?wx_fmt=png&quot;); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 100%;"></span>今日荐文<span style="display: inline-block; height: 51px; width: 37%; float: right; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0XQkjAq8CViceTgicPXWB6DoibWsvQXfu6zIXuWiclnicvHQibDp9icUia4GkOA/0?wx_fmt=png&quot;); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 100%;"></span></h5>
		<p style="box-sizing: border-box; white-space: pre-line; line-height: 27px; font-size: 15px; color: rgb(200, 199, 199); padding-top: 28px; padding-bottom: 28px;">点击下方图片即可阅读</p>
		
		
		
		
		
		
				<a href="https://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;mid=2659599183&amp;idx=1&amp;sn=55543b71f161474c5bafba0a4e63fdc4&amp;chksm=8be9965dbc9e1f4bccfd249e1b3edc65490f43842a7cb364a541b561d97d42bae01459cb7ac0#rd" style="color: #5BACEB;">
			<img src="/archtime/images/445e62c8455ca3941a877648031f4cf3a63a88e3.jpeg" style="color: inherit; float: left; width: 770px !important; height: 513.734px !important;">
		</a>
		<section class="" style="text-align: left; width: 100%; margin-top: -3em; margin-bottom: 29px; float: left; box-sizing: border-box; background-color: rgba(13, 14, 28, 0.8); max-width: 640px;">
			<section style="text-align: center; color: inherit; box-sizing: border-box;">
				<p style="font-size: 16px; line-height: 27px; text-align: left; color: rgb(255, 255, 255); box-sizing: border-box; white-space: normal; padding-top: 8px; padding-bottom: 8px; padding-left: 13px;"><span style="display: inline-block; width: 22px; height: 18px; background: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg1d1nicXGYKkOKDib39d8abj0J5ea8W3zPNma2Y2tLIfazDHFExG84Bjuibiaog4tjqSO1VEAUgzvPenQ/0?wx_fmt=png&quot;) center center / 100% 100% no-repeat; vertical-align: middle; margin-right: 8px;"></span>
					一篇文章了解Google新开源的操作系统 Fuchsia				</p>
			</section>
		</section>
		<hr style="width: 100%; height: 1px; border-top-style: dotted; border-top-color: rgb(165, 165, 165);">
	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">你竟然一路看到了这里，好感动！那就给你推荐一个座位有限的靠谱“架构课”作为回报吧。5月6日-7日，StuQ工作坊邀请到骨灰级架构师Peter，为你开讲《大型系统架构实践》，你能学到的，比你预想的多！</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">前20位报名，享受7折早鸟票！具体详戳 <span class="" style="text-align: left; color: rgb(91, 172, 235);">「 阅读原文 」</span>惊喜不停！</p><section class="" style="box-sizing: border-box; width: 100%; text-align: left;">
		
		<img src="/archtime/images/d111adf96b39d5f67372aa91f9304a2994f88c5d.jpeg" style="padding-right: 8px; padding-left: 8px; margin-top: 28px; margin-right: auto; margin-left: auto; width: 770px !important; height: 421.235px !important;"></section></section><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1493342526&src=3&ver=1&signature=L9XD8GAQyzHEmNm3CARkqcMusoI8ojEbzXFzYhHiUnQ5M1bhzDS*Wldo9ZnBHHO1cRF2e*cXWv4OEZy-4X8cpCSzVF4ogB5i6AJ2HLwQiybpUbu6RXwLME3CPuSpNECtPqxeYGgu1ve05fFZJqA3BNjpQeUlTYL1iJLRPn9ZJFU=">微信地址</a> | <a href="http://cn.mikecrm.com/1TmWve3?utm_source=liaoliaojiagou"/>阅读原文</a>
{% endraw  %}

