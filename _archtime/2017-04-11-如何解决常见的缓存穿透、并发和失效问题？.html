---
title: 如何解决常见的缓存穿透、并发和失效问题？
author: 程超
date: '2017-04-11 00:00:00 +0000'

---

{% raw  %}
<section style="color: rgb(63, 63, 63); font-size: 14px; font-family: Avenir, -apple-system-font, 微软雅黑, sans-serif; text-align: center; box-sizing: border-box;"><section class="" style="box-sizing: border-box; text-align: left;">
		<img src="/archtime/images/353d6c1291e962856d49161f188f1f9b4e7a4ad8.jpeg" style="border-radius: 4px; margin-bottom: 25px; width: 770px !important; height: 432.227px !important; visibility: visible !important;">
	</section><section class="" style="box-sizing: border-box; color: rgb(145, 145, 145); text-align: left; line-height: 1em; margin-top: 13px; padding-left: 14px;">
		作者｜程超	</section><section class="" style="box-sizing: border-box; color: rgb(145, 145, 145); text-align: left; line-height: 1em; margin-top: 13px; padding-left: 14px;">
		编辑｜Gary	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">在之前的一篇<a href="http://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;mid=2659597537&amp;idx=1&amp;sn=9c91d231315b507b5eaea0e465a01423&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;mid=2659597537&amp;idx=1&amp;sn=9c91d231315b507b5eaea0e465a01423&amp;scene=21#wechat_redirect">缓存穿透、缓存并发、缓存失效之思路变迁</a>文章中介绍了关于缓存穿透、并发的一些常用思路，但是个人感觉文章中没有明确一些思路的使用场景，本文将继续深化与大家共同探讨，同时也非常感谢这段时间给我提宝贵建议的朋友们（注：本文中提到的缓存可以理解为Redis）。</p><section class="" style="box-sizing: border-box; font-size: 20px;">
		<span style="margin-top: 38px; margin-bottom: 10px; height: 65px; line-height: 96px; color: rgb(60, 112, 198); background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg0azGjOwvvcFz3TDpDGKM5jebSJYJibSoyna3xsWFatiahDbG2dtKnf1n9K6NXugToQRX2icphFOTnpw/0?wx_fmt=png&quot;); background-position: 50% 50%; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; border-bottom: 2px solid rgb(27, 95, 160); background-size: 55px; display: inline-block;">缓存穿透与并发方案</span>
	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">相信不少朋友之前看过很多类似的文章，但是归根结底就是二个问题：</p><ul style="margin-top: 10px; line-height: 1em; text-align: left;" class="list-paddingleft-2"><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">如何解决穿透</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">如何解决并发</p></li></ul><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">当并发较高的时候，其实我是不建议使用缓存过期这个策略的，我更希望缓存一直存在，通过后台系统来更新缓存系统中的数据达到数据的一致性目的，有的朋友可能会质疑，如果缓存系统挂了怎么办，这样数据库更新了但是缓存没有更新，没有达到一致性的状态。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);"><strong style="text-align: left;">解决问题的思路是</strong>如果缓存是因为网络问题没有更新成功数据，那么建议重试几次，如果依然没有更新成功则认为缓存系统出错不可用，这时候客户端会将数据的KEY插入到消息系统中，消息系统可以过滤相同的KEY，只需保证消息系统不存在相同的KEY，当缓存系统恢复可用的时候，依次从MQ中取出KEY值然后从数据库中读取最新的数据更新缓存。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">注意：更新缓存之前，缓存中依然有旧数据，所以不会造成缓存穿透。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">下图展示了整个思路的过程：</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);"><img src="/archtime/images/7c6cbb13522eb5ba6a1c9935a53a60a11facb3be.png" style="width: 754px !important; height: 466.385px !important;"></p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">看完上面的方案以后，又会有不少朋友提出疑问，如果我是第一次使用缓存或者缓存中暂时没有我需要的数据，那又该如何处理呢？</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">在这种场景下，客户端从缓存中根据KEY读取数据，如果读到了数据则流程结束，如果没有读到数据（可能会有多个并发都没有读到数据），这时候使用缓存系统中的setNX方法设置一个值（这种方法类似加个锁），没有设置成功的请求则sleep一段时间，设置成功的请求读取数据库获取值，如果获取到则更新缓存，流程结束，之前sleep的请求这时候唤醒后直接再从缓存中读取数据，此时流程结束。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">在看完这个流程后，我想这里面会有一个漏洞，如果数据库中没有我们需要的数据该怎么处理，如果不处理则请求会造成死循环，不断的在缓存和数据库中查询，这时候我们会沿用我之前文章中的如果没有读到数据则往缓存中插入一个NULL字符串的思路，这样其他请求直接就可以根据“NULL”进行处理，直到后台系统在数据库成功插入数据后同步更新清理NULL数据和更新缓存。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">流程图如下所示：</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);"><img src="/archtime/images/758a2b6e15aff1ebb09d68e7b0a6588d0db60edc.png" style="width: 754px !important; height: 770.418px !important;"></p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">在实际工作中，我们往往将上面二个方案组合使用才能达到最佳效果，虽然第二种方案也会造成请求阻塞，但是只是在第一次使用或者缓存暂时没有数据的情况下才会产生，在生产中经过检验在TPS没有上万的情况下是不会造成问题的。</p><section class="" style="box-sizing: border-box; font-size: 20px;">
		<span style="margin-top: 38px; margin-bottom: 10px; height: 65px; line-height: 96px; color: rgb(60, 112, 198); background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg0azGjOwvvcFz3TDpDGKM5jebSJYJibSoyna3xsWFatiahDbG2dtKnf1n9K6NXugToQRX2icphFOTnpw/0?wx_fmt=png&quot;); background-position: 50% 50%; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; border-bottom: 2px solid rgb(27, 95, 160); background-size: 55px; display: inline-block;">热点缓存解决方案</span>
	</section><section class="" style="box-sizing: border-box; font-size: 16px; text-align: left; margin-top: 30px; margin-left: 8px; color: rgb(60, 112, 198);"><span style="display: inline-block; width: 15px; height: 15px; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg0azGjOwvvcFz3TDpDGKM5jQJhfYdpTkbVepRnO4nWygZ1cibKFDibP2KclsFiawV2ic6IO2ms3VQxB6Q/0?wx_fmt=png&quot;); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 100% 100%; margin-right: 10px;"></span>
		1. 缓存使用背景：	</section><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们拿用户中心的一个案例来说明。每个用户都会首先获取自己的用户信息，然后再进行其他相关的操作，有可能会有如下一些场景情况：</p><ul style="margin-top: 10px; line-height: 1em; text-align: left;" class="list-paddingleft-2"><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">会有大量相同用户重复访问该项目。</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">会有同一用户频繁访问同一模块。</p></li></ul><section class="" style="box-sizing: border-box; font-size: 16px; text-align: left; margin-top: 30px; margin-left: 8px; color: rgb(60, 112, 198);"><span style="display: inline-block; width: 15px; height: 15px; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg0azGjOwvvcFz3TDpDGKM5jQJhfYdpTkbVepRnO4nWygZ1cibKFDibP2KclsFiawV2ic6IO2ms3VQxB6Q/0?wx_fmt=png&quot;); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 100% 100%; margin-right: 10px;"></span>
		2. 思路解析	</section><ul style="margin-top: 10px; line-height: 1em; text-align: left;" class="list-paddingleft-2"><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">因为用户本身是不固定的而且用户数量也有几百万尤其上千万，我们不可能把所有的用户信息全部缓存起来，通过第一个场景情况可以看到一些规律，那就是有大量的相同用户重复访问，但是究竟是哪些用户重复访问我们也并不知道。</p></li><li><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; color: rgb(74, 74, 74);">如果有一个用户频繁刷新读取项目，那么对数据库本身也会造成较大压力，当然我们也会有相关的保护机制来确实恶意攻击，可以从前端控制，也可以有采黑名单等机制，这里不在赘述。如果用缓存的话，我们又该如何控制同一用户繁重读取用户信息呢。</p></li></ul><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);"><img src="/archtime/images/1f71e1f6d1f7c605bb941a987572ecc0e4ebaeea.png" style="width: 754px !important; height: 558.203px !important;"></p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">我们会通过缓存系统做一个排序队列，比如1000个用户，系统会根据用户的访问时间更新用户信息的时间，越是最近访问的用户排名越排前，系统会定期过滤掉排名最后的200个用户，然后再从数据库中随机取出200个用户加入队列，这样请求每次到达的时候，会先从队列中获取用户信息，如果命中则根据userId，再从另一个缓存数据结构中读取用户信息，如果没有命中则说明该用户请求频率不高。</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);">Java伪代码如下所示：</p><p style="box-sizing: border-box; font-size: 16px; text-align: justify; white-space: pre-line; line-height: 27px; padding-top: 23px; padding-right: 8px; padding-left: 8px; color: rgb(74, 74, 74);"><img src="/archtime/images/a56c1295de59b0ae1cfc7a836498581c99543cae.png" style="width: 754px !important; height: 457.427px !important;"></p><section class="" style="box-sizing: border-box; padding-top: 19px;">
		<h5 style="height: 51px; line-height: 52px; font-size: 18px; margin-top: 38px; color: rgb(60, 112, 198); background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg0azGjOwvvcFz3TDpDGKM5jgWPdDgGQNVdmNXDw730QXD9NhQIk2kf0ZjBpjBeVdWB19Z4dwgMia4A/0?wx_fmt=png&quot;); background-position: center center; background-size: initial; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="display: inline-block; height: 51px; width: 37%; float: left; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg0azGjOwvvcFz3TDpDGKM5jF1VkKuz3bgqMjulKAPkSlc8o41JYibxyzfVqB08CqvzyWY3atMHYS1Q/0?wx_fmt=png&quot;); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 100%;"></span>今日荐文<span style="display: inline-block; height: 51px; width: 37%; float: right; background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg0azGjOwvvcFz3TDpDGKM5jgmQbMsbYn3JaptRGLjiaCDLAUtJvldKo5vdt8obWOp75LFKtesGkpqg/0?wx_fmt=png&quot;); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 100%;"></span></h5>
		<p style="box-sizing: border-box; white-space: pre-line; line-height: 27px; font-size: 15px; color: rgb(200, 199, 199); padding-top: 28px; padding-bottom: 28px;">点击下方图片即可阅读</p>
		
		
		
		
		
		
				<a href="https://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;mid=2659599129&amp;idx=1&amp;sn=889f72b922ba72613b81c274067b2dce&amp;chksm=8be9960bbc9e1f1d8e311fc0dfb16597307048c9d4552d203c2e907cb8427284556e07009ebe#rd" style="color: #5BACEB;">
			<img src="/archtime/images/e005e6a785d277580ed676457637af645310acf3.jpeg" style="color: inherit; float: left; width: 770px !important; height: 470.495px !important;">
		</a>
		<section class="" style="text-align: left; width: 100%; margin-top: -3em; margin-bottom: 29px; float: left; box-sizing: border-box; background-color: rgba(13, 14, 28, 0.8); max-width: 640px;">
			<section style="text-align: center; color: inherit; box-sizing: border-box;">
				<p style="font-size: 16px; line-height: 27px; text-align: left; color: rgb(255, 255, 255); box-sizing: border-box; white-space: normal; padding-top: 8px; padding-bottom: 8px; padding-left: 13px;"><span style="display: inline-block; width: 22px; height: 18px; background: url(&quot;http://mmbiz.qpic.cn/mmbiz_png/LaW7jDBKBg0azGjOwvvcFz3TDpDGKM5jNuhDFKNXH4nBwJDIwh5GxzV50aT2icNkEwTQoONRT973ORm1k8KDtaQ/0?wx_fmt=png&quot;) center center / 100% 100% no-repeat; vertical-align: middle; margin-right: 8px;"></span>
					从Splunk到ElasticSearch，LinkedIn的实时日志系统架构演进之路				</p>
			</section>
		</section>
		<hr style="width: 100%; height: 1px; border-top-style: dotted; border-top-color: rgb(165, 165, 165);">
	</section><hr style="height: 1px; margin-top: 28px; border-top-style: dotted; border-top-color: rgb(165, 165, 165);"><section class="" style="box-sizing: border-box; width: 100%; text-align: left;">
		
		<img src="/archtime/images/71e11c2e396e21237270f1a746b041e7a14cb7d3.jpeg" style="padding-right: 8px; padding-left: 8px; margin-top: 28px; margin-right: auto; margin-left: auto; width: 770px !important; height: 603.2px !important;"></section></section>
{% endraw  %}

