---
title: '100亿数据平滑数据迁移,不影响服务'
author: 58沈剑
date: '2017-03-23 00:00:00 +0000'

---

{% raw  %}
<p><span style="font-size: 14px;"><strong><span style="font-family: 宋体;">一、问题的提出</span></strong></span></p><p><span style="font-family: 宋体; font-size: 14px;">互联网有很多“<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">数据量较大，并发量较大，业务复杂度较高</span>”的业务场景，其典型系统分层架构如下：</span></p><p><img src="/road5858/images/fb2756ebb4fc970eb4e824c80dba14b9117cb678.png" style="width: 94px !important; height: 136px !important; visibility: visible !important;"></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）上游是</span><strong><span style="font-size: 14px; font-family: 宋体;">业务层</span>biz</strong><span style="font-size: 14px; font-family: 宋体;">，实现个性化的业务逻辑</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）中游是</span><strong><span style="font-size: 14px; font-family: 宋体;">服务层</span>service</strong><span style="font-size: 14px; font-family: 宋体;">，封装数据访问</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）下游是</span><strong><span style="font-size: 14px; font-family: 宋体;">数据层</span>db</strong><span style="font-size: 14px; font-family: 宋体;">，存储固化的业务数据</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">服务化分层架构的好处是，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">服务层屏蔽下游数据层的复杂性</span>，例如缓存、分库分表、存储引擎等存储细节不需要向调用方暴露，而只向上游提供方便的</span>RPC<span style="font-size: 14px; font-family: 宋体;">访问接口，当有一些数据层变化的时候，所有的调用方也不需要升级，只需要服务层升级即可。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">互联网架构，很多时候面临着这样一些需求：</span></p><p><img src="/road5858/images/f15f006a14e9c6240662885a9df588982b4d87c7.png" style="width: 492px !important; height: 181px !important; visibility: visible !important;"></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">需求</span>1-&gt;<span style="font-size: 14px; font-family: 宋体;">底层表结构变更</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：数据量非常大的情况下，数据表增加了一些属性，删除了一些属性，修改了一些属性。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/a8a29f60b608198a38648804f96d83bc4f0ea9bc.png" style="width: 464px !important; height: 179px !important;"></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">需求</span>2-&gt;<span style="font-size: 14px; font-family: 宋体;">分库个数变换</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：由于数据量的持续增加，底层分库个数非成倍增加。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/46cacda1b913de99095413bf503d1b4440c38b44.png" style="width: 452px !important; height: 176px !important;"></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">需求</span>3-&gt;<span style="font-size: 14px; font-family: 宋体;">底层存储介质变换</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：底层存储引擎由一个数据库换为另一个数据库。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">种种需求，都需要进行数据迁移，<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">如何平滑迁移数据，迁移过程不停机，保证系统持续服务，是文本将要讨论的问题</span>。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-size: 19px; font-family: 宋体;">二、停机方案</span></strong></span></p><p><span style="font-family: 宋体; font-size: 14px;">在讨论平滑迁移数据方案之前，先看<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">下不平滑的停机数据迁移方案</span>，主要分三个步骤。</span></p><p><img src="/road5858/images/3df0ae80cadbcb454fc5e95ecad5bdb7c1b646e1.png" style="width: 100px !important; height: 148px !important;"></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">步骤一</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：<strong>挂</strong>一个类似“为了给广大用户提供更好的服务，服务器会在凌晨</span>0:00-0:400<span style="font-size: 14px; font-family: 宋体;">进行停机维护”的<strong>公告</strong>，并在对应时段进行<strong>停机</strong>，这个时段系统没有流量进入。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/f5d2cd3ad35a4f0322246060523116004ec61669.png" style="width: 265px !important; height: 208px !important;"></p><p><strong><span style="font-family: 宋体; font-size: 14px;">步骤二</span></strong><span style="font-family: 宋体; font-size: 14px;">：停机后，研发一个<strong>离线</strong>的数据迁移工具，进行<strong>数据迁移</strong>。针对第一节的三类需求，会分别开发不同的数据迁移工具。</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）底层表结构变更需求：开发旧表导新表的工具</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）分库个数变换需求：开发</span>2<span style="font-size: 14px; font-family: 宋体;">库导</span>3<span style="font-size: 14px; font-family: 宋体;">库的工具</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）底层存储介质变换需求：开发</span>Mongo<span style="font-size: 14px; font-family: 宋体;">导</span>Mysql<span style="font-size: 14px; font-family: 宋体;">工具</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/43eb33b0da434f32b23cc8149c07cba471625dd5.png" style="width: 270px !important; height: 146px !important;"></p><p><strong><span style="font-family: 宋体; font-size: 14px;">步骤三</span></strong><span style="font-family: 宋体; font-size: 14px;">：<strong>恢复服务</strong>，并将流量切到新库，不同的需求，可能会涉及不同服务升级。</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）底层表结构变更需求：服务要升级到访问新表</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）分库个数变换需求：服务不需要升级，只需要改寻库路由配置</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）底层存储介质变换需求：服务升级到访问新的存储介质</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">总的来说，停机方案是相对<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">直观和简单</span>的，但<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">对服务的可用性有影响</span>，许多游戏公司的服务器升级，游戏分区与合区，可能会采用类似的方案。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">除了影响服务的可用性，这个方案还有一个缺点，就是<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">必须在指定时间完成升级</span>，这个对研发、测试、运维同学来说，<strong>压力会非常大</strong>，一旦出现问题例如数据不一致，必须在规定时间内解决，否则只能回滚。根据经验，<strong>人压力越大越容易出错</strong>，这个缺点一定程度上是致命的。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">无论如何，停机方案并不是今天要讨论的重点，接下来看一下常见的<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">平滑数据迁移方案</span>。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-size: 19px; font-family: 宋体;">三、平滑迁移</span></strong><strong><span style="font-size: 19px;">-</span></strong><strong><span style="font-size: 19px; font-family: 宋体;">追日志法</span></strong></span></p><p><span style="font-family: 宋体; font-size: 14px;">平滑迁移方案一，追日志法，这个方案主要分为五个步骤。</span></p><p><img src="/road5858/images/c1e60a48118793c9b63cac32a15652b88083d9bf.png" style="width: 175px !important; height: 153px !important;"></p><p><span style="font-family: 宋体; font-size: 14px;">数据迁移前，上游业务应用通过旧的服务访问旧的数据。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/050d9f021c32052925425423cd414cf888fba7ae.png" style="width: 399px !important; height: 149px !important;"></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">步骤一</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：服务进行升级，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">记录“对旧库上的数据修改”的日志</span>（这里的修改，为数据的</span>insert<span style="font-size: 14px; font-family: 宋体;">,&nbsp;</span>delete<span style="font-size: 14px; font-family: 宋体;">,&nbsp;</span>update<span style="font-size: 14px; font-family: 宋体;">），这个日志不需要记录详细数据，主要记录：</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）被修改的库</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）被修改的表</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）被修改的唯一主键</span></span></p><p><span style="font-family: 宋体; font-size: 14px;">具体新增了什么行，修改后的数据格式是什么，不需要详细记录。这样的好处是，不管业务细节如何变化，<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">日志的格式是固定的</span>，这样能保证方案的通用性。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">这个服务升级风险较小：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）写接口是少数接口，改动点较少</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）升级只是增加了一些日志，对业务功能没有任何影响</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/26e7d902a438ea8afa12d385ac82e79932aefd11.png" style="width: 398px !important; height: 216px !important;"></p><p><strong><span style="font-family: 宋体; font-size: 14px;">步骤二</span></strong><span style="font-family: 宋体; font-size: 14px;">：<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">研发一个数据迁移工具，进行数据迁移</span>。这个数据迁移工具和离线迁移工具一样，把旧库中的数据转移到新库中来。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">这个小工具的风险较小：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）整个过程依然是旧库对线上提供服务</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）小工具的复杂度较低</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）任何时间发现问题，都可以把新库中的数据干掉重来</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>4<span style="font-size: 14px; font-family: 宋体;">）可以限速慢慢迁移，技术同学没有时间压力</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">数据迁移完成之后，就能够切到新库提供服务了么？</span></strong></p><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">答案是否定的</span><span style="font-family: 宋体; font-size: 14px;">，在数据迁移的过程中，旧库依然对线上提供着服务，库中的数据随时可能变化，这个变化并没有反映到新库中来，于是旧库和新库的数据并不一致，所以不能直接切库，需要将数据追平。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">哪些数据发生了变化呢？</span></p><p><span style="font-family: 宋体; font-size: 14px;">步骤一中日志里记录的不就是么？</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/30ec130f5ca9e39c1763e5385c1074dabe6d4ebf.png" style="width: 397px !important; height: 208px !important;"></p><p><strong><span style="font-family: 宋体; font-size: 14px;">步骤三</span></strong><span style="font-family: 宋体; font-size: 14px;">：<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">研发一个读取日志并迁移数据的小工具，要把步骤二迁移数据过程中产生的差异数据追平</span>。这个小工具需要做的是：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）读取日志，得到哪个库、哪个表、哪个主键发生了变化</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）把旧库中对应主键的记录读取出来</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）把新库中对应主键的记录替换掉</span></span></p><p><span style="font-family: 宋体; font-size: 14px;">无论如何，<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">原则是数据以旧库为准</span>。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">这个小工具的风险也很小：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）整个过程依然是旧库对线上提供服务</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）小工具的复杂度较低</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）任何时间发现问题，大不了从步骤二开始重来</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>4<span style="font-size: 14px; font-family: 宋体;">）可以限速慢慢重放日志，技术同学没有时间压力</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">日志重放之后，就能够切到新库提供服务了么？</span></strong></p><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">答案依然是否定的</span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，在日志重放的过程中，旧库中又可能有数据发生了变化，导致数据不一致，所以还是不能切库，需要进一步读取日志，追平记录。可以看到，重放日志追平数据的程序是一个</span>while(1)<span style="font-size: 14px; font-family: 宋体;">的程序，新库与旧库中的<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">数据追平也会是一个“无限逼近”的过程</span>。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">什么时候数据会完全一致呢？</span></strong></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/f9768d4fb624fa023405cc475020c95396f61167.png" style="width: 406px !important; height: 273px !important;"></p><p><strong><span style="font-family: 宋体; font-size: 14px;">步骤四</span></strong><span style="font-family: 宋体; font-size: 14px;">：在持续<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">重放日志，追平数据的过程中，研发一个数据校验的小工具，将旧库和新库中的数据进行比对，直到数据完全一致</span>。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">这个小工具的风险依旧很小：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）整个过程依然是旧库对线上提供服务</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）小工具的复杂度较低</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）任何时间发现问题，大不了从步骤二开始重来</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>4<span style="font-size: 14px; font-family: 宋体;">）可以限速慢慢比对数据，技术同学没有时间压力</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/740d2f49e2fe248f7fc1f7eab018bf469a25b1bd.png" style="width: 403px !important; height: 172px !important;"></p><p><strong><span style="font-family: 宋体; font-size: 14px;">步骤五</span></strong><span style="font-family: 宋体; font-size: 14px;">：在数据比对完全一致之后，将<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">流量迁移到新库</span>，新库提供服务，完成迁移。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">如果步骤四数据一直是</span>99.9%<span style="font-size: 14px; font-family: 宋体;">的一致，不能完全一致，也是正常的，可以做一个秒级的旧库</span>readonly<span style="font-size: 14px; font-family: 宋体;">，等日志重放程序完全追上数据后，再进行切库切流量。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">至此，升级完毕，整个过程能够持续对线上提供服务，不影响服务的可用性。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-size: 19px; font-family: 宋体;">四、平滑迁移</span></strong><strong><span style="font-size: 19px;">-</span></strong><strong><span style="font-size: 19px; font-family: 宋体;">双写法</span></strong></span></p><p><span style="font-family: 宋体; font-size: 14px;">平滑迁移方案二，双写法，这个方案主要分为四个步骤。</span></p><p><img src="/road5858/images/82e7fa60bf01094c87de25dba7a9a2aed15555ba.png" style="width: 171px !important; height: 150px !important;"></p><p><span style="font-family: 宋体; font-size: 14px;">数据迁移前，上游业务应用通过旧的服务访问旧的数据。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/a97468bddbc70698fbacdec0e016c4518654905a.png" style="width: 271px !important; height: 151px !important;"></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">步骤一</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">服务进行升级</span>，对“对旧库上的数据修改”（这里的修改，为数据的</span>insert<span style="font-family: 宋体; font-size: 14px; line-height: 22.4px;">,</span>&nbsp;delete<font face="宋体">,&nbsp;</font>update<span style="font-size: 14px; font-family: 宋体;">），在新库上进行相同的修改操作，这就是所谓的“<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">双写</span>”，主要修改操作包括：</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）旧库与新库的同时</span>insert</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）旧库与新库的同时</span>delete</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）旧库与新库的同时</span>update</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">由于新库中此时是没有数据的，所以双写旧库与新库中的</span>affect rows<span style="font-size: 14px; font-family: 宋体;">可能不一样，不过这完全不影响业务功能，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">只要不切库，依然是旧库提供业务服务</span>。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">这个服务升级风险较小：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）写接口是少数接口，改动点较少</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）新库的写操作执行成功与否，对业务功能没有任何影响</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/d4eb839212be31ae8ac59bcb917e344b91d14050.png" style="width: 295px !important; height: 200px !important;"></p><p><strong><span style="font-family: 宋体; font-size: 14px;">步骤二</span></strong><span style="font-family: 宋体; font-size: 14px;">：研发一个数据迁移工具，进行<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">数据迁移</span>。这个数据迁移工具在本文中已经出现第三次了，把旧库中的数据转移到新库中来。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">这个小工具的风险较小：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）整个过程依然是旧库对线上提供服务</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）小工具的复杂度较低</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）任何时间发现问题，都可以把新库中的数据干掉重来</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>4<span style="font-size: 14px; font-family: 宋体;">）可以限速慢慢迁移，技术同学没有时间压力</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">数据迁移完成之后，就能够切到新库提供服务了么？</span></strong></p><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">答案是肯定的</span><span style="font-family: 宋体; font-size: 14px;">，因为前置步骤进行了双写，所以理论上数据迁移完之后，新库与旧库的数据应该完全一致。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">由于迁移数据的过程中，旧库新库双写操作在同时进行，<strong>怎么证明数据迁移完成之后数据就完全一致了呢？</strong></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/8b9e4b5c1e9948be9ed578aaec69c32351bcbefa.png" style="width: 466px !important; height: 321px !important;"></p><p><span style="font-family: 宋体; font-size: 14px;">如上图所示：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）左侧是旧库中的数据，右侧是新库中的数据</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）按照</span>primary key<span style="font-size: 14px; font-family: 宋体;">从</span>min<span style="font-size: 14px; font-family: 宋体;">到</span>max<span style="font-size: 14px; font-family: 宋体;">的顺序，分段，限速进行数据的迁移，假设已经迁移到</span>now<span style="font-size: 14px; font-family: 宋体;">这个数据段</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">数据迁移过程中的修改操作分别讨论：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）假设迁移过程中进行了一个</span><strong><span style="font-size: 14px; font-family: 宋体;">双</span>insert<span style="font-size: 14px; font-family: 宋体;">操作</span></strong><span style="font-size: 14px; font-family: 宋体;">，旧库新库都插入了数据，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">数据一致</span>性没有被破坏</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）假设迁移过程中进行了一个</span><strong><span style="font-size: 14px; font-family: 宋体;">双</span>delete<span style="font-size: 14px; font-family: 宋体;">操作</span></strong><span style="font-size: 14px; font-family: 宋体;">，这又分为两种情况</span></span></p><p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-size: 14px; font-family: 宋体;">（</span>2.1<span style="font-size: 14px; font-family: 宋体;">）假设这</span>delete<span style="font-size: 14px; font-family: 宋体;">的数据属于</span>[min,now]<span style="font-size: 14px; font-family: 宋体;">范围，即已经完成迁移，则旧库新库都删除了数据，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">数据一致</span>性没有被破坏</span></span></p><p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-size: 14px; font-family: 宋体;">（</span>2.2<span style="font-size: 14px; font-family: 宋体;">）假设这</span>delete<span style="font-size: 14px; font-family: 宋体;">的数据属于</span>[now,max]<span style="font-size: 14px; font-family: 宋体;">范围，即未完成迁移，则旧库中删除操作的</span>affect rows<span style="font-size: 14px; font-family: 宋体;">为</span>1<span style="font-size: 14px; font-family: 宋体;">，新库中删除操作的</span>affect rows<span style="font-size: 14px; font-family: 宋体;">为</span>0<span style="font-size: 14px; font-family: 宋体;">，但是数据迁移工具在后续数据迁移中，并不会将这条旧库中被删除的数据迁移到新库中，所以数据一致性仍没有被破坏</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）假设迁移过程中进行了一个</span><strong><span style="font-size: 14px; font-family: 宋体;">双</span>update<span style="font-size: 14px; font-family: 宋体;">操作</span></strong><span style="font-size: 14px; font-family: 宋体;">，可以认为</span>update<span style="font-size: 14px; font-family: 宋体;">操作是一个</span>delete<span style="font-size: 14px; font-family: 宋体;">加一个</span>insert<span style="font-size: 14px; font-family: 宋体;">操作的复合操作，所以数据仍然是<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">一致</span>的</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">除非除非除非，在一种非常非常非常极限的情况下：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）</span>date-migrate-tool<strong><span style="font-size: 14px; font-family: 宋体;">刚好</span></strong><span style="font-size: 14px; font-family: 宋体;">从旧库中将某一条数据</span>X<span style="font-size: 14px; font-family: 宋体;">取出</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）在</span>X<span style="font-size: 14px; font-family: 宋体;">插入到新库中之前，旧库与新库中<strong>刚好</strong>对</span>X<span style="font-size: 14px; font-family: 宋体;">进行了双</span>delete<span style="font-size: 14px; font-family: 宋体;">操作</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）</span>date-migrate-tool<span style="font-size: 14px; font-family: 宋体;">再将</span>X<span style="font-size: 14px; font-family: 宋体;">插入到新库中</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">这样，会出现新库比旧库多出一条数据</span>X<span style="font-size: 14px; font-family: 宋体;">。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">但无论如何，为了保证数据的一致性，切库之前，还是需要进行数据校验的。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/d79b724194434678914f1b588f5fd14a46b4a427.png" style="width: 300px !important; height: 205px !important;"></p><p><strong><span style="font-family: 宋体; font-size: 14px;">步骤三</span></strong><span style="font-family: 宋体; font-size: 14px;">：在数据迁移完成之后，需要使用<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">数据校验的小工具</span>，将旧库和新库中的数据进行比对，完全一致则符合预期，如果出现步骤二中的极限不一致情况，则以旧库中的数据为准。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">这个小工具的风险依旧很小：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）整个过程依然是旧库对线上提供服务</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）小工具的复杂度较低</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）任何时间发现问题，大不了从步骤二开始重来</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>4<span style="font-size: 14px; font-family: 宋体;">）可以限速慢慢比对数据，技术同学没有时间压力</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><img src="/road5858/images/5e6dd01ec0194facf1c50a12fbf9d68d97893847.png" style="width: 300px !important; height: 152px !important;"></p><p><strong><span style="font-family: 宋体; font-size: 14px;">步骤四</span></strong><span style="font-family: 宋体; font-size: 14px;">：数据完全一致之后，将<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 104, 39);">流量切到新库</span>，完成平滑数据迁移。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">至此，升级完毕，整个过程能够持续对线上提供服务，不影响服务的可用性。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-size: 19px; font-family: 宋体;">五、总结</span></strong></span></p><p><span style="font-family: 宋体; font-size: 14px;">针对互联网很多“数据量较大，并发量较大，业务复杂度较高”的业务场景，在</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）底层表结构变更</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）分库个数变换</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）底层存储介质变换</span></span></p><p><span style="font-family: 宋体; font-size: 14px;">的众多需求下，需要进行数据迁移，完成<strong>“平滑迁移数据，迁移过程不停机，保证系统持续服务”</strong>有两种常见的解决方案。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">追日志法</span></strong><span style="font-family: 宋体; font-size: 14px;">，五个步骤：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）<strong>服务进行升级</strong>，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">记录</span>“对旧库上的数据修改”的<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">日志</span></span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）研发一个数据迁移<strong>小工具</strong>，进行<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">数据迁移</span></span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）研发一个读取日志<strong>小工具</strong>，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">追平数据</span>差异</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>4<span style="font-size: 14px; font-family: 宋体;">）研发一个数据比对<strong>小工具</strong>，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">校验数据</span>一致性</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>5<span style="font-size: 14px; font-family: 宋体;">）<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">流量切到新库</span>，完成平滑迁移</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">双写法</span></strong><span style="font-family: 宋体; font-size: 14px;">，四个步骤：</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）<strong>服务进行升级</strong>，记录“对旧库上的数据修改”进行新库的<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">双写</span></span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）研发一个数据迁移<strong>小工具</strong>，进行<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">数据迁移</span></span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>3<span style="font-size: 14px; font-family: 宋体;">）研发一个数据比对<strong>小工具</strong>，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 104, 39);">校验数据</span>一致性</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>4<span style="font-size: 14px; font-family: 宋体;">）流量切到新库，完成平滑迁移</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">文章比较长，希望大家有收获。</span></span></p><p><font face="宋体"><span style="font-size: 14px; line-height: 22.4px; color: rgb(255, 104, 39);">帮转</span><span style="font-size: 14px; line-height: 22.4px;">哟。</span></font></p><p><font face="宋体"><span style="font-size: 14px; line-height: 22.4px;">==【完】==</span></font></p><p><font face="宋体"><span style="font-size: 14px; line-height: 22.4px;">推荐阅读：</span></font></p><p><font face="宋体"><span style="font-size: 14px; line-height: 22.4px;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959942&amp;idx=1&amp;sn=e9d3fe111b8a1d44335f798bbb6b9eea&amp;chksm=bd2d075a8a5a8e4cad985b847778aa83056e22931767bb835132c04571b66d5434020fd4147f&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959942&amp;idx=1&amp;sn=e9d3fe111b8a1d44335f798bbb6b9eea&amp;chksm=bd2d075a8a5a8e4cad985b847778aa83056e22931767bb835132c04571b66d5434020fd4147f&amp;scene=21#wechat_redirect">业界难题-“跨库分页”的四种方案</a></span></font></p><p><font face="宋体"><span style="font-size: 14px; line-height: 22.4px;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959883&amp;idx=1&amp;sn=e7df8510c7096a5b069e0f12eaaca010&amp;chksm=bd2d07978a5a8e815c2ae41b16b6b4c579923502fb919008a22bb108a1e920109f25387f8903&amp;scene=21#wechat_redirect" target="_blank" data_ue_src="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959883&amp;idx=1&amp;sn=e7df8510c7096a5b069e0f12eaaca010&amp;chksm=bd2d07978a5a8e815c2ae41b16b6b4c579923502fb919008a22bb108a1e920109f25387f8903&amp;scene=21#wechat_redirect">数据库秒级平滑扩容架构方案</a><br></span></font></p>
{% endraw  %}

