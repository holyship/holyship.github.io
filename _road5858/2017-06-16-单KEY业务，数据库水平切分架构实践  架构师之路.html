---
title: 单KEY业务，数据库水平切分架构实践 | 架构师之路
author: 58沈剑
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1498052271&src=3&ver=1&signature=nULoNfhbsabgcFJEB9PUQ1KJasWOsq8hSo-mm4SVBUqXpDLOmbKmY46mI-tH6ASrpLYSYQojdSaCl4vWp*Xp7eiv71d0RFo9PrjKJjWzmkMfS-HMTOS4552dU8sTD7NGfu*3IppAb9N7u7ua9raN0QGAoUZ3ao0QkFWcSVqVzCs=
date: '2017-06-16 00:00:00 +0000'

---

{% raw  %}
<p><span style="font-size: 14px;"><span style="font-family: 宋体;">提醒，本文较长，可提前收藏/转发。</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体;">本文将以“用户中心”为例，介绍“单</span>KEY<span style="font-family: 宋体;">”类业务，随着数据量的逐步增大，数据库性能显著降低，数据库水平切分相关的架构实践：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">如何来实施水平切分</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">水平切分后常见的问题</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">典型问题的优化思路及实践</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 16px;"><strong><span style="font-family: 宋体;">一、用户中心</span></strong></span></p><p><span style="font-family: 宋体; font-size: 14px;">用户中心是一个非常常见的业务，主要提供<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">用户注册、登录、信息查询与修改</span>的服务，其核心元数据为：</span></p><p><span style="font-size: 12px;">User(uid, login_name, passwd, sex, age, nickname, …)</span></p><p><span style="font-family: 宋体; font-size: 14px;">其中：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;">uid<span style="font-size: 14px; font-family: 宋体;">为用户</span>ID<span style="font-size: 14px; font-family: 宋体;">，主键</span></span></p></li><li><p><span style="font-size: 14px;">login_name, passwd, sex, age, nickname, …<span style="font-size: 14px; font-family: 宋体;">等用户属性</span></span></p></li></ul><p><span style="font-family: 宋体; font-size: 14px;">数据库设计上，一般来说在业务<strong>初期</strong>，<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">单库单表</span>就能够搞定这个需求，典型的架构设计为：</span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrUamdriaAWKQibIiafx1ud6DWiaApc0fFRzC6X2vgb9Vp29xoFEpFjFUw7Hg/0?wx_fmt=png" style="width: 90px !important; height: 103px !important; visibility: visible !important;"></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;">user-center<span style="font-size: 14px; font-family: 宋体;">：用户中心服务，对调用者提供友好的</span>RPC<span style="font-size: 14px; font-family: 宋体;">接口</span></span></p></li><li><p><span style="font-size: 14px;">user-db<span style="font-size: 14px; font-family: 宋体;">：对用户进行数据存储</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 16px;"><strong><span style="font-family: 宋体;">二、用户中心水平切分方法</span></strong></span></p><p><span style="font-family: 宋体; font-size: 14px;">当<strong>数据量越来越大时</strong>，需要对数据库进行<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">水平切分</span>，常见的水平切分算法有<strong>“范围法”和“哈希法”</strong>。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">范围法</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，以用户中心的业务主键</span>uid<span style="font-size: 14px; font-family: 宋体;">为划分依据，将数据水平切分到两个数据库实例上去：</span></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrU03JIxwdPWIQbcV948AJdUxg3uNDbIp4ibzOaibTuv8YYGXYYazmzZ2Fg/0?wx_fmt=png" style="width: 211px !important; height: 104px !important;"></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;">user-db1<span style="font-size: 14px; font-family: 宋体;">：存储</span>0<span style="font-size: 14px; font-family: 宋体;">到</span>1<span style="font-size: 14px; font-family: 宋体;">千万的</span>uid<span style="font-size: 14px; font-family: 宋体;">数据</span></span></p></li><li><p><span style="font-size: 14px;">user-db2<span style="font-size: 14px; font-family: 宋体;">：存储</span>1<span style="font-size: 14px; font-family: 宋体;">到</span>2<span style="font-size: 14px; font-family: 宋体;">千万的</span>uid<span style="font-size: 14px; font-family: 宋体;">数据</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">范围法的<strong>优点</strong>是：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">切分策略简单</span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，根据</span>uid<span style="font-size: 14px; font-family: 宋体;">，按照范围，</span>user- center<span style="font-size: 14px; font-family: 宋体;">很快能够定位到数据在哪个库上</span></span></p></li><li><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">扩容简单</span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，如果容量不够，只要增加</span>user-db3<span style="font-size: 14px; font-family: 宋体;">即可</span></span></p></li></ul><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;"><br></span></span></p><p><span style="font-family: 宋体; font-size: 14px;">范围法的<strong>不足</strong>是：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;">uid<span style="font-size: 14px; font-family: 宋体;">必须要满足<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 76, 0);">递增的特性</span></span></span></p></li><li><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">数据量不均</span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，新增的</span>user-db3<span style="font-size: 14px; font-family: 宋体;">，在初期的数据会比较少</span></span></p></li><li><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">请求量不均</span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，一般来说，新注册的用户活跃度会比较高，故</span>user-db2<span style="font-size: 14px; font-family: 宋体;">往往会比</span>user-db1<span style="font-size: 14px; font-family: 宋体;">负载要高，导致服务器利用率不平衡</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">哈希法</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，也是以用户中心的业务主键</span>uid<span style="font-size: 14px; font-family: 宋体;">为划分依据，将数据水平切分到两个数据库实例上去：</span></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrUJCkytKRyvvmNyOkKRUoYATZWQnUnvZX7KLRjCS9T5f4vPJmaZvwaew/0?wx_fmt=png" style="width: 214px !important; height: 106px !important;"></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;">user-db1<span style="font-size: 14px; font-family: 宋体;">：存储</span>uid<span style="font-size: 14px; font-family: 宋体;">取模得</span>1<span style="font-size: 14px; font-family: 宋体;">的</span>uid<span style="font-size: 14px; font-family: 宋体;">数据</span></span></p></li><li><p><span style="font-size: 14px;">user-db2<span style="font-size: 14px; font-family: 宋体;">：存储</span>uid<span style="font-size: 14px; font-family: 宋体;">取模得</span>0<span style="font-size: 14px; font-family: 宋体;">的</span>uid<span style="font-size: 14px; font-family: 宋体;">数据</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">哈希法的<strong>优点</strong>是：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">切分策略简单</span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，根据</span>uid<span style="font-size: 14px; font-family: 宋体;">，按照</span>hash<span style="font-size: 14px; font-family: 宋体;">，</span>user-center<span style="font-size: 14px; font-family: 宋体;">很快能够定位到数据在哪个库上</span></span></p></li><li><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">数据量均衡</span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，只要</span>uid<span style="font-size: 14px; font-family: 宋体;">是均匀的，数据在各个库上的分布一定是均衡的</span></span></p></li><li><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">请求量均衡</span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，只要</span>uid<span style="font-size: 14px; font-family: 宋体;">是均匀的，负载在各个库上的分布一定是均衡的</span></span></p></li></ul><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;"><br></span></span></p><p><span style="font-family: 宋体; font-size: 14px;">哈希法的<strong>不足</strong>是：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">扩容麻烦</span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，如果容量不够，要增加一个库，重新</span>hash<span style="font-size: 14px; font-family: 宋体;">可能会导致数据迁移，如何平滑的进行数据迁移，是一个需要解决的问题</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 16px;"><strong><span style="font-family: 宋体;">三、用户中心水平切分后带来的问题</span></strong></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">使用</span>uid<span style="font-size: 14px; font-family: 宋体;">来进行水平切分之后，整个用户中心的业务访问会遇到什么问题呢？</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px; color: rgb(255, 76, 0);"><span style="font-size: 14px; font-family: 宋体;">对于</span>uid<span style="font-size: 14px; font-family: 宋体;">属性上的查询可以直接路由到库</span></span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，假设访问</span>uid=124<span style="font-size: 14px; font-family: 宋体;">的数据，取模后能够直接定位</span>db-user1<span style="font-size: 14px; font-family: 宋体;">：</span></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrUI3nHV2L7XibF1LQ7cbZPVYG99FdRCWmJibriaH5RPqxChA2AG75s3RV6w/0?wx_fmt=png" style="width: 299px !important; height: 169px !important;"></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px; color: rgb(255, 76, 0);"><span style="font-size: 14px; font-family: 宋体;">对于非</span>uid<span style="font-size: 14px; font-family: 宋体;">属性上的查询，例如</span>login_name<span style="font-size: 14px; font-family: 宋体;">属性上的查询，就悲剧了</span></span><span style="font-size: 14px; font-family: 宋体;">：</span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrU2B5icaoyyxCPnEUsS06rHhLRHBw6avcW5Wl0JGtV2cmNUF1T1urdoKQ/0?wx_fmt=png" style="width: 294px !important; height: 170px !important;"></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">假设访问</span>login_name=shenjian<span style="font-size: 14px; font-family: 宋体;">的数据，由于不知道数据落在哪个库上，往往需要遍历所有库，当分库数量多起来，性能会显著降低。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">如何解决分库后，非</span>uid<span style="font-size: 14px; font-family: 宋体;">属性上的查询问题，是后文要重点讨论的内容。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 16px;"><strong><span style="font-family: 宋体;">四、用户中心非</span>uid</strong><strong><span style="font-family: 宋体;">属性查询需求分析</span></strong></span></p><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">任何脱离业务的架构设计都是耍流氓</span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">，在进行架构讨论之前，先来对业务进行简要分析，看非</span>uid<span style="font-size: 14px; font-family: 宋体;">属性上有哪些查询需求。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">根据楼主这些年的架构经验，用户中心非</span>uid<span style="font-size: 14px; font-family: 宋体;">属性上经常有两类业务需求：</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>1<span style="font-size: 14px; font-family: 宋体;">）<strong>用户侧，前台访问</strong>，最典型的有两类需求</span></span></p><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">用户登录</span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：通过</span>login_name/phone/email<span style="font-size: 14px; font-family: 宋体;">查询用户的实体，</span>1%<span style="font-size: 14px; font-family: 宋体;">请求属于这种类型</span></span></p><p><span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">用户信息查询</span><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：登录之后，通过</span>uid<span style="font-size: 14px; font-family: 宋体;">来查询用户的实例，</span>99%<span style="font-size: 14px; font-family: 宋体;">请求属这种类型</span></span></p><p><span style="font-family: 宋体; font-size: 14px;"><br></span></p><p><span style="font-family: 宋体; font-size: 14px;">用户侧的查询基本上是单条记录的查询，访问量较大，服务需要高可用，并且对一致性的要求较高。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">（</span>2<span style="font-size: 14px; font-family: 宋体;">）<strong>运营侧，后台访问</strong>，根据产品、运营需求，访问模式各异，</span></span><span style="font-family: 宋体; font-size: 14px; line-height: 1.6;">按照</span><span style="font-family: 宋体; font-size: 14px; line-height: 1.6; color: rgb(255, 76, 0);">年龄、性别、头像、登陆时间、注册时间来进行查询</span><span style="font-family: 宋体; font-size: 14px; line-height: 1.6;">。</span></p><p><span style="font-family: 宋体; font-size: 14px;"><br></span></p><p><span style="font-family: 宋体; font-size: 14px;">运营侧的查询基本上是批量分页的查询，由于是内部系统，访问量很低，对可用性的要求不高，对一致性的要求也没这么严格。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">这两类不同的业务需求，应该使用什么样的架构方案来解决呢？</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 16px;"><strong><span style="font-family: 宋体;">五、用户中心水平切分架构思路</span></strong></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">用户中心在数据量较大的情况下，使用</span>uid<span style="font-size: 14px; font-family: 宋体;">进行水平切分，对于非</span>uid<span style="font-size: 14px; font-family: 宋体;">属性上的查询需求，架构设计的核心思路为：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">针对<strong>用户侧</strong>，应该采用“</span><span style="font-size: 14px; color: rgb(255, 76, 0);"><span style="font-size: 14px; font-family: 宋体;">建立非</span>uid<span style="font-size: 14px; font-family: 宋体;">属性到</span>uid<span style="font-size: 14px; font-family: 宋体;">的映射关系</span></span><span style="font-size: 14px; font-family: 宋体;">”的架构方案</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">针对<strong>运营侧</strong>，应该采用“<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 76, 0);">前台与后台分离</span>”的架构方案</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 16px;"><strong><span style="font-family: 宋体;">六、用户中心</span>-</strong><strong><span style="font-family: 宋体;">用户侧最佳实践</span></strong></span></p><p><span style="font-size: 14px;"><strong><span style="font-size: 16px; font-family: 宋体;">【索引表法】</span></strong></span></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">思路</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：</span>uid<span style="font-size: 14px; font-family: 宋体;">能直接定位到库，</span>login_name<span style="font-size: 14px; font-family: 宋体;">不能直接定位到库，如果通过</span>login_name<span style="font-size: 14px; font-family: 宋体;">能查询到</span>uid<span style="font-size: 14px; font-family: 宋体;">，问题解决</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;"><br></span></span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">解决方案</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">建立一个索引表记录</span>login_name-&gt;uid<span style="font-size: 14px; font-family: 宋体;">的映射关系</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">用</span>login_name<span style="font-size: 14px; font-family: 宋体;">来访问时，先通过索引表查询到</span>uid<span style="font-size: 14px; font-family: 宋体;">，再定位相应的库</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">索引表属性较少，可以容纳非常多数据，一般不需要分库</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">如果数据量过大，可以通过</span>login_name<span style="font-size: 14px; font-family: 宋体;">来分库</span></span></p></li></ul><p><span style="font-family: 宋体; font-size: 14px;"><br></span></p><p><span style="font-family: 宋体; font-size: 14px;">潜在<strong>不足</strong>：多一次数据库查询，性能下降一倍</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-size: 16px; font-family: 宋体;">【缓存映射法】</span></strong></span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">思路</span></strong><span style="font-family: 宋体; font-size: 14px;">：访问索引表性能较低，把映射关系放在缓存里性能更佳</span></p><p><span style="font-family: 宋体; font-size: 14px;"><br></span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">解决方案</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;">login_name<span style="font-size: 14px; font-family: 宋体;">查询先到</span>cache<span style="font-size: 14px; font-family: 宋体;">中查询</span>uid<span style="font-size: 14px; font-family: 宋体;">，再根据</span>uid<span style="font-size: 14px; font-family: 宋体;">定位数据库</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">假设</span>cache miss<span style="font-size: 14px; font-family: 宋体;">，采用扫全库法获取</span>login_name<span style="font-size: 14px; font-family: 宋体;">对应的</span>uid<span style="font-size: 14px; font-family: 宋体;">，放入</span>cache</span></p></li><li><p><span style="font-size: 14px;">login_name<span style="font-size: 14px; font-family: 宋体;">到</span>uid<span style="font-size: 14px; font-family: 宋体;">的映射关系不会变化，映射关系一旦放入缓存，不会更改，无需淘汰，缓存命中率超高</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">如果数据量过大，可以通过</span>login_name<span style="font-size: 14px; font-family: 宋体;">进行</span>cache<span style="font-size: 14px; font-family: 宋体;">水平切分</span></span></p></li></ul><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">潜在<strong>不足</strong>：多一次</span>cache<span style="font-size: 14px; font-family: 宋体;">查询</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-size: 16px; font-family: 宋体;">【</span></strong><strong><span style="font-size: 16px;">login_name</span></strong><strong><span style="font-size: 16px; font-family: 宋体;">生成</span></strong><strong><span style="font-size: 16px;">uid</span></strong><strong><span style="font-size: 16px; font-family: 宋体;">】</span></strong></span></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">思路</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：不进行远程查询，由</span>login_name<span style="font-size: 14px; font-family: 宋体;">直接得到</span>uid</span></p><p><span style="font-size: 14px;"><br></span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">解决方案</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">在用户注册时，设计函数</span>login_name<span style="font-size: 14px; font-family: 宋体;">生成</span>uid<span style="font-size: 14px; font-family: 宋体;">，</span>uid=f(login_name)<span style="font-size: 14px; font-family: 宋体;">，按</span>uid<span style="font-size: 14px; font-family: 宋体;">分库插入数据</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">用</span>login_name<span style="font-size: 14px; font-family: 宋体;">来访问时，先通过函数计算出</span>uid<span style="font-size: 14px; font-family: 宋体;">，即</span>uid=f(login_name)<span style="font-size: 14px; font-family: 宋体;">再来一遍，由</span>uid<span style="font-size: 14px; font-family: 宋体;">路由到对应库</span></span></p></li></ul><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">潜在<strong>不足</strong>：该函数设计需要非常讲究技巧，有</span>uid<span style="font-size: 14px; font-family: 宋体;">生成冲突风险</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-size: 16px; font-family: 宋体;">【</span></strong><strong><span style="font-size: 16px;">login_name</span></strong><strong><span style="font-size: 16px; font-family: 宋体;">基因融入</span></strong><strong><span style="font-size: 16px;">uid</span></strong><strong><span style="font-size: 16px; font-family: 宋体;">】</span></strong></span></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">思路</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：不能用</span>login_name<span style="font-size: 14px; font-family: 宋体;">生成</span>uid<span style="font-size: 14px; font-family: 宋体;">，可以从</span>login_name<span style="font-size: 14px; font-family: 宋体;">抽取“基因”，融入</span>uid<span style="font-size: 14px; font-family: 宋体;">中</span></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrUiaibCbjwaqEl9MOaIclIbqfrAMiaRRZSNeaQchyxuiaxlvd0fkerI04aFA/0?wx_fmt=png" style="width: 539px !important; height: 153px !important;"></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">假设分</span>8<span style="font-size: 14px; font-family: 宋体;">库，采用</span>uid%8<span style="font-size: 14px; font-family: 宋体;">路由，潜台词是，</span>uid<span style="font-size: 14px; font-family: 宋体;">的最后</span>3<span style="font-size: 14px; font-family: 宋体;">个</span>bit<span style="font-size: 14px; font-family: 宋体;">决定这条数据落在哪个库上，这</span>3<span style="font-size: 14px; font-family: 宋体;">个</span>bit<span style="font-size: 14px; font-family: 宋体;">就是所谓的“基因”。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">解决方案</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">在用户注册时，设计函数</span>login_name<span style="font-size: 14px; font-family: 宋体;">生成</span>3bit<span style="font-size: 14px; font-family: 宋体;">基因，</span>login_name_gene=f(login_name)<span style="font-size: 14px; font-family: 宋体;">，如上图粉色部分</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">同时，生成</span>61bit<span style="font-size: 14px; font-family: 宋体;">的全局唯一</span>id<span style="font-size: 14px; font-family: 宋体;">，作为用户的标识，如上图绿色部分</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">接着把</span>3bit<span style="font-size: 14px; font-family: 宋体;">的</span>login_name_gene<span style="font-size: 14px; font-family: 宋体;">也作为</span>uid<span style="font-size: 14px; font-family: 宋体;">的一部分，如上图屎黄色部分</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">生成</span>64bit<span style="font-size: 14px; font-family: 宋体;">的</span>uid<span style="font-size: 14px; font-family: 宋体;">，由</span>id<span style="font-size: 14px; font-family: 宋体;">和</span>login_name_gene<span style="font-size: 14px; font-family: 宋体;">拼装而成，并按照</span>uid<span style="font-size: 14px; font-family: 宋体;">分库插入数据</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">用</span>login_name<span style="font-size: 14px; font-family: 宋体;">来访问时，先通过函数由</span>login_name<span style="font-size: 14px; font-family: 宋体;">再次复原</span>3bit<span style="font-size: 14px; font-family: 宋体;">基因，</span>login_name_gene=f(login_name)<span style="font-size: 14px; font-family: 宋体;">，通过</span>login_name_gene%8<span style="font-size: 14px; font-family: 宋体;">直接定位到库</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 16px;"><strong><span style="font-family: 宋体;">七、用户中心</span>-</strong><strong><span style="font-family: 宋体;">运营侧最佳实践</span></strong></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">前台<strong>用户侧</strong>，业务需求基本都是<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 76, 0);">单行记录的访问</span>，只要建立非</span>uid<span style="font-size: 14px; font-family: 宋体;">属性&nbsp;</span>login_name / phone / email&nbsp;<span style="font-size: 14px; font-family: 宋体;">到</span>uid<span style="font-size: 14px; font-family: 宋体;">的映射关系，就能解决问题。</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;"><br></span></span></p><p><span style="font-family: 宋体; font-size: 14px;">后台<strong>运营侧</strong>，业务需求各异，基本是<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">批量分页</span>的访问，这类访问计算量较大，返回数据量较大，比较消耗数据库性能。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">如果此时前台业务和后台业务公用一批服务和一个数据库，有可能导致，由于后台的“少数几个请求”的“批量查询”的“低效”访问，导致数据库的</span>cpu<span style="font-size: 14px; font-family: 宋体;">偶尔瞬时</span>100%<span style="font-size: 14px; font-family: 宋体;">，影响前台正常用户的访问（例如，登录超时）。</span></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrU28Rr6w5cVaicnRrgNibpibKmbUKM2ePWueMT44rsZDKuOqlNOTtR5icVpg/0?wx_fmt=png" style="width: 301px !important; height: 153px !important;"></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">而且，为了满足后台业务各类“奇形怪状”的需求，往往会在数据库上建立各种索引，这些索引占用大量内存，会使得用户侧前台业务</span>uid/login_name<span style="font-size: 14px; font-family: 宋体;">上的查询性能与写入性能大幅度降低，处理时间增长。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">对于这一类业务，应该采用<span style="font-family: 宋体; font-size: 14px; color: rgb(255, 76, 0);">“前台与后台分离”的架构方案</span>：</span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrUWp4R0xh5GUiaI9FzvcXdrPGEMY1l3vnDr9KjTKxagGqayN4NdJvtZxQ/0?wx_fmt=png" style="width: 458px !important; height: 163px !important;"></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">用户侧前台业务需求架构依然不变，产品运营侧后台业务需求则</span><strong><span style="font-size: 14px; font-family: 宋体;">抽取独立的</span>web / service / db&nbsp;<span style="font-size: 14px; font-family: 宋体;">来支持</span></strong><span style="font-size: 14px; font-family: 宋体;">，<span style="font-size: 14px; font-family: 宋体; color: rgb(255, 76, 0);">解除系统之间的耦合</span>，对于“业务复杂”“并发量低”“无需高可用”“能接受一定延时”的后台业务：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">可以去掉</span>service<span style="font-size: 14px; font-family: 宋体;">层，在运营后台</span>web<span style="font-size: 14px; font-family: 宋体;">层通过</span>dao<span style="font-size: 14px; font-family: 宋体;">直接访问</span>db</span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">不需要反向代理，不需要集群冗余</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">不需要访问实时库，可以通过</span>MQ<span style="font-size: 14px; font-family: 宋体;">或者线下异步同步数据</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">在数据库非常大的情况下，可以使用更契合大量数据允许接受更高延时的“索引外置”或者“</span>HIVE<span style="font-size: 14px; font-family: 宋体;">”的设计方案</span></span></p></li></ul><p><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrUGvNtllkhu7qosvWPhj5BaQAacK6xrnvPSg5yO4toiaKJF9qjYvdkdtw/0?wx_fmt=png" style="width: 449px !important; height: 157px !important;"></p><p><span style="font-size: 14px;"></span><span style="font-size: 14px; line-height: 1.6;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-size: 16px; font-family: 宋体;">八、总结</span></strong></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">将以“用户中心”为典型的“单</span>KEY<span style="font-size: 14px; font-family: 宋体;">”类业务，水平切分的架构点，本文做了这样一些介绍。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">水平切分方式</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">范围法</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">哈希法</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">水平切分后碰到的问题</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">通过</span>uid<span style="font-size: 14px; font-family: 宋体;">属性查询能直接定位到库，通过非</span>uid<span style="font-size: 14px; font-family: 宋体;">属性查询不能定位到库</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">非</span>uid<span style="font-size: 14px; font-family: 宋体;">属性查询的典型业务</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">用户侧，前台访问，单条记录的查询，访问量较大，服务需要高可用，并且对一致性的要求较高</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">运营侧，后台访问，根据产品、运营需求，访问模式各异，基本上是批量分页的查询，由于是内部系统，访问量很低，对可用性的要求不高，对一致性的要求也没这么严格</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">这两类业务的架构设计思路</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">针对用户侧，应该采用“建立非</span>uid<span style="font-size: 14px; font-family: 宋体;">属性到</span>uid<span style="font-size: 14px; font-family: 宋体;">的映射关系”的架构方案</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">针对运营侧，应该采用“前台与后台分离”的架构方案</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">用户前台侧，“建立非</span>uid<span style="font-size: 14px; font-family: 宋体;">属性到</span>uid<span style="font-size: 14px; font-family: 宋体;">的映射关系”最佳实践</span></span></strong><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">索引表法：数据库中记录</span>login_name-&gt;uid<span style="font-size: 14px; font-family: 宋体;">的映射关系</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">缓存映射法：缓存中记录</span>login_name-&gt;uid<span style="font-size: 14px; font-family: 宋体;">的映射关系</span></span></p></li><li><p><span style="font-size: 14px;">login_name<span style="font-size: 14px; font-family: 宋体;">生成</span>uid</span></p></li><li><p><span style="font-size: 14px;">login_name<span style="font-size: 14px; font-family: 宋体;">基因融入</span>uid</span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">运营后台侧，“前台与后台分离”最佳实践</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">前台、后台系统</span>web/service/db<span style="font-size: 14px; font-family: 宋体;">分离解耦，避免后台低效查询引发前台查询抖动</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">可以采用数据冗余的设计方式</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">可以采用“外置索引”（例如</span>ES<span style="font-size: 14px; font-family: 宋体;">搜索系统）或者“大数据处理”（例如</span>HIVE<span style="font-size: 14px; font-family: 宋体;">）来满足后台变态的查询需求</span></span></p></li></ul><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;"></span></span></p><p><span style="font-family: 宋体; font-size: 14px; line-height: 1.6;"><br></span></p><p><span style="font-family: 宋体; font-size: 14px; line-height: 1.6;">其他类型业务的水平切分架构方案，未来和大家聊。</span><br></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">希望大伙有收获。</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;">相关推荐：</span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959992&amp;idx=1&amp;sn=eb2fbd7d7922db42a593c304e50a65b7&amp;chksm=bd2d07648a5a8e72d489022ec6006274d7e43ab48449b255d5661658c2af8e9221977a9609ed&amp;scene=21#wechat_redirect" target="_blank">100亿数据平滑数据迁移,不影响服务</a><br></span></span></p><p><span style="font-size: 14px;"><span style="font-size: 14px; font-family: 宋体;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959883&amp;idx=1&amp;sn=e7df8510c7096a5b069e0f12eaaca010&amp;chksm=bd2d07978a5a8e815c2ae41b16b6b4c579923502fb919008a22bb108a1e920109f25387f8903&amp;scene=21#wechat_redirect" target="_blank">数据库秒级平滑扩容架构方案</a><br></span></span></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1498052271&src=3&ver=1&signature=nULoNfhbsabgcFJEB9PUQ1KJasWOsq8hSo-mm4SVBUqXpDLOmbKmY46mI-tH6ASrpLYSYQojdSaCl4vWp*Xp7eiv71d0RFo9PrjKJjWzmkMfS-HMTOS4552dU8sTD7NGfu*3IppAb9N7u7ua9raN0QGAoUZ3ao0QkFWcSVqVzCs=">微信地址</a> | <a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960185&amp;idx=1&amp;sn=0acd4a563c8c9684373fd05c116c4441&amp;chksm=bd2d06a58a5a8fb3281acd95a7d9494161e75dcd27e95fdd526fce2b031ba79c4153bf255cee#rd">阅读原文</a>
{% endraw  %}

