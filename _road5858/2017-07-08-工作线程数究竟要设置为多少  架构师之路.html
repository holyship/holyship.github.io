---
title: 工作线程数究竟要设置为多少 | 架构师之路
author: 58沈剑
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1499656649&src=3&ver=1&signature=Hv6rg8SdYuiUQmONS3uvW1gSMMfgEt5EdAbfzM6PjFHlOYWGtySuV7QzFwUsJRtBEcZZtFpUZwXGF1fH9emhUbTPcYtU2ozVeWpvTDcTPUroO39DMthqd6k9g*2WHCuwgtvBgBb5RFn9E4G7Fsyko8tGtH84KUrj9LEUT9s1Msk=
date: '2017-07-08 00:00:00 +0000'

---

{% raw  %}
<p><span style="font-size: 18px;"><strong>&nbsp;<span style="line-height: 1.6; font-family: 宋体;">一、需求缘起</span></strong></span></p><p><span style="font-size: 14px;">Web-Server<span style="font-family: 宋体; font-size: 14px;">通常有个配置，<strong>最大工作线程数</strong>，后端服务一般也有个配置，工作线程池的<strong>线程数量</strong>，这个线程数的配置不同的业务架构师有不同的经验值，有些业务设置为</span>CPU<span style="font-family: 宋体; font-size: 14px;">核数的</span>2<span style="font-family: 宋体; font-size: 14px;">倍，有些业务设置为</span>CPU<span style="font-family: 宋体; font-size: 14px;">核数的</span>8<span style="font-family: 宋体; font-size: 14px;">倍，有些业务设置为</span>CPU<span style="font-family: 宋体; font-size: 14px;">核数的</span>32<span style="font-family: 宋体; font-size: 14px;">倍。</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="color: rgb(255, 104, 39); font-family: 宋体; font-size: 14px;">“工作线程数”的设置依据是什么，到底设置为多少能够最大化CPU性能</span><span style="font-family: 宋体; font-size: 14px;">，是本文要讨论的问题。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><h2><span style="font-size: 18px;"><strong><span style="font-family: 宋体;">二、共性认知</span></strong></span></h2><p><span style="font-family: 宋体; font-size: 14px;">在进行进一步深入讨论之前，先以提问的方式就一些共性认知达成一致。</span></p><p><span style="font-family: 宋体; font-size: 14px;"><br></span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">问：工作线程数是不是设置的越大越好？</span></strong></span></p><p><span style="font-family: 宋体; font-size: 14px;">答：<span style="color: rgb(255, 104, 39); font-family: 宋体; font-size: 14px;">肯定不是的</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">服务器</span>CPU<span style="font-family: 宋体; font-size: 14px;">核数有限，能够同时并发的线程数有限，单</span><span style="font-family: 宋体; font-size: 14px;">核</span>CPU<span style="font-family: 宋体; font-size: 14px;">设置</span>10000<span style="font-family: 宋体; font-size: 14px;">个工作线程没有意义</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">线程切换是有开销的，如果线程切换过于频繁，反而会使性能降低</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span><br></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">问：调用</span>sleep()</strong><strong><span style="font-family: 宋体; font-size: 14px;">函数的时候，线程是否一直占用</span>CPU</strong><strong><span style="font-family: 宋体; font-size: 14px;">？</span></strong></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">答：<span style="color: rgb(255, 104, 39); font-family: 宋体; font-size: 14px;">不占用</span>，等待时会把</span>CPU<span style="font-family: 宋体; font-size: 14px;">让出来，给其他需要</span>CPU<span style="font-family: 宋体; font-size: 14px;">资源的线程使用。</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">不止</span>sleep()<span style="font-family: 宋体; font-size: 14px;">函数，在进行一些阻塞调用时，例如网络编程中的：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><strong>阻塞</strong></span>accept()<span style="font-family: 宋体; font-size: 14px;">，等待客户端连接</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><strong>阻塞</strong></span>recv()<span style="font-family: 宋体; font-size: 14px;">，等待下游回包</span></span></p></li></ul><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">都不占用CPU资源。</span></span></p><p><span style="font-size: 14px;"></span><br></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">问：单核</span>CPU</strong><strong><span style="font-family: 宋体; font-size: 14px;">，设置多线程有意义么，是否能提高</span></strong></span><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">并发性能？</span></strong></span></p><p><span style="font-family: 宋体; font-size: 14px;">答：<span style="color: rgb(255, 104, 39); font-family: 宋体; font-size: 14px;">即使是单核，使用多线程也是有意义的，大多数情况也能提高并发</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><strong><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">多线程编码可以让</span><span style="font-family: 宋体; font-size: 14px;">代码更加清晰</span></span></strong><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">，例如：</span>IO<span style="font-family: 宋体; font-size: 14px;">线程收发包，</span>Worker<span style="font-family: 宋体; font-size: 14px;">线程进行任务处理，</span>Timeout<span style="font-family: 宋体; font-size: 14px;">线程进行超时检测</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">如果有一个任务一直占用</span>CPU<span style="font-family: 宋体; font-size: 14px;">资源在进行计算，此时增加线程并不能增加并发，例如以下代码会一直占用CPU，并使得CPU占用率达到100%：</span></span></p><p><span style="font-size: 12px;">&nbsp;while(1){ i++; }</span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><span style="color: rgb(255, 104, 39); font-family: 宋体; font-size: 14px;">通常来说</span>，</span>Worker<span style="font-family: 宋体; font-size: 14px;">线程一般不会一直占用</span>CPU<span style="font-family: 宋体; font-size: 14px;">进行计算，此时即使</span>CPU<span style="font-family: 宋体; font-size: 14px;">是单核，</span><span style="color: rgb(255, 104, 39); font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">增加</span>Worker<span style="font-family: 宋体; font-size: 14px;">线程也能够提高并发</span></span><span style="font-family: 宋体; font-size: 14px;">，因为这个线程在休息的时候，其他的线程可以继续工作</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><h2><span style="font-size: 18px;"><strong><span style="font-family: 宋体;">三、常见服务线程模型</span></strong></span></h2><p><span style="font-family: 宋体; font-size: 14px;">了解常见的服务线程模型，有助于理解服务并发的原理，一般来说互联网常见的服务线程模型有两种：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-family: 宋体; font-size: 14px;">IO线程与工作现场通过任务队列解耦</span></p></li><li><p><span style="font-family: 宋体; font-size: 14px;">纯异步</span></p></li></ul><p><span style="font-family: 宋体; font-size: 14px;"><br></span></p><p><span style="font-size: 14px;"><strong>IO</strong><strong><span style="font-family: 宋体; font-size: 14px;">线程与工作线程通过队列解耦类模型</span></strong></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz/YrezxckhYOxxdwicwqAoloPIfAMycKW160iciaY0RV9GHHLbOoMyEhj4kAicViaSMZQYxybjzFFIQfSmbRd3oTpQuIA/0?wx_fmt=png" style="width: 422px !important; height: 330px !important;"><br><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体; font-size: 14px;">如上图，大部分</span><span style="line-height: 1.6; font-size: 14px;">Web-Server</span><span style="line-height: 1.6; font-family: 宋体; font-size: 14px;">与服务框架都是使用这样的一种“</span><span style="line-height: 1.6; font-size: 14px;">IO</span><span style="line-height: 1.6; font-family: 宋体; font-size: 14px;">线程与</span><span style="line-height: 1.6; font-size: 14px;">Worker</span><span style="line-height: 1.6; font-family: 宋体; font-size: 14px;">线程通过队列解耦”类线程模型：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">有少数几个</span>IO<span style="font-family: 宋体; font-size: 14px;">线程</span></strong><span style="font-family: 宋体; font-size: 14px;">监听上游发过来的请求，并进行收发包（<span style="color: rgb(255, 104, 39); font-family: 宋体; font-size: 14px;">生产者</span>）</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><strong>有一个或者多个任务队列</strong>，作为</span>IO<span style="font-family: 宋体; font-size: 14px;">线程与</span>Worker<span style="font-family: 宋体; font-size: 14px;">线程异步解耦的数据传输通道（<span style="color: rgb(255, 104, 39); font-family: 宋体; font-size: 14px;">临界资源</span>）</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><strong>有多个工作线程</strong>执行正真的任务（<span style="color: rgb(255, 104, 39); font-family: 宋体; font-size: 14px;">消费者</span>）</span></span></p></li></ul><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">这个线程模型应用很广，符合大部分场景，这个线程模型的特点是，<strong>工作线程内部是同步阻塞执行任务的</strong>（回想一下</span>tomcat<span style="font-family: 宋体; font-size: 14px;">线程中是怎么执行</span>Java<span style="font-family: 宋体; font-size: 14px;">程序的，</span>dubbo<span style="font-family: 宋体; font-size: 14px;">工作线程中是怎么执行任务的），因此</span><span style="color: rgb(255, 104, 39); font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">可以通过增加</span>Worker<span style="font-family: 宋体; font-size: 14px;">线程数来增加并发能力</span></span><span style="font-family: 宋体; font-size: 14px;">，今天要讨论的重点是“该模型</span>Worker<span style="font-family: 宋体; font-size: 14px;">线程数设置为多少能达到最大的并发”。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">纯异步线程模型</span></strong></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">没有阻塞，这种线程模型只需要设置很少的线程数就能够做到很高的吞吐量，</span><span style="font-family: 宋体; font-size: 14px;">该模型的缺点是：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">如果使用单线程模式，难以利用多</span>CPU<span style="font-family: 宋体; font-size: 14px;">多核的优势</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">程序员更习惯写同步代码，</span>callback<span style="font-family: 宋体; font-size: 14px;">的方式对代码的可读性有冲击，对程序员的要求也更高</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">框架更复杂，往往需要</span>server<span style="font-family: 宋体; font-size: 14px;">端收发组件，</span>server<span style="font-family: 宋体; font-size: 14px;">端队列，</span>client<span style="font-family: 宋体; font-size: 14px;">端收发组件，</span>client<span style="font-family: 宋体; font-size: 14px;">端队列，上下文管理组件，有限状态机组件，超时管理组件的支持</span></span></p></li></ul><p><span style="font-size: 14px;"><br></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">文章《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959576&amp;idx=1&amp;sn=2be8d3f61effe7118abf920a175da710&amp;scene=21#wechat_redirect" target="_blank">RPC-client异步收发核心细节？</a>》中有更详细的介绍，<span style="font-size: 14px;">however<span style="font-family: 宋体; font-size: 14px;">，这个模型不是今天讨论的重点，</span></span></span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><h2><span style="font-size: 18px;"><strong><span style="font-family: 宋体;">四、工作线程的工作模式</span></strong></span></h2><p><span style="font-family: 宋体; font-size: 14px;">了解工作线程的工作模式，对量化分析线程数的设置非常有帮助：</span></p><p><img src="http://mmbiz.qpic.cn/mmbiz/YrezxckhYOxxdwicwqAoloPIfAMycKW16qTYL2nyXku8PkxicFEuJSQCFmwZtZOoOeTicjx4lBdp2TjvRItJInpNQ/0?wx_fmt=png" style="width: 241px !important; height: 459px !important;"><br><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体; font-size: 14px;">上图是一个典型的工作线程的处理过程，从开始处理</span><span style="line-height: 1.6; font-size: 14px;">start</span><span style="line-height: 1.6; font-family: 宋体; font-size: 14px;">到结束处理</span><span style="line-height: 1.6; font-size: 14px;">end</span><span style="line-height: 1.6; font-family: 宋体; font-size: 14px;">，该任务的处理共有</span><span style="line-height: 1.6; font-size: 14px;">7</span><span style="line-height: 1.6; font-family: 宋体; font-size: 14px;">个步骤：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">从工作队列里拿出任务，进行一些<strong>本地</strong>初始化计算，例如</span>http<span style="font-family: 宋体; font-size: 14px;">协议分析、参数解析、参数校验等</span></span></p></li><li><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">访问</span>cache</strong><span style="font-family: 宋体; font-size: 14px;">拿一些数据</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">拿到</span>cache<span style="font-family: 宋体; font-size: 14px;">里的数据后，再进行一些<strong>本地</strong>计算，这些计算和业务逻辑相关</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">通过</span><strong>RPC<span style="font-family: 宋体; font-size: 14px;">调用下游</span>service</strong><span style="font-family: 宋体; font-size: 14px;">再拿一些数据，或者让下游</span>service<span style="font-family: 宋体; font-size: 14px;">去处理一些相关的任务</span></span></p></li><li><p><span style="font-size: 14px;">RPC<span style="font-family: 宋体; font-size: 14px;">调用结束后，再进行一些<strong>本地</strong>计算，怎么计算和业务逻辑相关</span></span></p></li><li><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">访问</span>DB</strong><span style="font-family: 宋体; font-size: 14px;">进行一些数据操作</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">操作完数据库之后做一些收尾工作，同样这些收尾工作也是<strong>本地</strong>计算，和业务逻辑相关</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">分析整个处理的时间轴，会发现：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">其中</span>1<span style="font-family: 宋体; font-size: 14px;">，</span>3<span style="font-family: 宋体; font-size: 14px;">，</span>5<span style="font-family: 宋体; font-size: 14px;">，</span>7<span style="font-family: 宋体; font-size: 14px;">步骤中（上图中粉色时间轴），线程进行本地业务逻辑计算时<strong>需要占用</strong></span><strong>CPU</strong></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">而</span>2<span style="font-family: 宋体; font-size: 14px;">，</span>4<span style="font-family: 宋体; font-size: 14px;">，</span>6<span style="font-family: 宋体; font-size: 14px;">步骤中（上图中橙色时间轴），访问</span>cache<span style="font-family: 宋体; font-size: 14px;">、</span>service<span style="font-family: 宋体; font-size: 14px;">、</span>DB<span style="font-family: 宋体; font-size: 14px;">过程中线程处于一个等待结果的状态，<strong>不需要占用</strong></span><strong>CPU</strong><span style="font-family: 宋体; font-size: 14px;">，进一步的分解，这个“等待结果”的时间共分为三部分：</span></span></p><p style="text-indent:27px"><span style="font-size: 14px;">2.1<span style="font-family: 宋体; font-size: 14px;">）请求在网络上传输到下游的</span>cache<span style="font-family: 宋体; font-size: 14px;">、</span>service<span style="font-family: 宋体; font-size: 14px;">、</span>DB</span></p><p style="text-indent:27px"><span style="font-size: 14px;">2.2<span style="font-family: 宋体; font-size: 14px;">）下游</span>cache<span style="font-family: 宋体; font-size: 14px;">、</span>service<span style="font-family: 宋体; font-size: 14px;">、</span>DB<span style="font-family: 宋体; font-size: 14px;">进行任务处理</span></span></p><p style="text-indent:27px"><span style="font-size: 14px;">2.3<span style="font-family: 宋体; font-size: 14px;">）</span>cache<span style="font-family: 宋体; font-size: 14px;">、</span>service<span style="font-family: 宋体; font-size: 14px;">、</span>DB<span style="font-family: 宋体; font-size: 14px;">将报文在网络上传回工作线程</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><h2><span style="font-size: 18px;"><strong><span style="font-family: 宋体;">五、量化分析并合理设置工作线程数</span></strong></span></h2><p><span style="font-family: 宋体; font-size: 14px;">最后一起来回答工作线程数设置为多少合理的问题。</span></p><p><span style="font-family: 宋体; font-size: 14px;"><br></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">通过上面的分析，</span>Worker<span style="font-family: 宋体; font-size: 14px;">线程在执行的过程中，</span><span style="color: rgb(255, 104, 39); font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">有一部计算时间需要占用</span>CPU<span style="font-family: 宋体; font-size: 14px;">，另一部分等待时间不需要占用</span>CPU</span><span style="font-family: 宋体; font-size: 14px;">，通过量化分析，例如<strong>打日志进行统计</strong>，可以统计出整个</span><strong>Worker<span style="font-family: 宋体; font-size: 14px;">线程执行过程中这两部分时间的比例</span></strong><span style="font-family: 宋体; font-size: 14px;">，例如：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">执行计算，占用CPU的时间（粉色时间轴）是</span>100ms</span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">等待时间，不占用CPU的时间（橙色时间轴）也是</span>100ms</span></p></li></ul><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">得到的结果是，这个线程计算和等待的时间是</span>1<span style="font-family: 宋体; font-size: 14px;">：</span>1<span style="font-family: 宋体; font-size: 14px;">，即</span><span style="color: rgb(255, 104, 39); font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">有</span>50%<span style="font-family: 宋体; font-size: 14px;">的时间在计算（占用</span>CPU<span style="font-family: 宋体; font-size: 14px;">），</span>50%<span style="font-family: 宋体; font-size: 14px;">的时间在等待（不占用</span>CPU<span style="font-family: 宋体; font-size: 14px;">）</span></span><span style="font-family: 宋体; font-size: 14px;">：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">假设此时是<strong>单核</strong>，</span><span style="color: rgb(255, 104, 39); font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">则设置为</span>2<span style="font-family: 宋体; font-size: 14px;">个工作线程就可以把</span>CPU<span style="font-family: 宋体; font-size: 14px;">充分利用起来</span></span><span style="font-family: 宋体; font-size: 14px;">，让</span>CPU<span style="font-family: 宋体; font-size: 14px;">跑到</span>100%</span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">假设此时是</span><strong>N<span style="font-family: 宋体; font-size: 14px;">核</span></strong><span style="font-family: 宋体; font-size: 14px;">，</span><span style="color: rgb(255, 104, 39); font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">则设置为</span>2N<span style="font-family: 宋体; font-size: 14px;">个工作现场就可以把</span>CPU<span style="font-family: 宋体; font-size: 14px;">充分利用起来</span></span><span style="font-family: 宋体; font-size: 14px;">，让</span>CPU<span style="font-family: 宋体; font-size: 14px;">跑到</span>N*100%</span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">结论</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></p><p><span style="font-size: 14px;">N<span style="font-family: 宋体; font-size: 14px;">核服务器，通过执行业务的单线程分析出本地计算时间为</span>x<span style="font-family: 宋体; font-size: 14px;">，等待时间为</span>y<span style="font-family: 宋体; font-size: 14px;">，则工作线程数（线程池线程数）设置为</span> N*(x+y)/x<span style="font-family: 宋体; font-size: 14px;">，能让</span>CPU<span style="font-family: 宋体; font-size: 14px;">的利用率最大化。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">经验</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">一般来说，非</span>CPU<span style="font-family: 宋体; font-size: 14px;">密集型的业务（加解密、压缩解压缩、搜索排序等业务是</span>CPU<span style="font-family: 宋体; font-size: 14px;">密集型的业务），瓶颈都在后端数据库访问或者RPC调用，本地</span>CPU<span style="font-family: 宋体; font-size: 14px;">计算的时间很少，所以设置几十或者几百个工作线程是能够提升吞吐量的。</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><strong><span style="font-family: 宋体; font-size: 18px;">六<span style="font-family: 宋体;">、</span>总结</span></strong></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><strong><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">线程数不是越多越好</span></span></strong></p></li><li><p><strong><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">sleep()不占用CPU</span></span></strong></p></li><li><p><strong><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">单核设置多线程</span></span></strong><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">不但能使得代码清晰，还能提高吞吐量</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">站点和服务最常用的线程模型是“<strong><span style="font-family: 宋体; font-size: 14px;">IO线程与工作现场通过任务队列解耦</span></strong>”，此时设置多工作线程可以提升吞吐量</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><strong><span style="font-size: 14px;">N<span style="font-family: 宋体; font-size: 14px;">核服务器</span></span></strong><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">，通过日志分析出任务执行过程中，</span><strong><span style="font-family: 宋体; font-size: 14px;">本地计算时间为</span>x</strong><span style="font-family: 宋体; font-size: 14px;">，</span><strong><span style="font-family: 宋体; font-size: 14px;">等待时间为</span>y</strong><span style="font-family: 宋体; font-size: 14px;">，则工作线程数（线程池线程数）设置为</span><strong> N*(x+y)/x</strong><span style="font-family: 宋体; font-size: 14px;">，能让</span>CPU<span style="font-family: 宋体; font-size: 14px;">的利用率最大化</span></span></span></span></p></li></ul><p style="color: rgb(62, 62, 62); white-space: normal; word-wrap: break-word !important; min-height: 1em; max-width: 100%; box-sizing: border-box !important; background-color: rgb(255, 255, 255);"><span style="line-height: 1.6; font-size: 14px; word-wrap: break-word !important; max-width: 100%; box-sizing: border-box !important;"></span></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1499656649&src=3&ver=1&signature=Hv6rg8SdYuiUQmONS3uvW1gSMMfgEt5EdAbfzM6PjFHlOYWGtySuV7QzFwUsJRtBEcZZtFpUZwXGF1fH9emhUbTPcYtU2ozVeWpvTDcTPUroO39DMthqd6k9g*2WHCuwgtvBgBb5RFn9E4G7Fsyko8tGtH84KUrj9LEUT9s1Msk=">微信地址</a> | <a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960258&amp;idx=1&amp;sn=caf8295fa5c0ee47d6b9e6bf5cffcb49&amp;chksm=bd2d061e8a5a8f08374ddc84a3c59355368b840ab38ba97782947e02c0d9d6d3c289032b3d39#rd">阅读原文</a>
{% endraw  %}

