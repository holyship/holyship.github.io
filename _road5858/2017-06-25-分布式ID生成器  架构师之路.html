---
title: 分布式ID生成器 | 架构师之路
author: 58沈剑
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1499131416&src=3&ver=1&signature=iU4hCwtQzyv2pey6SDTnZ2C-mFRC1Hh3Dphb3zLBkqij4Jaanumtg17LZBDShHzuc5xEdFWfukz5FMlV5a5dB1NAvrbA5PHbQgVKt8HKMc2Tu3akXmcvyQIjV32Ur5REatix44VlCnqdvVEulCLLvTSIpFAN4zajooL3U0Loy0Y=
date: '2017-06-25 00:00:00 +0000'

---

{% raw  %}
<p><span style="font-size: 16px;"><strong><span style="font-family: 宋体;">一、需求缘起</span></strong></span></p><p><span style="font-family: 宋体; font-size: 14px;">几乎所有的业务系统，都有<span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;">生成一个唯一记录标识的需求</span>，例如：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">消息标识：</span>message-id</span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">订单标识：</span>order-id</span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">帖子标识：</span>tiezi-id</span></p></li></ul><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">这个记录标识往往就是数据库中的<span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;"><strong>主键</strong></span>，数据库上会建立<strong>聚集索引</strong>（</span>cluster index<span style="font-family: 宋体; font-size: 14px;">），即在物理存储上以这个字段排序。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-family: 宋体; font-size: 14px;">这个记录标识上的查询，往往又有<span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;">分页或者排序的业务需求</span>，例如：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">拉取最新的一页消息</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"></span><span style="font-size: 12px;">select message-id/ order by time/ limit 100</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">拉取最新的一页订单</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"></span><span style="font-size: 12px;">select order-id/ order by time/ limit 100</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">拉取最新的一页帖子</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"></span><span style="font-size: 12px;">select tiezi-id/ order by time/ limit 100</span></span></p></li></ul><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">所以往往要有一个</span>time<span style="font-family: 宋体; font-size: 14px;">字段，并且在</span>time<span style="font-family: 宋体; font-size: 14px;">字段上建立<strong>普通索引</strong>（</span>non-cluster index<span style="font-family: 宋体; font-size: 14px;">）。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">普通索引存储的是实际记录的指针，其访问效率会比聚集索引慢，如果记录标识在生成时能够基本按照时间有序，则可以省去这个</span>time<span style="font-family: 宋体; font-size: 14px;">字段的索引查询：</span></span></p><p><span style="font-size: 12px;">select message-id/ (order by message-id)/limit 100</span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">强调，能这么做的前提是，</span>message-id<span style="font-family: 宋体; font-size: 14px;">的生成基本是<span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;"><strong>趋势时间递增的</strong></span>。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">这就引出了记录标识生成（也就是上文提到的三个</span>XXX-id<span style="font-family: 宋体; font-size: 14px;">）的两大核心需求：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-family: 宋体; font-size: 14px;">全局唯一</span></p></li><li><p><span style="font-family: 宋体; font-size: 14px;">趋势有序</span></p></li></ul><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">这也是本文要讨论的核心问题：</span><span style="color: rgb(255, 41, 65); font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">如何高效生成趋势有序的全局唯一</span>ID<span style="font-family: 宋体; font-size: 14px;">。</span></strong></span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 16px;"><strong><span style="font-family: 宋体;">二、常见方法、不足与优化</span></strong></span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">方法一：使用数据库的&nbsp;</span><span style="background: white; color: rgb(51, 51, 51); font-family: Arial,sans-serif; font-size: 14px;">auto_increment&nbsp;</span><span style="background: white; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px;">来生成全局唯一递增</span><span style="background: white; color: rgb(51, 51, 51); font-family: Arial,sans-serif; font-size: 14px;">ID</span></strong></span></p><p><span style="font-size: 14px;"><strong><span style="background: white; color: rgb(51, 51, 51); font-family: Arial,sans-serif; font-size: 14px;"><br></span></strong></span></p><p><span style="font-size: 14px;"><strong><span style="background: white; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px;">优点：</span></strong></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="background: white; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px;">简单，使用数据库已有的功能</span></p></li><li><p><span style="font-family: 宋体; font-size: 14px;">能够保证唯一性</span></p></li><li><p><span style="font-family: 宋体; font-size: 14px;">能够保证递增性</span></p></li><li><p><span style="font-family: 宋体; font-size: 14px;">步长固定</span></p></li></ul><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;"><br></span></strong></span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">缺点：</span></strong></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">可用性难以保证：数据库常见架构是一主多从</span>+<span style="font-family: 宋体; font-size: 14px;">读写分离，生成自增</span>ID<span style="font-family: 宋体; font-size: 14px;">是写请求，<span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;">主库挂了就玩不转了</span></span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定</span>ID<span style="font-family: 宋体; font-size: 14px;">的生成性能上限，并且<span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;">难以扩展</span></span></span></p></li></ul><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;"><br></span></strong></span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">改进方法：</span></strong></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-family: 宋体; font-size: 14px;">冗余主库，避免写入单点</span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">数据水平切分，保证各主库生成的</span>ID<span style="font-family: 宋体; font-size: 14px;">不重复</span></span></p></li></ul><p><img src="http://mmbiz.qpic.cn/mmbiz/YrezxckhYOydMj2Lichnic5csTOdqI2a1mhuMcicyicr4Qgj6HSNbtS2jApdjkt8cpVrGzK75J6Kt4FtfdeD7ZzSQw/0?wx_fmt=png" style="width: 293px !important; height: 165px !important;"><br><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体;">如上图所述，由</span><span style="line-height: 1.6;">1</span><span style="line-height: 1.6; font-family: 宋体;">个写库变成</span><span style="line-height: 1.6;">3</span><span style="line-height: 1.6; font-family: 宋体;">个写库，</span><span style="color: rgb(255, 41, 65);"><strong><span style="line-height: 1.6; font-family: 宋体;">每个写库设置不同的</span><span style="line-height: 1.6; font-family: Arial,sans-serif; background-color: white;">auto_increment</span><span style="line-height: 1.6; font-family: 宋体; background-color: white;">初始值，以及相同的增长步长</span></strong></span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: 宋体; background-color: white;">，以保证每个数据库生成的</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: Arial,sans-serif; background-color: white;">ID</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: 宋体; background-color: white;">是不同的（上图中库</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: Arial,sans-serif; background-color: white;">0</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: 宋体; background-color: white;">生成</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: Arial,sans-serif; background-color: white;">0,3,6,9…</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: 宋体; background-color: white;">，库</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: Arial,sans-serif; background-color: white;">1</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: 宋体; background-color: white;">生成</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: Arial,sans-serif; background-color: white;">1,4,7,10</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: 宋体; background-color: white;">，库</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: Arial,sans-serif; background-color: white;">2</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: 宋体; background-color: white;">生成</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: Arial,sans-serif; background-color: white;">2,5,8,11…</span><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: 宋体; background-color: white;">）</span></span></p><p><span style="color: rgb(51, 51, 51); line-height: 1.6; font-family: 宋体; font-size: 14px; background-color: white;"><br></span></p><p><span style="background: white; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px;">改进后的架构保证了可用性，但<strong>缺点</strong>是：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="color: rgb(255, 41, 65); font-size: 14px;"><span style="font-family: 宋体; font-size: 14px; background-color: white;">丧失了</span><span style="font-family: Arial,sans-serif; font-size: 14px; background-color: white;">ID</span><span style="font-family: 宋体; font-size: 14px; background-color: white;">生成的“绝对递增性”</span></span><span style="background: white; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px;">：先访问库</span><span style="background: white; color: rgb(51, 51, 51); font-family: Arial,sans-serif; font-size: 14px;">0</span><span style="background: white; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px;">生成</span><span style="background: white; color: rgb(51, 51, 51); font-family: Arial,sans-serif; font-size: 14px;">0,3</span><span style="background: white; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px;">，再访问库</span><span style="background: white; color: rgb(51, 51, 51); font-family: Arial,sans-serif; font-size: 14px;">1</span><span style="background: white; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px;">生成</span><span style="background: white; color: rgb(51, 51, 51); font-family: Arial,sans-serif; font-size: 14px;">1</span><span style="background: white; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px;">，可能导致在非常短的时间内，</span><span style="background: white; color: rgb(51, 51, 51); font-family: Arial,sans-serif; font-size: 14px;">ID</span><span style="background: white; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px;">生成不是绝对递增的（这个问题不大，目标是趋势递增，不是绝对递增）</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">数据库的<span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;">写压力依然很大</span>，每次生成</span>ID<span style="font-family: 宋体; font-size: 14px;">都要访问数据库</span></span></p></li></ul><p><span style="font-family: 宋体; font-size: 14px;"><br></span></p><p><span style="font-family: 宋体; font-size: 14px;">为了解决上述两个问题，引出了第二个常见的方案。</span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">方法二：单点批量</span>ID<span style="font-family: 宋体; font-size: 14px;">生成服务</span></strong></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">数据库写压力大，是因为每次生成</span>ID<span style="font-family: 宋体; font-size: 14px;">都访问了数据库，可以<span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;">使用批量的方式降低数据库写压力</span>。</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz/YrezxckhYOydMj2Lichnic5csTOdqI2a1m25q9MHNcXic2sLBuuOYBdjF8ZLNopI71EMlZiaCMY5V2rPD2xqic0ZXog/0?wx_fmt=png" style="width: 225px !important; height: 132px !important;"><br><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体;">如上图所述，数据库使用双</span><span style="line-height: 1.6;">master</span><span style="line-height: 1.6; font-family: 宋体;">保证可用性，</span><span style="color: rgb(255, 41, 65);"><span style="line-height: 1.6; font-family: 宋体;">数据库中只存储当前</span><span style="line-height: 1.6;">ID</span><span style="line-height: 1.6; font-family: 宋体;">的最大值</span></span><span style="line-height: 1.6; font-family: 宋体;">，例如</span><span style="line-height: 1.6;">0</span><span style="line-height: 1.6; font-family: 宋体;">。</span></span></p><p><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体;"><br></span></span></p><p><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体;"></span><span style="line-height: 1.6;">ID</span><span style="line-height: 1.6; font-family: 宋体;">生成服务假设每次批量拉取</span><span style="line-height: 1.6;">6</span><span style="line-height: 1.6; font-family: 宋体;">个</span><span style="line-height: 1.6;">ID</span><span style="line-height: 1.6; font-family: 宋体;">，服务访问数据库，将当前</span><span style="line-height: 1.6;">ID</span><span style="line-height: 1.6; font-family: 宋体;">的最大值修改为</span><span style="line-height: 1.6;">5</span><span style="line-height: 1.6; font-family: 宋体;">，这样应用访问</span><span style="line-height: 1.6;">ID</span><span style="line-height: 1.6; font-family: 宋体;">生成服务索要</span><span style="line-height: 1.6;">ID</span><span style="line-height: 1.6; font-family: 宋体;">，</span><span style="line-height: 1.6;">ID</span><span style="line-height: 1.6; font-family: 宋体;">生成服务不需要每次访问数据库，就能依次派发</span><span style="line-height: 1.6;">0,1,2,3,4,5</span><span style="line-height: 1.6; font-family: 宋体;">这些</span><span style="line-height: 1.6;">ID</span><span style="line-height: 1.6; font-family: 宋体;">了。</span></span></p><p><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体;"><br></span></span></p><p><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体;">当</span><span style="line-height: 1.6;">ID</span><span style="line-height: 1.6; font-family: 宋体;">发完后，再将</span><span style="line-height: 1.6;">ID</span><span style="line-height: 1.6; font-family: 宋体;">的最大值修改为</span><span style="line-height: 1.6;">11</span><span style="line-height: 1.6; font-family: 宋体;">，就能再次派发</span><span style="line-height: 1.6;">6,7,8,9,10,11</span><span style="line-height: 1.6; font-family: 宋体;">这些</span><span style="line-height: 1.6;">ID</span><span style="line-height: 1.6; font-family: 宋体;">了，于是数据库的压力就降低到原来的</span><span style="line-height: 1.6;">1/6</span><span style="line-height: 1.6; font-family: 宋体;">。</span></span></p><p><span style="line-height: 1.6; font-family: 宋体; font-size: 14px;"><br></span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">优点</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">保证了</span>ID<span style="font-family: 宋体; font-size: 14px;">生成的绝对递增有序</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">大大的降低了数据库的压力，</span>ID<span style="font-family: 宋体; font-size: 14px;">生成可以做到每秒生成几万几十万个</span></span></p></li></ul><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;"><br></span></strong></span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">缺点</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;">服务仍然是单点</span></span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">如果服务挂了，服务重启起来之后，继续</span><span style="color: rgb(255, 41, 65); font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">生成</span>ID<span style="font-family: 宋体; font-size: 14px;">可能会不连续，中间出现空洞</span></span><span style="font-family: 宋体; font-size: 14px;">（服务内存是保存着</span>0,1,2,3,4,5<span style="font-family: 宋体; font-size: 14px;">，数据库中</span>max-id<span style="font-family: 宋体; font-size: 14px;">是</span>5<span style="font-family: 宋体; font-size: 14px;">，分配到</span>3<span style="font-family: 宋体; font-size: 14px;">时，服务重启了，下次会从</span>6<span style="font-family: 宋体; font-size: 14px;">开始分配，</span>4<span style="font-family: 宋体; font-size: 14px;">和</span>5<span style="font-family: 宋体; font-size: 14px;">就成了空洞，不过这个问题也不大）</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">虽然每秒可以生成几万几十万个</span>ID<span style="font-family: 宋体; font-size: 14px;">，但毕竟还是有性能上限，无法进行水平扩展</span></span></p></li></ul><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;"><br></span></strong></span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">改进方法</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></span></p><p><span style="font-size: 14px;"><span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;">单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”</span><span style="font-family: 宋体; font-size: 14px;">，所以我们能用以下方法优化上述缺点（</span>1<span style="font-family: 宋体; font-size: 14px;">）：</span></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz/YrezxckhYOydMj2Lichnic5csTOdqI2a1m2L4ibGZhV6wB1C7pEBrthNvylt7TicxVWfTTOBEqEdWtialMS80t0bfBQ/0?wx_fmt=png" style="width: 402px !important; height: 124px !important;"><br><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体;">如上图，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。</span></span></p><p><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体;"><br></span></span></p><p><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体;">这个切换的过程对调用方是透明的，可以自动完成，常用的技术是</span><span style="line-height: 1.6;">vip+keepalived</span><span style="line-height: 1.6; font-family: 宋体;">，具体就不在这里展开。</span></span></p><p><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体;"><br></span></span></p><p><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体;">另外，ID-gen-service也可以实施水平扩展，以解决上述缺点（3），但会引发一致性问题，具体解决方案详见《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960223&amp;idx=1&amp;sn=121716347174eedd6636b1c2c0b96047&amp;chksm=bd2d06438a5a8f55d35add7dc99940c280264fa7caeacb21f7dc79884d00c050d0367a745f87&amp;scene=21#wechat_redirect" target="_blank">浅谈CAS在分布式ID生成方案上的应用</a>》。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">方法三：</span>uuid/guid</strong></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">不管是通过数据库，还是通过服务来生成</span>ID<span style="font-family: 宋体; font-size: 14px;">，业务方</span>Application<span style="font-family: 宋体; font-size: 14px;">都需要进行一次远程调用，比较耗时。</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">有没有一种本地生成</span>ID<span style="font-family: 宋体; font-size: 14px;">的方法，即高性能，又时延低呢？</span></span></p><p><span style="font-size: 14px;"><br></span></p><p><span style="font-size: 14px;">uuid<span style="font-family: 宋体; font-size: 14px;">是一种常见的方案：</span></span></p><p><span style="font-family: 宋体; font-size: 14px;"></span><span style="font-size: 12px;">string ID =GenUUID();</span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;"><br></span></strong></span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">优点</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">本地生成</span>ID<span style="font-family: 宋体; font-size: 14px;">，不需要进行远程调用，时延低</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">扩展性好，基本可以认为没有性能上限</span></span></p></li></ul><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;"><br></span></strong></span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">缺点</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;">无法保证趋势递增</span></span></span></p></li><li><p><span style="font-size: 14px;"><span style="color: rgb(255, 41, 65); font-size: 14px;">uuid<span style="font-family: 宋体; font-size: 14px;">过长，往往用字符串表示，作为主键建立索引查询效率低</span></span><span style="font-family: 宋体; font-size: 14px;">，常见优化方案为</span>“<span style="font-family: 宋体; font-size: 14px;">转化为两个</span>uint64<span style="font-family: 宋体; font-size: 14px;">整数存储</span>”<span style="font-family: 宋体; font-size: 14px;">或者</span>“<span style="font-family: 宋体; font-size: 14px;">折半存储</span>”<span style="font-family: 宋体; font-size: 14px;">（折半后不能保证唯一性）</span></span></p></li></ul><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">方法四：取当前毫秒数</span></strong></span></p><p><span style="font-size: 14px;"><br></span></p><p><span style="font-size: 14px;">uuid<span style="font-family: 宋体; font-size: 14px;">是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串</span>ID<span style="font-family: 宋体; font-size: 14px;">检索效率低，有没有一种能<span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;">保证递增的本地算法呢</span>？</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">取当前毫秒数是一种常见方案：</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"></span><span style="font-size: 12px;">uint64 ID = GenTimeMS();</span></span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;"><br></span></strong></span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">优点</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">本地生成</span>ID<span style="font-family: 宋体; font-size: 14px;">，不需要进行远程调用，时延低</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">生成的</span>ID<span style="font-family: 宋体; font-size: 14px;">趋势递增</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">生成的</span>ID<span style="font-family: 宋体; font-size: 14px;">是整数，建立索引后查询效率高</span></span></p></li></ul><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;"><br></span></strong></span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">缺点</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">如果并发量超过</span>1000<span style="font-family: 宋体; font-size: 14px;">，会生成重复的</span>ID</span></p></li></ul><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">这个缺点要了命了，不能保证</span>ID<span style="font-family: 宋体; font-size: 14px;">的唯一性。当然，使用微秒可以降低冲突概率，但每秒最多只能生成</span>1000000<span style="font-family: 宋体; font-size: 14px;">个</span>ID<span style="font-family: 宋体; font-size: 14px;">，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题。</span></span></p><p><span style="font-size: 14px;">&nbsp;</span></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">方法五：类</span>snowflake<span style="font-family: 宋体; font-size: 14px;">算法</span></strong></span></p><p><span style="font-size: 14px;"><br></span></p><p><span style="font-size: 14px;">snowflake<span style="font-family: 宋体; font-size: 14px;">是</span>twitter<span style="font-family: 宋体; font-size: 14px;">开源的分布式</span>ID<span style="font-family: 宋体; font-size: 14px;">生成算法，其<span style="color: rgb(255, 41, 65); font-family: 宋体; font-size: 14px;"><strong>核心思想为，</strong></span>一个</span>long<span style="font-family: 宋体; font-size: 14px;">型的</span>ID：<span style="font-family: 宋体; font-size: 14px;"></span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"></span>41bit<span style="font-family: 宋体; font-size: 14px;">作为毫秒数</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"></span>10bit<span style="font-family: 宋体; font-size: 14px;">作为机器编号</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"></span>12bit<span style="font-family: 宋体; font-size: 14px;">作为毫秒内序列号</span></span></p></li></ul><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">算法单机每秒内理论上最多可以生成</span>1000*(2^12)<span style="font-family: 宋体; font-size: 14px;">，也就是</span>400W<span style="font-family: 宋体; font-size: 14px;">的</span>ID<span style="font-family: 宋体; font-size: 14px;">，完全能满足业务的需求。</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">借鉴</span>snowflake<span style="font-family: 宋体; font-size: 14px;">的思想，结合各公司的业务逻辑和并发量，可以实现</span><strong><span style="font-family: 宋体; font-size: 14px;">自己的分布式</span>ID<span style="font-family: 宋体; font-size: 14px;">生成算法</span></strong><span style="font-family: 宋体; font-size: 14px;">。</span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">举例，假设某公司</span>ID<span style="font-family: 宋体; font-size: 14px;">生成器服务的需求如下：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">单机高峰并发量小于</span>1W<span style="font-family: 宋体; font-size: 14px;">，预计未来</span>5<span style="font-family: 宋体; font-size: 14px;">年单机高峰并发量小于</span>10W</span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">有</span>2<span style="font-family: 宋体; font-size: 14px;">个机房，预计未来</span>5<span style="font-family: 宋体; font-size: 14px;">年机房数量小于</span>4<span style="font-family: 宋体; font-size: 14px;">个</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">每个机房机器数小于</span>100<span style="font-family: 宋体; font-size: 14px;">台</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">目前有</span>5<span style="font-family: 宋体; font-size: 14px;">个业务线有</span>ID<span style="font-family: 宋体; font-size: 14px;">生成需求，预计未来业务线数量小于</span>10<span style="font-family: 宋体; font-size: 14px;">个</span></span></p></li><li><p><span style="font-size: 14px;">…</span></p></li></ul><p><span style="font-family: 宋体; font-size: 14px;"><br></span></p><p><span style="font-family: 宋体; font-size: 14px;">分析过程如下：</span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">高位取从</span>2017<span style="font-family: 宋体; font-size: 14px;">年</span>1<span style="font-family: 宋体; font-size: 14px;">月</span>1<span style="font-family: 宋体; font-size: 14px;">日到现在的毫秒数（假设系统</span>ID<span style="font-family: 宋体; font-size: 14px;">生成器服务在这个时间之后上线），假设系统至少运行</span>10<span style="font-family: 宋体; font-size: 14px;">年，那至少需要</span>10<span style="font-family: 宋体; font-size: 14px;">年</span>*365<span style="font-family: 宋体; font-size: 14px;">天</span>*24<span style="font-family: 宋体; font-size: 14px;">小时</span>*3600<span style="font-family: 宋体; font-size: 14px;">秒</span>*1000<span style="font-family: 宋体; font-size: 14px;">毫秒</span>=320*10^9<span style="font-family: 宋体; font-size: 14px;">，差不多预留</span>39bit<span style="font-family: 宋体; font-size: 14px;">给毫秒数</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">每秒的单机高峰并发量小于</span>10W<span style="font-family: 宋体; font-size: 14px;">，即平均每毫秒的单机高峰并发量小于</span>100<span style="font-family: 宋体; font-size: 14px;">，差不多预留</span>7bit<span style="font-family: 宋体; font-size: 14px;">给每毫秒内序列号</span></span></p></li><li><p><span style="font-size: 14px;">5<span style="font-family: 宋体; font-size: 14px;">年内机房数小于</span>4<span style="font-family: 宋体; font-size: 14px;">个，预留</span>2bit<span style="font-family: 宋体; font-size: 14px;">给机房标识</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">每个机房小于</span>100<span style="font-family: 宋体; font-size: 14px;">台机器，预留</span>7bit<span style="font-family: 宋体; font-size: 14px;">给每个机房内的服务器标识</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">业务线小于</span>10<span style="font-family: 宋体; font-size: 14px;">个，预留</span>4bit<span style="font-family: 宋体; font-size: 14px;">给业务线标识</span></span></p></li></ul><p><img src="http://mmbiz.qpic.cn/mmbiz/YrezxckhYOydMj2Lichnic5csTOdqI2a1mC7utPZR12icoHP8UzEibcVetkkZHxWg3ZNhuItMhiboT2AvBWWKvnDlzA/0?wx_fmt=png" style="width: 393px !important; height: 48px !important;"><br><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体; font-size: 16px;"></span></span></p><p><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体; font-size: 16px;"><br></span></span></p><p><span style="font-size: 14px;"><span style="line-height: 1.6; font-family: 宋体;">这样设计的</span><span style="line-height: 1.6;">64bit</span><span style="line-height: 1.6; font-family: 宋体;">标识，可以保证：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">每个业务线、每个机房、每个机器生成的</span>ID<span style="font-family: 宋体; font-size: 14px;">都是不同的</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">同一个机器，每个毫秒内生成的</span>ID<span style="font-family: 宋体; font-size: 14px;">都是不同的</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">同一个机器，同一个毫秒内，以序列号区区分保证生成的</span>ID<span style="font-family: 宋体; font-size: 14px;">是不同的</span></span></p></li><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">将毫秒数放在最高位，保证生成的</span>ID<span style="font-family: 宋体; font-size: 14px;">是趋势递增的</span></span></p></li></ul><p><br></p><p><span style="font-size: 14px;"><strong><span style="font-family: 宋体; font-size: 14px;">缺点</span></strong><span style="font-family: 宋体; font-size: 14px;">：</span></span></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p><span style="font-size: 14px;"><span style="font-family: 宋体; font-size: 14px;">由于“没有一个全局时钟”，每台服务器分配的</span>ID<span style="font-family: 宋体; font-size: 14px;">是绝对递增的，但从全局看，生成的</span>ID<span style="font-family: 宋体; font-size: 14px;">只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）</span></span></p></li></ul><p><span style="font-family: 宋体; font-size: 14px;"><br></span></p><p><strong><span style="font-family: 宋体; font-size: 14px;">思路比方案重要</span></strong><span style="font-family: 宋体; font-size: 14px;">，<span style="color: rgb(255, 76, 0); font-family: 宋体; font-size: 14px;">顺手</span>帮转哟。</span></p><p><span style="font-family: 宋体; font-size: 14px;"><br></span></p><p><span style="font-family: 宋体; font-size: 14px;">相关推荐：</span></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960243&amp;idx=1&amp;sn=c5d0de35c6d87e08370eef4179ff66bb&amp;chksm=bd2d066f8a5a8f79a3478591e44054a1838e6aa8a35e544a5eb42b38cb274de6501a6b3b77e5&amp;scene=21#wechat_redirect" target="_blank"><span style="font-family: 宋体; font-size: 14px;">架构师之路2016全年精选</span></a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959886&amp;idx=1&amp;sn=03e45a5014053607eff5e55ed2c660d7&amp;chksm=bd2d07928a5a8e8454d395e176fa9d346682abfe9dfbf3244f1dead83ee4508aa25121f9b811&amp;scene=21#wechat_redirect" target="_blank"><span style="font-family: 宋体; font-size: 14px;">架构师之路2017上半年精选</span></a></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1499131416&src=3&ver=1&signature=iU4hCwtQzyv2pey6SDTnZ2C-mFRC1Hh3Dphb3zLBkqij4Jaanumtg17LZBDShHzuc5xEdFWfukz5FMlV5a5dB1NAvrbA5PHbQgVKt8HKMc2Tu3akXmcvyQIjV32Ur5REatix44VlCnqdvVEulCLLvTSIpFAN4zajooL3U0Loy0Y=">微信地址</a> | <a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960243&amp;idx=1&amp;sn=c5d0de35c6d87e08370eef4179ff66bb&amp;chksm=bd2d066f8a5a8f79a3478591e44054a1838e6aa8a35e544a5eb42b38cb274de6501a6b3b77e5#rd">阅读原文</a>
{% endraw  %}

