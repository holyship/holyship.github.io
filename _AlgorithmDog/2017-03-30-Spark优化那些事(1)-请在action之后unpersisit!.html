---
title: Spark优化那些事(1)-请在action之后unpersisit!
author: bourneli
date: '2017-03-30 00:00:00 +0000'

---

{% raw  %}
<p style=" margin-bottom: 15px; color: rgb(17, 17, 17) ; ; ; ; ; ; ">作者 bourneli 出身于湖北武汉。23岁时离开武汉，独自一人来到深圳实习并工作，一直到现在。bourneli 在鹅厂工作，工种是（大）数据民工，俗称“提包工程师”，用户包的“包”。业余时间爱写点技术博客，将碰到的问题和解决方案记录下来，方便后面回顾。博客地址: http://bourneli.github.io/</p><h2 style=" margin-bottom: 15px; font-size: 32px; white-space: normal; color: rgb(17, 17, 17) ; ; ; ; ">背景</h2><p style=" margin-bottom: 15px; color: rgb(17, 17, 17) ; ; ; ; ; ; ">最近在使用spark做一些图算法方面的工作，遇到了一些spark性能优化方面的坑，折腾了好久，最后通过各方面的努力，包括与同事讨论，阅读spark相关的原始论文，stackoverflow提问，google检索等，解决了一些，这里开个系列，总结相关内容。本博文是该系列第一篇，分享一个之前一直没有注意的事情，cache/persist后的rdd，没有使用就unpersist，等于白干。下面看看示例代码，</p><p><br></p><figure class="" style=" margin-bottom: 15px; background: rgb(255, 255, 255); color: rgb(17, 17, 17) ; ; ; ; ; "><pre style="margin-top: 0px; margin-bottom: 15px; padding: 8px 12px; font-size: 15px; border-width: 1px; border-style: solid; border-color: rgb(232, 232, 232); border-radius: 3px; background-color: rgb(238, 238, 255); overflow-x: auto;"><code class="" data-lang="scala" style="border-width: 0px; border-style: initial; border-color: initial; border-radius: 3px; padding-top: 1px; padding-bottom: 1px;"><span class="" style="font-weight: bold;">val</span> <span class="">rdd1</span> <span class="" style="font-weight: bold;">=</span> <span class="" style="font-weight: bold;">...</span> <span class="" style="color: rgb(153, 153, 136); font-style: italic;">// 读取hdfs数据，加载成RDD<br><br></span><span class="">rdd1</span><span class="" style="font-weight: bold;">.</span><span class="">cache<br><br></span><span class="" style="font-weight: bold;">val</span> <span class="">rdd2</span> <span class="" style="font-weight: bold;">=</span> <span class="">rdd1</span><span class="" style="font-weight: bold;">.</span><span class="">map</span><span class="" style="font-weight: bold;">(...)<br><br></span><span class="" style="font-weight: bold;">val</span> <span class="">rdd3</span> <span class="" style="font-weight: bold;">=</span> <span class="">rdd1</span><span class="" style="font-weight: bold;">.</span><span class="">filter</span><span class="" style="font-weight: bold;">(...)<br><br></span><span class="">rdd1</span><span class="" style="font-weight: bold;">.</span><span class="">unpersist</span><span class="">rdd2</span><span class="" style="font-weight: bold;">.</span><span class="">take</span><span class="" style="font-weight: bold;">(</span><span class="" style="color: rgb(0, 153, 153);">10</span><span class="" style="font-weight: bold;">).</span><span class="">foreach</span><span class="" style="font-weight: bold;">(</span><span class="">println</span><span class="" style="font-weight: bold;">)<br><br></span><span class="">rdd3</span><span class="" style="font-weight: bold;">.</span><span class="">take</span><span class="" style="font-weight: bold;">(</span><span class="" style="color: rgb(0, 153, 153);">10</span><span class="" style="font-weight: bold;">).</span><span class="">foreach</span><span class="" style="font-weight: bold;">(</span><span class="">println</span><span class="" style="font-weight: bold;">)</span></code></pre></figure><p><br></p><p style=" margin-bottom: 15px; color: rgb(17, 17, 17) ; ; ; ; ; ; ">上面代码的意图是：既然rdd1会被利用两次，那么就缓存起来，用完后释放内存。问题是，rdd1还没有被复用，就被“释放”了，导致rdd2,rdd3在执行take时，仍然需要从hdfs中加载rdd1,没有到达cache效果。</p><h2 style=" margin-bottom: 15px; font-size: 32px; color: rgb(17, 17, 17) ; ; ; ; ; ">原理</h2><p style=" margin-bottom: 15px; color: rgb(17, 17, 17) ; ; ; ; ; ; ">这里要从RDD的操作谈起，RDD的操作分为两类：action和tranformation。区别是tranformation输入RDD，输出RDD，而action输入RDD，输出非RDD。transformation是缓释执行的，action是即刻执行的。上面的代码中，hdfs加载数据，map，filter都是transformation，take是action。所以当rdd1加载时，并没有被调用，直到take调用时，rdd1才会被真正的加载到内存。</p><p style=" margin-bottom: 15px; color: rgb(17, 17, 17) ; ; ; ; ; ; ">cache和unpersisit两个操作比较特殊，他们既不是action也不是transformation。<a style="color: rgb(23, 86, 169);">cache会将标记需要缓存的rdd</a>，真正缓存是在第一次被相关action调用后才缓存；<a style="color: rgb(23, 86, 169);">unpersisit是抹掉该标记，并且立刻释放内存</a>。</p><p style=" margin-bottom: 15px; color: rgb(17, 17, 17) ; ; ; ; ; ; ">所以，综合上面两点，可以发现，在rdd2的take执行之前，rdd1，rdd2均不在内存，但是rdd1被标记和剔除标记，等于没有标记。所以当rdd2执行take时，虽然加载了rdd1，但是并不会缓存。然后，当rdd3执行take时，需要重新加载rdd1，导致rdd1.cache并没有达到应该有的作用，所以，正确的做法是将take提前到unpersist之前，如下：</p><p><br></p><figure class="" style=" margin-bottom: 15px; background: rgb(255, 255, 255); color: rgb(17, 17, 17) ; ; ; ; ; "><pre style="margin-top: 0px; margin-bottom: 15px; padding: 8px 12px; font-size: 15px; border-width: 1px; border-style: solid; border-color: rgb(232, 232, 232); border-radius: 3px; background-color: rgb(238, 238, 255); overflow-x: auto;"><code class="" data-lang="scala" style="border-width: 0px; border-style: initial; border-color: initial; border-radius: 3px; padding-top: 1px; padding-bottom: 1px;"><span class="" style="font-weight: bold;">val</span> <span class="">rdd1</span> <span class="" style="font-weight: bold;">=</span> <span class="" style="font-weight: bold;">...</span> <span class="" style="color: rgb(153, 153, 136); font-style: italic;">// 读取hdfs数据，加载成RDD<br><br></span><span class="">rdd1</span><span class="" style="font-weight: bold;">.</span><span class="">cache<br><br></span><span class="" style="font-weight: bold;">val</span> <span class="">rdd2</span> <span class="" style="font-weight: bold;">=</span> <span class="">rdd1</span><span class="" style="font-weight: bold;">.</span><span class="">map</span><span class="" style="font-weight: bold;">(...)<br><br></span><span class="" style="font-weight: bold;">val</span> <span class="">rdd3</span> <span class="" style="font-weight: bold;">=</span> <span class="">rdd1</span><span class="" style="font-weight: bold;">.</span><span class="">filter</span><span class="" style="font-weight: bold;">(...)<br><br></span><span class="">rdd2</span><span class="" style="font-weight: bold;">.</span><span class="">take</span><span class="" style="font-weight: bold;">(</span><span class="" style="color: rgb(0, 153, 153);">10</span><span class="" style="font-weight: bold;">).</span><span class="">foreach</span><span class="" style="font-weight: bold;">(</span><span class="">println</span><span class="" style="font-weight: bold;">)<br><br></span><span class="">rdd3</span><span class="" style="font-weight: bold;">.</span><span class="">take</span><span class="" style="font-weight: bold;">(</span><span class="" style="color: rgb(0, 153, 153);">10</span><span class="" style="font-weight: bold;">).</span><span class="">foreach</span><span class="" style="font-weight: bold;">(</span><span class="">println</span><span class="" style="font-weight: bold;">)<br><br></span><span class="">rdd1</span><span class="" style="font-weight: bold;">.</span><span class="">unpersist</span></code></pre></figure><p><br></p><p style=" margin-bottom: 15px; color: rgb(17, 17, 17) ; ; ; ; ; ; ">这样，rdd2执行take时，会先缓存rdd1，接下来直接rdd3执行take时，直接利用缓存的rdd1，最后，释放掉rdd1。</p><h2 style=" margin-bottom: 15px; font-size: 32px; color: rgb(17, 17, 17) ; ; ; ; ; ">总结</h2><p style=" margin-bottom: 15px; color: rgb(17, 17, 17) ; ; ; ; ; ; ">上面的问题经过简化，剔除噪声，所以显得很简单。但是在实际工作中，当rdd在经过若干的if else, while后，很容易迷失方向。所以，使用 RDD 开发迭代算法时，需要时刻注意 rdd 的缓存和释放，确保rdd在unpersisit之前被加载。这里推荐<a style="color: rgb(23, 86, 169);">Graphx Pregel</a>实现，很仔细的缓存和释放rdd，提高执行效率。</p><p><br></p><p>原文链接:http://bourneli.github.io/scala/spark/2016/06/17/spark-unpersist-after-action.html</p>
{% endraw  %}

