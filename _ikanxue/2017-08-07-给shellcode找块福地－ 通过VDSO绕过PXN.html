---
title: 给shellcode找块福地－ 通过VDSO绕过PXN
author: ggggwwww
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1502116456&src=3&ver=1&signature=fMd4ZeYncDjRuvdiU8EiAqzwJV-51HguOx4pnyGlqXjJ10eFEeoZU*4ykBfJ5DfCcbB*9QgBsAKzwmoYzWJII8jRjj4wVqUTfa6-DtUQlGxqdKyX--0uAt1orV7g9rlV39SSwFtcRX6Iy0HOTk6WRalbrlD68d9uc4JYC1khLMY=
date: '2017-08-07 00:00:00 +0000'

---

{% raw  %}
<p style="margin: 20px 8px; line-height: 1.75em;"><br></p><p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1UG7KPNHN8Hfq33iaeiaP4IZIh0WkmVYok6TpHWDodF7fj3bkFsvTzI33ABXb0qQUSWibpjVdFkOKHxJc46ia9zQqQ/0?wx_fmt=jpeg" style="width: 612px !important; height: 408px !important;"></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span><br></p><section style="background-color: rgb(255, 255, 255); box-sizing: border-box;"><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">0x01 引语</span></strong></p></section></section></section></section><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span><br></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">近日看雪论坛里有个兄弟在写漏洞利用的时候遇到了点问题。他发现rop实现提权的方式在不同设备版本适配的时候比较麻烦,需要做的工作较多。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">他想知道有没有更好更稳定的方式，绕过PXN让内核执行shellcode。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">最近一年，一种利用VDSO( Virtual Dynamic Shared Object，虚拟动态共享对象)机制的攻击方式，在脏牛（DirtyCow）等漏洞利用代码中得到应用。本文将介绍这种新型的绕过PXN的攻击方式。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"><br></span></p><section style="background-color: rgb(255, 255, 255); box-sizing: border-box;"><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">0x02 回顾PXN</span></strong></p></section></section></section></section><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span><br></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">PXN(&nbsp;PrivilegedExecute-Never)&nbsp;“特权执行从不”技术由ARM公司提出，主要防御RET2USR的攻击，它的开启与否主要由页表属性的PXN位来控制。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GsSoLEoCcmgHAWrnWlZ3czmATFrz4p3GG4ExJTApNv9iboCYDfHJBGlDOA0UtFZVYeZruUnkRHMgQ/0?wx_fmt=png" style="width: 692px !important; height: 496px !important;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"> 64位内核中，内核对用户空间的内存页默认开启PXN位。通过设置PXN位，内核就不能直接执行用户空间的攻击代码，从而有效防御RET2USR攻击。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GsSoLEoCcmgHAWrnWlZ3cz84XqAltQa2ZomyeRb1jT9ArwImHppvVM9XeBNYgOLaObMaJrypojiaw/0?wx_fmt=png" style="width: 505px !important; height: 400px !important;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">&nbsp;<br></span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"><br></span></p><section style="background-color: rgb(255, 255, 255); box-sizing: border-box;"><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">0x03 传统的PXN绕过技术</span></strong></p></section></section></section></section><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span><br></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">1）利用ROP技术绕过PXN</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">其主要原理是通过控制内存中的一段数据，通过控制数据来控制代码执行流，如组合执行内核中特定的代码片段，从而达到修改内核中的关键数据，达到提权限的目的。这种攻击方式是需要进行不同机型中查找到多段代码片段，如果需要root的机型较多，则需要攻击者投入较多精力去做适配，另外由于ROP往往要做栈迁移，使得漏洞利用的稳定性不是很好。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">2) 利用RET2DIR技术绕过PXN</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">该技术由哥伦比亚大学在2014年提出，其利用原理是，linux内核在设计的时候，为了提高内存的操作效率，在用户空间映射内存的时候，内核也相应地在内核的低端内存区地址映射一段影子内存。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">同样，攻击者也可以将用户空间的攻击代码映射到内核的低端内存可执行区或者将特定数据进行喷射到内核的低端内存，进行内存布局，然后利用发现的漏洞，让内核执行攻击代码，从而达到提权的作用。这项技术在32位arm设备上有60%以上的成功率，而在64位arm中有96%的成功率。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">通过RET2DIR和JOP方式的结合，可以使得UAF这类漏洞的利用代码比较稳定，而且成功率较高。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">keen_team在cve-2015-3636的漏洞利用中使用这两个技术后，一时间RET2DIR成为漏洞利用的“倚天剑”。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">不过在2016年七月google在android PIXEL(内核3.18-16.04)版本以后封杀了RET2DIR的攻击方式。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GsSoLEoCcmgHAWrnWlZ3czfXr2nfd3odsQJic4hakKRqL8jzQhH6TwU4bianFdTicKib0sqLzNvK8ZNw/0?wx_fmt=png" style="width: 691px !important; height: 265px !important;"></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">3) 通过修改寄存器绕过pxn<br></span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">我们可以通过修改CP15/CR4寄存器信息来绕过PXN/SMEP。这种方式往往需要ROP一段内核的代码来修改CP15寄存器的值，其复杂度和ROP其实是一样的。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">4) 通过内核特定函数完成PXN绕过</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">该技术在2016年MOSEC大会上由360团队公开，该技术巧妙地利用kernel_setsockopt函数的特性，通过控制r0，让内核执行set_fs(KERNEL_DS)，实现任意地址读写权限的效果。这种方式在x64内核时需要进行ROP栈迁移，复杂度较高。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">那有没有更好的方式，给SHELLCODE安营扎寨，让内核执行我们的提权代码呢？</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"><br></span></p><section style="background-color: rgb(255, 255, 255); box-sizing: border-box;"><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">0x04&nbsp; 新的攻击方法</span></strong></p></section></section></section></section><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span><br></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">由于linux内核是个庞大且复杂的系统，一定还有这样的“福地”，让我们可以在内核中找到，空间任意执行我们的ShellCode。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">近年攻击者把目标放在了内核和用户空间共享的代码空间－VDSO( Virtual Dynamic Shared Object，虚拟动态共享对象)。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">VDSO是内核为了减少内核与用户空间频繁切换，提高系统调用效率而提出的机制。特别是gettimeofday这种对时间精度要求特别高的系统调用，需要尽可能地减少用户空间到内核空间堆栈切换的开销。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">&nbsp;<img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GsSoLEoCcmgHAWrnWlZ3czm8hPWU6MxAj2W11iaIzMKKXGLHy0mxTlzN5eWNrgKAJAiccwffE8wraA/0?wx_fmt=png" style="width: 692px !important; height: 463px !important;"></span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">我们可以通过cat /proc/self/maps命令来查看用户态vdso映射情况。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GsSoLEoCcmgHAWrnWlZ3czYTjFSG6DyWsJCbBrfWFS1IIqOY0icbX7fn7iaPn8NXAmepvxyjHfVCUg/0?wx_fmt=png" style="width: 691px !important; height: 388px !important;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">由于该段用户空间和内核空间是一一映射的， 如果我们能在这段空间中布置我们的提权代码，我们可以让内核来执行该段代码，从而提权。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">不过事情没有想象那么容易，该段空间是只读和可执行的。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">通过阅读内核的代码，我们可以发现,如果我们可以把这段映射区改为可读可写可执行就可以了。&nbsp; <br></span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span></p><p style="margin-left: 8px; margin-right: 8px;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GsSoLEoCcmgHAWrnWlZ3czB6fDv7zicgNQznu1dfwk9GGIncTqzNlhhsK2U78v4iaIEWTYVIwMIu9g/0?wx_fmt=png" style="width: 415px !important; height: 286px !important;"></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">我们可以通过利用内核中现成的代码来完成页表属性的修改。我们发现可以通过内核导出函数set_memory_rw来打开内核页表的读写权限。set_memory_rw函数的定义如下：</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">int set_memory_rw(unsigned long virt, int numpages)</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">&nbsp;</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">virt 为起始虚拟地址，可以设置为_text的虚拟地址，</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">numpages 为页表的数量。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">假设我们可以修改vdso映射区的读写权限，那我们的攻击路径可以是这样:</span></p><p style="line-height: 1.75em; margin: 20px 8px;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">1. 利用内核漏洞的执行set_memory_rw函数，修改vdso映射区的读写权限。</span></p><p style="line-height: 1.75em; margin: 20px 8px;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">2. 在VDSO布置shellcode。</span></p><p style="line-height: 1.75em; margin: 20px 8px;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">3. 调用shellcode提权。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">那问题来了，用户态的vdso的虚拟地址是多少呢。&nbsp; </span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">在高版本的glibc中，我们可以通过以下代码获得vdso的地址。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span></p><p style="margin-left: 8px; margin-right: 8px;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GsSoLEoCcmgHAWrnWlZ3czib7M1sClaO7ZSWSRjUklIM3MrEjtS9H91PAibbkfqZU4rIgynAmOu7jQ/0?wx_fmt=png" style="width: 422px !important; height: 216px !important;"></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">当然我们也可以通过读取/proc/selft/maps虚拟文件内容的方式获得用户态的vdso映射地址。我们的攻击路径可以进一步再完善为：</span></p><p style="line-height: 1.75em; margin: 20px 8px;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">1. 获取vdso的映射地址。</span></p><p style="line-height: 1.75em; margin: 20px 8px;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">2. 利用内核漏洞的执行set_memory_rw函数，修改vdso映射区的读写权限。</span></p><p style="line-height: 1.75em; margin: 20px 8px;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">3. 在VDSO布置shellcode。</span></p><p style="line-height: 1.75em; margin: 20px 8px;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">4. 调用shellcode提权。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"><br></span></p><section style="background-color: rgb(255, 255, 255); box-sizing: border-box;"><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">0x05&nbsp; 布置shellcode</span></strong></p></section></section></section></section><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span><br></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">内核映射到用户空间的vdso其实为一个完整的ELF文件。该文件一般为，这里面包括了代码段和数据段。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GsSoLEoCcmgHAWrnWlZ3czQWJIQEtaBOfqibicM7Ks3QOqhhJP5AX8rZLhPEVYWtwrPGTlkh4Rv7Hg/0?wx_fmt=png" style="width: 669px !important; height: 496px !important;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"> 在ARM64内核的vdso区导出了四个函数，它们分别是<span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;">__kernel_clock_getres、__kernel_rt_sigreturn、__kernel_gettimeofday、__kernel_clock_gettime。</span></span></p><p style="margin: 20px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GsSoLEoCcmgHAWrnWlZ3cz4R9wQT0wcVVZDujA33EKLPSBysVLgowrxQCfVyWiaaPpls099wvtIHw/0?wx_fmt=png" style="width: 723px !important; height: 230px !important;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">我们可以在代码段末段放置我们的shellcode，然后以in-hook的方式hook gettimeofday函数,当用户调用gettimeofday函数时将会执行我们放置在vdso中的shellcode，在安卓版脏牛的vdso poc代码中就用到了这种方式。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">当然我们也可以直接通过计算elf文件的长度，然后在文件长度的末端放置我们的shellcode，然后让内核去执行该段地址的代码即可。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"><br></span></p><section style="background-color: rgb(255, 255, 255); box-sizing: border-box;"><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">0x06 进一步完善攻击路径</span></strong></p></section></section></section></section><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span><br></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">在很多情况下，我们利用的内核漏洞不一定是任意代码执行这一类的，我们利用的内核漏洞也可能是任意地址写任意值的这类漏洞。那这种情况下我们需要通过任意地址写转变成任意代码执行。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">我们常见的方法是通过调用改写 ptmx_fops-&gt;unlocked_ioctl 或者是 覆盖ptmx_fops指针，使其指向我们要调用内核地址，然后调用 /dev/ptmx 的ioctl或者是check_flags来完成内核代码的调用。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">由于这种方式需要进行较复杂的反汇编及偏移计算才能确定unlocked_ioctl的地址，另外check_flags函数只能传递一个参数，而且该函数只能传递一个32位的数据 ,显然这种方式需要我们进一步的改进。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">那什么样的函数指针是比较好用的呢，我们要求这样的函数指针最好满足以下条件：&nbsp; </span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">第一、可以传送多个参数。&nbsp; </span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">第二、该函数指针可以在符号表里方便找到。&nbsp; </span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">第三、这个函数调用函数指针前，各个参数都是透传，没有经过中间加工。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">第四、函数返回值也没有经过内部加工。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">在2016年11月韩国INetCop 安全团队的 dong-hoon you (x82)介绍了一个十分好用的系统调用函数 prtcl。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">这个函数可以最多传输1～5个参数。&nbsp; 它的调用路径是这样的：</span></p><blockquote><p style="margin: 20px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;">prctl-&gt;security_task_prctl-&gt; (security_operations)-&gt;task_prctl 。</span></p></blockquote><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">如果我们修改(security_operations)-&gt;task_prctl为我们调用的set_memory_rw函数地址。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">那么我们通过用户态调用prtcl函数，使得内核就可以执行set_memory_rw函数，打开VDSO映射区的读写权限。&nbsp;&nbsp; <br></span></p><p style="line-height: 1.75em; margin: 20px 8px;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">1. 获取vdso的映射地址。</span></p><p style="line-height: 1.75em; margin: 20px 8px;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">2. 利用内核漏洞任意地址写的能力将(security_operations)-&gt;task_prctl 函数指针修改为set_memory_rw函数的地址。</span></p><p style="line-height: 1.75em; margin: 20px 8px;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">3. 调用prtcl的系统调用,让内核执行set_memory_rw函数，修改vdso映射区的读写权限。</span></p><p style="line-height: 1.75em; margin: 20px 8px;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">4. 在VDSO中布置shellcode。</span></p><p style="line-height: 1.75em; margin: 20px 8px;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">5. 调用gettimeofday函数或通过prtcl的系统调用，让内核调用shellcode提权。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"><br></span></p><section style="background-color: rgb(255, 255, 255); box-sizing: border-box;"><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">0x07 总结</span></strong></p></section></section></section></section><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span><br></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">针对内核ROP攻击等绕过PXN技术的不足，本文介绍了基于VDSO机制的新绕过PXN的方法。这种方法使得攻击代码能够轻松绕过PXN限制，多快好省地执行我们的提权代码。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">除了介绍基于VDSO机制的新绕过PXN的方法，本文还介绍了prctl函数在漏洞利用中的运用。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);">后续我们将继续介绍其他新型的绕过PXN方法，敬请期待。</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"><br></span></p><section style="background-color: rgb(255, 255, 255); box-sizing: border-box;"><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">0x08参考资料</span></strong></p></section></section></section></section><p style="margin: 20px 8px; line-height: 1.75em;"><span style="letter-spacing: 2px; font-size: 15px; color: rgb(63, 63, 63);"></span><br></p><p style="margin: 20px 8px; line-height: 1.75em;"><em><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;">1. Johan Petersson，What is linux-gate.so.1?, </span></em></p><p style="margin: 20px 8px; line-height: 1.75em;"><em><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;">http://www.trilithium.com/johan/2005/08/linux-gate/</span></em></p><p style="margin: 20px 8px; line-height: 1.75em;"><em><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;">2. INetCop Security dong-hoon you (x82)， New Reliable Android Kernel Root Exploitation Techniques,</span></em></p><p style="margin: 20px 8px; line-height: 1.75em;"><em><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;">http://powerofcommunity.net/poc2016/x82.pdf</span></em></p><p style="margin: 20px 8px; line-height: 1.75em;"><em><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;">3. Vasileios P. Kemerlis Michalis Polychronakis Angelos D. Keromytis， Columbia Universityret2dir: Rethinking Kernel Isolation,&nbsp; http://www.blackhat.com/docs/eu-14/materials/eu-14-Kemerlis-Ret2dir-Deconstructing-Kernel-Isolation.pdf</span></em></p><p style="margin: 20px 8px; line-height: 1.75em;"><em><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;"></span></em></p><p><br></p><section label="Copyright © 2014 playhudong All Rights Reserved." style="border-width: medium; border-color: currentcolor; -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; border-style: none; margin: 5px 0px 0px; padding: 10px 0px; background: rgba(0, 0, 0, 0) none repeat scroll 0% 0%;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8G9B6YFlthnv1h3cWDDXGAmK9wQfy6pod114tTuOSIFVeVd0vd1PEwicksgBGmxL0iaC0icX7B9EQzNg/640?wx_fmt=png" style="margin: 0px auto; display: block; visibility: visible !important; width: 160px !important; height: 8.44575px !important;"></section><p><br></p><p><br></p><p style="letter-spacing: 1px; margin: 15px 1em; text-align: center; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">本文由看雪论坛 ggggwwww 原创，转载请注明来自看雪社区</span></p><p style="text-align: center;"><br></p><p style="text-align: center;"><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1UG7KPNHN8HFWP586ic3Pf4F6hD1rnmHpScQgCs4x9dJWoHHNnoiamW5RMTq8alBq5UiahM3G1W9TK3RPXQHXWZUQ/640?wx_fmt=jpeg" style="visibility: visible !important; width: 770px !important; height: 381.992px !important;"></p><p style="text-align: center;"><br></p><p style="letter-spacing: 1px; margin: 15px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 16px; color: rgb(63, 63, 63);">热门阅读</span></p><ul style="list-style-type: disc;" class="list-paddingleft-2"><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284365&amp;idx=1&amp;sn=ec442a2de4c753a2ffb899168276debf&amp;chksm=b18141c786f6c8d19beb57641b6b18a000da46da2b9bedb72f2bb655f8f2bb27290fe6526e4f&amp;scene=21#wechat_redirect" target="_blank">CTF取证类题目指南</a></span></p></li><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284324&amp;idx=1&amp;sn=72487148429cc697d79becdc237779ce&amp;chksm=b18141ae86f6c8b8fee96bd9546afa740d3697d727bd7265d0d748d35221df0c013979579a13&amp;scene=21#wechat_redirect" target="_blank">嵌入式设备硬件PCB级逆向</a><br></span></p></li><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284361&amp;idx=1&amp;sn=4387782057503a16864581ab9337b78e&amp;chksm=b18141c386f6c8d5bc76dafbd713de485d63dd26b5f013a634f479c833c97471fa9915d66959&amp;scene=21#wechat_redirect" target="_blank">搭建一个Fake AP 接入点的教程</a><br></span></p></li><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284298&amp;idx=2&amp;sn=771546cd763617327ffd6a11a9d14e97&amp;chksm=b181418086f6c896fe7a64c473281613409dcaaf672de9f5b62605e3fb765bad4fe95a86df1f&amp;scene=21#wechat_redirect" target="_blank">Web 应用中最愚蠢的安全错误，前5名</a></span></p></li><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284361&amp;idx=4&amp;sn=8865dd636391fa78f29e5be6592dcec5&amp;chksm=b18141c386f6c8d5bb3e6221320b5becd3560e0cb433d836c3018a63136c23d6f89a1bf53183&amp;scene=21#wechat_redirect" target="_blank">议题征集 | 2017 安全开发者峰会</a><br></span></p></li></ul><p style="text-align: center;"><br></p><p style="text-align: center;"><br></p><p style="text-align: center;"><span style="font-size: 15px; background-color: rgb(178, 178, 178); color: rgb(63, 63, 63);">点击阅读原文/read，还有更多干货等着你~</span></p><p style="margin: 20px 8px; line-height: 1.75em;"><em><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;"></span></em><br></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1502116456&src=3&ver=1&signature=fMd4ZeYncDjRuvdiU8EiAqzwJV-51HguOx4pnyGlqXjJ10eFEeoZU*4ykBfJ5DfCcbB*9QgBsAKzwmoYzWJII8jRjj4wVqUTfa6-DtUQlGxqdKyX--0uAt1orV7g9rlV39SSwFtcRX6Iy0HOTk6WRalbrlD68d9uc4JYC1khLMY=">微信地址</a> | <a href="http://bbs.pediy.com/thread-220057.htm">阅读原文</a>
{% endraw  %}

