---
title: 从内核角度分析 Dirty Cow 原理
author: ghostway
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1499131012&src=3&ver=1&signature=iU4hCwtQzyv2pey6SDTnZ62YXf1MWi8Zh8usUjq2T6Tp8olMm-6I1I4qsl-rYUzkEslKlH6cxolxoLxftDKuPoRYJ3NwX405l3Sx16vioe0gp0jag8eTAhoLCiXu4U8wCJDRG9M6B15Lpk1MCgv3HLQWXBsJTBSL45dXSofs5jk=
date: '2017-06-28 00:00:00 +0000'

---

{% raw  %}
<h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 18px; background-color: rgb(0, 0, 0); color: rgb(255, 251, 0);"><strong><span style="font-size: 18px; background-color: rgb(0, 0, 0);">介绍</span></strong></span></h3><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">虽然已经有很多文章和博客贴出了该漏洞的利用，但是没有一个给出从内核角度分析Dirty Cow原理的详细描述。如下的分析是基于这个</span><span style="font-size: 15px; color: rgb(63, 63, 63);">Dirty Cow POC</span><span style="color: rgb(63, 63, 63);"><span style="color: rgb(63, 63, 63); font-size: 15px;">的，同样的思路也适用于其他相似的攻击。例子代码很短，最重要的是两个线程的操作：一个线程调用write(2)写/proc/self/mem，另一个线程调用madvice(MADV_DONTNEED)。由于这两个线程操作的相互竞争，当wirte(2)直接修改基于文件的内存映射时（即使涉及到的文件不允许被攻击者进程写）会产生一个安全问题，最终导致提权。&nbsp;</span></span><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></h3><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">该文章颇重于技术层面，故假设读者已经掌握了如下的基本技术点：</span></h3><ul style="margin-bottom: 10px; color: rgb(51, 51, 51); font-family: none; font-size: 16px;" class="list-paddingleft-2"><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">Virtual Memory（虚拟内存）</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">Pages（页）</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">Page Fault（页错误）</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">Copy-on-Write（写时复制）</span></p></li></ul><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 16px; background-color: rgb(0, 0, 0); color: rgb(255, 251, 0);"><strong><span style="font-size: 16px; background-color: rgb(0, 0, 0);">如何实现攻击</span></strong></span></h3><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">尽管我们最终是想写入，然而代码首先会以只读的方式O_RDONLY来打开open一个特定的文件，这样做的目的是为了让内核”happy”，由于我们目前只有比较低的权限，无法写入特定的文件。在成功打开并获取了文件描述符之后，立即调用mmap来映射该文件。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUqKIBfD4iayiaG9rdES9XJxDmRbb6D3EOVDicZW79t6CvzwP4v8KprrjZ9A/0?wx_fmt=png" style="width: 456px !important; height: 322px !important; visibility: visible !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">调用函数mmap在进程的虚拟地址空间中创建了一个基于文件的（file-backed）的只读的内存映射，内核中通过结构struct vm_area_struect来描述该内核对象，其包含映射的文件描述符，对于映射的页的读写权限等一些信息。之后创建了两个线程，一个调用madvice，另一个调用write。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUqBhh8Il2IoJG8X02UxLLia1yyvyDBE4lBdq10HCeK15Bbuiad6Sawiaywg/0?wx_fmt=png" style="width: 417px !important; height: 55px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">首先看下madviseThread做了什么：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUqOddpwQW5eufUDOUwbL8LBkRQmttcB9mTGiaWbViaBKnAclgId3lLd03Q/0?wx_fmt=png" style="width: 739px !important; height: 267px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">madvise(MADV_DONTNEED)基本功能是清除被管理的内存映射的物理页。就当前情况而言， 在调用完该函数后，提到的这些页将被clear。当下一次用户尝试访问这些内存区域时，原始的内容会重新从磁盘或者页缓存中导入，而对于匿名的堆内存，则会填充零。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">官方文档解释如下：<br></span></p><section label="Copyright Reserved by PLAYHUDONG." style="padding: 0.5em 1em; border-style: none; background: rgb(235, 235, 235) none repeat scroll 0% 0%;"><section style="padding: 16px; line-height: 2.4;"><span style="font-size: 15px; color: rgb(63, 63, 63);">MADV_DONTNEEDDo&nbsp;not&nbsp;expect&nbsp;access&nbsp;in&nbsp;the&nbsp;near&nbsp;future.&nbsp;(For&nbsp;the&nbsp;time&nbsp;being,&nbsp;the&nbsp;application&nbsp;is&nbsp;finished&nbsp;with&nbsp;the&nbsp;given&nbsp;range,&nbsp;so&nbsp;the&nbsp;kernel&nbsp;can&nbsp;free&nbsp;resources&nbsp;associated&nbsp;with&nbsp;it.)&nbsp;Subsequent&nbsp;accesses&nbsp;of&nbsp;pages&nbsp;in&nbsp;this&nbsp;range&nbsp;will&nbsp;succeed,&nbsp;but&nbsp;will&nbsp;result&nbsp;either&nbsp;in&nbsp;reloading&nbsp;of&nbsp;the&nbsp;memory&nbsp;contents&nbsp;from&nbsp;the&nbsp;underlying&nbsp;mapped&nbsp;file&nbsp;(see&nbsp;mmap(2))&nbsp;or&nbsp;zero-fill-on-demand&nbsp;pages&nbsp;for&nbsp;mappings&nbsp;without&nbsp;an&nbsp;underlying&nbsp;file<span class="" style="font-size: 15px; line-height: 1em; font-weight: bolder; vertical-align: middle; text-align: center; margin-left: 5px;"></span></span></section></section><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">MADV_DONTNEED在Linux上的行为一直都是有争议的，它并没有完全服从POSIX的标准。事实上，我们将会看到它非标准的行为而导致Dirty COW的攻击变为可能。&nbsp;<br><br>继续看另一个线程，此处是攻击的关键点：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUqw5icspwO9XgJlns9K1EAt5CnGuGj06bbhlOsIUicXxz6N3Eb3WW6FsEw/0?wx_fmt=png" style="width: 722px !important; height: 416px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">它首先lseek到映射的地址，之后调用write(2)便实现了直接修改原本是只读权限的file-backed的内存映射。究竟是哪种行为导致特权文件的修改？HOW???!!!&nbsp;</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; background-color: rgb(0, 0, 0); color: rgb(255, 251, 0);"><strong>write(2)&nbsp;on&nbsp;/proc/{pid}/mem&nbsp;</strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">/proc/{pid}/meme是一个假的文件，它提供了一些Out-of-band的访问内存的方法。另一个类似的访问是调用ptrace(2)，同样的，也可称为Dirty COW的另一个可选的攻击点。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">为弄清楚/proc/self/mem如何工作，我们需要深入的了解内核。首先看下对于虚拟的文件，write(2)是如何实现的。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">在内核层面中，文件系统的操作的实现是利用面向对象的思想设计的（OOP）。有一个通用的抽象的结构struct file_operations。不同的文件类型，可以提供不同的实现。对于/proc/{pid}/mem，它的实现在文件/fs/proc/base.c中。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUqMlSP1vj9HK6f7tqsz8Usia7cDY30mznibamYkAm8nB7AJ5vfh20hdNTA/0?wx_fmt=png" style="width: 549px !important; height: 135px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">当write(2)写一个虚拟文件时，内核将调用函数mem_write，它只是对meme_rw的一个简单的封装。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUqzrfJUKHVQu2IvWoiaST3J8mBup2Am3RUxmNChJ614lABlXSHuMQqfmg/0?wx_fmt=png" style="width: 745px !important; height: 995px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">函数开始的时候分配了一个临时的内存buffer，用来在源进程（i.e. 
写的那个进程）和目的进程（被写/proc/self/mem的那个进程）之间的内存交换。当前，这两个进程是一样的。但是在一般情况下这一步是非常重要的，对于两个不同的进程。因为一个进程不能直接访问另一个进程的虚拟地址空间。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">之后它拷贝源进程的用户态bufferbuf中的内容到当前刚申请的空间中，通过调用函数copy_from_user。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">当这些前奏工作准备好之后，真正关键的部分是access_remote_vm。正如其名字含义一样，它允许内核读写另一个进程的虚拟地址空间。它是所有out-of-band访问内存方式的核心实现（比如，ptrace(2), /proc/self/mem, process_vm_readv, process_vm_writev等）。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">access_remote_vm调用了多个中间层函数，最终调用__get_user_pages_locked(...),在这个函数中，它第一次开始解析这种out-of-band访问方式的flags，当前情况的标志为： <br></span></p><blockquote><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">FOLL_TOUCH | FOLL_REMOTE | FOLL_GET | FOLL_WRITE | FOLL_FORCE <br></span></p></blockquote><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">这些被称为gup_flags(Get User Pages flags)或者foll_flags(Follow flags)，它们来代表一些信息，比如调用者为什么或以何种方式访问和获得目标的内存页。我们暂称它为access semantics（访问语义）。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">之后flag和所有其他的参数之后传递给__get_user_pages，此时才是开始真正地访问远程进程内存。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; background-color: rgb(0, 0, 0); color: rgb(255, 251, 0);"><strong>__get_user_pages&nbsp;和faultin_page</strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);"><span style="font-size: 16px; color: rgb(63, 63, 63);"></span>__get_use_pages函数用来查找和锁定一个指定的虚拟地址范围（在远程进程的虚拟地址空间范围内）到内核地址空间范围内。锁定内存是必须的，若没有这一步，用户态页面可能不在内存中。之后__get_user_pages以某种方式模拟用户态内存访问，但是是在内核层面上，之后使用faultin_page来完成对页错误的处理。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">如下是相关代码片段：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUqwwPTmMhRYqdPJw4HZJZGUlRkqjO5TiaiaY1TviaQxbOQbpuvmlq5KLtyA/0?wx_fmt=png" style="width: 617px !important; height: 757px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">代码首先定位远程进程中起始地址为start的内存页，而且foll_flags决定着当前的内存访问语义。如果该页面不可用(page==NULL)，即该页面不在内存中，需要进行页错误处理。之后faultin_page被调用，内部模拟一个内存空间的访问和触发页错误处理，以期待handler换进丢失的页。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">通常有几个原因导致follow_page_mask`返回空，如下是一个不完全的列表：</span></p><ul style="margin-bottom: 10px; color: rgb(51, 51, 51); font-family: none; font-size: 16px;" class="list-paddingleft-2"><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">该地址没有关联的内存映射，比如访问空指针。</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">该内存映射已经被创建了，但是由于demand-paging，内容尚未被加载进来。</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">页已经被换出到原始的文件或者交换文件中。</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">访问语义foll_flags与页的权限配置不一致（比如，写一个只读的映射）。</span></p></li></ul><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">最后一个原因就是我们调用write(2)写/proc/self/mem后发生的情况。通常的做法是页错误handler成功的处理错误，返回一个有效的页，之后再次重新访问。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">注意那个retry标志。此刻还不清楚作用，之后我们会提到，它是另一个导致此次exploit的“帮凶”。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">心里明白这点后，继续看fault_page的实现：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUqpfFgZY9p9vOEwtDgxZnzzpOkLRKPOkknDNPDL3iarDicEEKAPErqJObw/0?wx_fmt=png" style="width: 642px !important; height: 1281px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">函数的前半段解释foll_flags为对应的fault_flags，用以传递给handle_mm_fault,而该函数负责解析页错误，这样__get_user_pages可以继续执行。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">在当前情况中，因为我们要修改的原始的内存映射为只读的，故handle_mm_fault将创建一个新的只读的COW page（do_wp_page)给我们想要写的地址，同时使它为变为私有的和dirty，因此称为Dirty COW。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">真正创建COWed page的是嵌入在handle深处的do_wp_page，粗略的执行流程如下：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUq80tH0xzw3LSh5rIQCVPWp1Rj5Hzg6gdwwRWMsXKhgjRd2O5yKyzGgA/0?wx_fmt=png" style="width: 539px !important; height: 217px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">现在我们将视线转回fault_page的结束位置，在它返回之前，它做了如下一件事，使得该利用变为可能。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUqVKtZVqOsub8VrBmd8ZtJxo8I6ABTuvvN6nPMKn4rAf0PvR6L3xZwuA/0?wx_fmt=png" style="width: 560px !important; height: 250px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">在它检测到一个写时复制发生后，(ret &amp; VM_FAULT_WRITE == true)，它决定移除FOLL_WRITEflag。为什么要这样做？ <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">还记得那个retry&nbsp;lable么？如果不移除FOLL_WRITE，则下一次retry，将执行同样的流程。新申请的COWed 页和原来的也有同样的访问权限。同样的访问权限，同样的foll_flags，同样的retry,会导致死循环。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">为了打破这种无限的retry循环，一个聪明的想法是移除write flag。这样当下一次调用follow_page_mask时，将返回一个有效的页，指向起始地址。因为当前FOLL_WRITE不在了，foll_flags仅仅是一个普通的读权限，这对于新申请的COWed 只读页时允许的。</span></p><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="background-color: rgb(0, 0, 0); color: rgb(255, 251, 0);"><strong><span style="font-size: 16px; background-color: rgb(0, 0, 0);">谎言</span></strong></span><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></h3><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">此处到了问题的关键。通过从foll_flags移除write标志，&nbsp;follow_page_mask在下一次retry时，该访问将被视为只读的，尽管我们的目标是要写。现在，假如我们在同一时刻，COWed page被抛弃了通过另一个线程调用madvice(MADV_DONTNEED)会怎样？当然什么灾难也不会发生。follow_page_mask将仍然失败由于定位COWed page时发生缺页。但是下一次在faultin_page发生的将非常有趣。因为这次foll_flags并不包含FOLL_WRITE，故不再创建一个dirty COW 页，handle_mm_fault将简单地将该页从page cache中移除！为什么这么直接，因为万能的kernel只是在处理请求read 权限（切记，FOLL_WRITE已经被移除了），为什么要费尽创建页的另一个拷贝，如果kernel已经约定不再修改它。&nbsp;</span></h3><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">faultin_page返回不久之后，__get_user_pages将做另一次retry，来获取它请求了多次的页。多亏follow_page_mask在这次尝试中，最终返回给我们页。而且，它不再是普通的页，它是直接绑定特权文件的原始页。&nbsp;</span><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></h3><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">Kernel帮助我们获得了打开特权城堡的钥匙。有这个页在手，通用的commonner non-root程序现在有能力修改root file了。&nbsp;</span><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></h3><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">所有一切都是因为kernel在此撒谎了。在被告知dirty COW页已经ready之后的retry中，它只告诉了follow_page_mask和handle_mm_fault，只需要只读权限。这两个函数高兴的接受，最终返回一个当前任务最优的一个页。在这种情况下，它返回了一个如果我们修改它，它就将修改内容写回到原始特权文件的页。&nbsp;</span><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></h3><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">在最终获得页之后，__get_user_pages可以最终跳过faultin_page调用，返回页给__access_remote_vm来进行更多的处理。</span></h3><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 16px; background-color: rgb(0, 0, 0); color: rgb(255, 251, 0);"><strong><span style="font-size: 16px; background-color: rgb(0, 0, 0);">灾难</span></strong></span><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></h3><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">该页怎样被修改？如下是access_remote_vm的相关代码</span></h3><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUqQxE42r0SZ8P5QS3hFw6ibqXicIHRFHqBvG0axQoyCicqPkeZnBKyjAA1g/0?wx_fmt=png" style="width: 404px !important; height: 200px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-size: 15px;">上个代码片段中的page将直接映射我们之前提到的页。内核首先映射kmap这些页到内核地址空间中，之后调用copy_to_user_page快速地将buf中的用户数据写入到提到的页中，修改原始页的内容。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-size: 15px;">过一段时间以后，内核守护者线程（kflushd, bdflush, kupdated, pdflush线程等）会将被修改的页将被会写回到位于磁盘的特权文件中，这样就完成了整个攻击。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-size: 15px;">你可以会问，是听起来不错，但是发生的概率是多大？利用的话，有多少成功率？所有这些是在内核空间中吧？内核拥有权力来决定什么时候一个线程运行吧？ <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-size: 15px;">不幸的是，你可能已经猜到了。概率很大，Dirty COW甚至在一个单核的机器上，利用都相当稳定，归功于__get_user_ages会显示请求任务机制来切换线程，通过调用cond_resched。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-size: 15px;">以下是两个线程如何相互竞争的：&nbsp;<br>&nbsp;</span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUq7TGotibBWAfoH023ibPxiaSvVBfGs53LIHayJ6tWJiapCpnLiczLFEmIBbA/0?wx_fmt=png" style="width: 723px !important; height: 599px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-size: 15px;">机敏的读者可能已经注意到了，如果我们直接访问一个基于文件的只读映射，一个段错误将会产生。但是，为什么我们使用wirte写proc/self/mem确返回了一个dirty COWed的页呢？ </span><span style="font-size: 15px; color: rgb(63, 63, 63);"><br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">这个原因取决于当在一个进程内发生内存访问和当采用out-of-band(ptrace, /proc/{pid}/mem内存访问时，内核如何处理页错误的情况。这两种情况最终都会调用handle_mm_fault来处理页错误。但是后者使用faultin_page来模拟页错误，页错误直接导致触发MMU，将直接进入中断处理器，之后所有的路径都进入到平台独立的内核处理函数__do_page_fault中。而在直接写只读内存区域时，hanler将检测到访问违例在函数access_error中，同时在handle_mm_fault处理之前，直接触发信号SIGEGV在函数bad_aea_access_error中：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUqJ8YRWW2u4iaszGfS0FFDKficEyMd7nBPLbs5AeP3AN37PwXrXcD9umNw/0?wx_fmt=png" style="width: 602px !important; height: 295px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">然而，faultin_page会吝啬的处理访问违例，通过创建一个脏的 COWed页返回来使其合理合法（这毕竟是一个只读的，kernel不能如此轻松让你直接返回映射的页），相信kernel将会有一个完美的理由来violate这个访问，没有段错误。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">为什么内核采用如此多步骤来提供这种Out-of-band的内存访问呢？为什么内核支持这种侵入式的访问，从一个进程来访问另一个进程的地址空间？ <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">答案很简单，即使每个进程的地址空间是神圣的，私有性很强，等等。但是仍然需要调试器或别的侵入式的程序来有方法访问和获取一个进程的数据。这是一个了不起的实现，不然调试器从一个bug程序中如何设置断点和观察变量。</span></p><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 16px; background-color: rgb(0, 0, 0); color: rgb(255, 251, 0);"><strong><span style="font-size: 16px; background-color: rgb(0, 0, 0);">补丁</span></strong></span></h3><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">补丁非常短，整个 diff 如下：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GbvXaBUUNpcG5hcia1rHiaUqfSHicrGsNyYY6HHDicWkibSibQBPAaOIA1sTaGwfuVzEPBs5NHV2ZVG75w/0?wx_fmt=png" style="width: 770px !important; height: 746.745px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);"></span><span style="font-size: 15px; color: rgb(63, 63, 63);"> 这个补丁引入了一个新的标志FOLL_COW对应访问语义。当发生VM_FAULT_WRITE页错误时不再是简单地去掉FOLL_WRITE，write的语义将保持原样。但是为了仍然允许break这个retry循环，当下一次retry时，使用新的标志来产生一个dirty COWed页。如果期待的COWed页不在，一个新的页将会被返回来处理原始的拷贝。 <br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">所以，不要再撒谎了，这次补丁合理的处理COWed page下一次retry，然而，老的版本只是简单的抛弃了write 标志,寄希望于COWed page能在下次retry仍然存在。</span></p><h3 style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 16px; background-color: rgb(0, 0, 0); color: rgb(255, 251, 0);"><strong><span style="font-size: 16px; background-color: rgb(0, 0, 0);">结论</span></strong></span></h3><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">这个故事的寓意有两点：</span></p><ul style="margin-bottom: 10px; color: rgb(51, 51, 51); font-family: none; font-size: 16px;" class="list-paddingleft-2"><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">并发的程序非常难处理。</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">撒谎是不对的。</span></p></li></ul><p style="line-height: normal; margin-top: 15px; margin-bottom: 15px; text-align: center;"><span style="font-size: 14px; color: rgb(136, 136, 136);">本文由 看雪翻译小组<span class=""> ghostway</span> 编译，来源 Chao-tic</span><span style="font-size: 15px; color: rgb(136, 136, 136);">'s blog<br></span></p><p style="line-height: normal; margin-top: 15px; margin-bottom: 15px; text-align: center;"><span style="font-size: 14px; color: rgb(136, 136, 136);"></span><br></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: center;"><span style="font-size: 15px; color: rgb(255, 104, 39);">如果你喜欢的话，不要忘记点个赞哦！</span><br></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><br></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p style="margin-top: 15px; margin-bottom: 15px; max-width: 100%; min-height: 1em; line-height: 1.75em; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(79, 138, 187); box-sizing: border-box !important; overflow-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;">热门阅读文章：<br></strong></span></p><hr style="max-width: 100%; line-height: 25.6px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;"></p><ul class="list-paddingleft-2" style="list-style-type: circle;"><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458283127&amp;idx=1&amp;sn=a456b8495b438499ab68d1a2c32e543c&amp;chksm=b1815cfd86f6d5eb01205cf7c3052d428b2e9105d34523a276bdfb774c7adbbcbd197210f286&amp;scene=21#wechat_redirect" target="_blank">看雪 CTF 2017 攻击篇 6月强势来袭！</a></span></p></li><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458283658&amp;idx=2&amp;sn=f8870520fd3f842e489ce6bf2cb780ae&amp;chksm=b1815e0086f6d71634f6a1437dc638b4405bf263d45b27aabe77a67b9f99a583ea9211df63d5&amp;scene=21#wechat_redirect" target="_blank">娱乐War3 随机函数 GetRandomInt 懒人利用法</a><br></span></p></li><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458283635&amp;idx=3&amp;sn=5ac5c1643f079d82894bdb0c484332dd&amp;chksm=b1815ef986f6d7efa34c863c9ea942331025a40a839f7b0fa6ada50dd657e0606eccc63e06c3&amp;scene=21#wechat_redirect" target="_blank">记一次安卓系统源码编译刷机过程</a><br></span></p></li><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458283627&amp;idx=2&amp;sn=1ed3120f3b060dc5cccfd37add8fce45&amp;chksm=b1815ee186f6d7f75a6d74837204683da588dc1d4fa8fe1f94b4399eb54e4e08c097267556f1&amp;scene=21#wechat_redirect" target="_blank">黑掉SQL Server数据库链接：实验的设置和攻击指南（二）</a><br></span></p></li><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458283585&amp;idx=3&amp;sn=a7dc01fb0dca60054a4cd8aba4f3e9a8&amp;chksm=b1815ecb86f6d7ddbe2fb1f42592fe3c27aa814cf1e7fd1695e524af437f781ec48cd27efadd&amp;scene=21#wechat_redirect" target="_blank">黑掉SQL Server数据库链接：实验的设置和攻击指南</a><br></span></p></li><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;">......<br style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></p></li></ul><p style="margin-top: 15px; margin-bottom: 15px; max-width: 100%; min-height: 1em; line-height: 1.75em; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;">更多优秀文章，长按下方二维码，“<span style="max-width: 100%; color: rgb(0, 122, 170);">关注看雪学院公众号</span>”查看！</span></p><p><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1UG7KPNHN8F7ckRiaZtp76v0KXiaibibdH9bCfZtDdhqeqbk5LToic1TlqZZJ05wLxqexpbloufvSCKbUEPbEtFUzzQ/640?wx_fmt=jpeg" style="visibility: visible !important; width: 640px !important; height: 427px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; max-width: 100%; min-height: 1em; line-height: 1.75em; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span><span style="max-width: 100%; color: rgb(178, 178, 178); box-sizing: border-box !important; overflow-wrap: break-word !important; font-size: 15px;">看雪论坛：http://bbs.pediy.com/</span><span style="max-width: 100%; color: rgb(178, 178, 178); font-size: 14px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></p><p style="margin-top: 15px; margin-bottom: 15px; max-width: 100%; min-height: 1em; line-height: 1.75em; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(178, 178, 178); font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;">微信公众号 ID：ikanxue</span></p><p style="margin-top: 15px; margin-bottom: 15px; max-width: 100%; min-height: 1em; line-height: 1.75em; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(178, 178, 178); font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;">微博：看雪安全</span></p><p><span style="max-width: 100%; color: rgb(178, 178, 178); font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;">投稿、合作：www.kanxue.com</span></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1499131012&src=3&ver=1&signature=iU4hCwtQzyv2pey6SDTnZ62YXf1MWi8Zh8usUjq2T6Tp8olMm-6I1I4qsl-rYUzkEslKlH6cxolxoLxftDKuPoRYJ3NwX405l3Sx16vioe0gp0jag8eTAhoLCiXu4U8wCJDRG9M6B15Lpk1MCgv3HLQWXBsJTBSL45dXSofs5jk=">微信地址</a> | <a href="http://bbs.pediy.com/thread-218797.htm">阅读原文</a>
{% endraw  %}

