---
title: 实现CVE-2016-3842的堆喷
author: Ericky
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1503365665&src=3&ver=1&signature=OYewMZH60kmig22U24i7m7*yIRWwXpdLJI-Tjeo*GEAICPcVyP-61LcAEyxTaEQqli2GF0RNhrf*XV6u7a*Q3*gE0YbQkhFqP*ycY*XfcDYpVuHZreZETgPTfa4yGaE144zGtSlbQTppytFojv23nqIVONJg210qCFteyqoECrc=
date: '2017-08-12 00:00:00 +0000'

---

{% raw  %}
<p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);"></span></p><p style="text-align: center;"><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1UG7KPNHN8FchqnDS7ibGibuDdHZESXteDicU57Rem5KxkwX61GczKGyS1IENmwDgKic0ibLaful6op5b85gBkYqF1w/0?wx_fmt=jpeg" style="width: 319px !important; height: 240px !important; visibility: visible !important;"></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);"></span><br></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">前言<br></span></strong></span></p></section></section></section><p style="text-align: center; margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">看到论坛有大牛分析了这个CVE-2016-3842的利用方法，我之前也对这个漏洞的堆喷做了一些笔记，这里分享一下。首先要先感谢一下某因幡和Retme两位大神，在研究这个漏洞期间遇到不少的问题，他们都一一给我解答了，这里对他们表示再次感谢。</span></p><p style="text-align: center; margin-top: 25px; margin-bottom: 25px;"><br></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">漏洞介绍<br></span></strong></span></p></section></section></section><p style="text-align: center; margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">这个漏洞是GPU中的一个UAF漏洞，是由于race
 condition 造成的。在GPU驱动中提供了一个ioctl命令IOCTL_KGSL_GPUMEM_ALLOC 
，这个命令可以让用户去分配一块GPU共享内存。当一个线程调用这个ioctl之后，程序会创建一个kgsl_mem_entry的结构体用来描述一块已经分配好的内存。与此同时函数kgsl_mem_entry_attach_process会通过调用idr_alloc函数给kgsl_mem_entry分配一个ID。在这个时候，另外一个线程调用
 IOCTL_KGSL_GPUMEM_FREE_ID 
的ioctl命令去释放这个内存块，如果能在分配函数完成之前将这个kgsl_mem_entry释放掉，那么直接就造成了UAF了。</span></p><p class=""><br></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">再来看一下官方介绍：</span></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">If
 we add the mem entry pointer in the process idr and rb tree too early, 
other threads can do operations on the entry by guessing the ID or GPU 
address before the object gets returned by the creating operation.</span></p><p style="margin-top: 25px; margin-bottom: 25px; text-align: center;"><br></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">POC<br></span></strong></span></p></section></section></section><p style="text-align: center; margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">因为每在内核分配的第一个kgsl_mem_entry所分配的ID为1，所以可以准确释放刚分配好的内存块。</span></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">代码如下：</span></p><p style="margin: 25px 8px; line-height: 1.5em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FchqnDS7ibGibuDdHZESXteDeTnjuS0rPeSQiabf0mK9zdicJBhHFsA5v3xiaBzEWjJ8lT9b6zLp8Ampw/0?wx_fmt=png" style="width: 631px !important; height: 564px !important;"></p><p style="margin: 25px 8px; line-height: 1.5em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FchqnDS7ibGibuDdHZESXteD46X8XKpUfAyFaADuwjmxDqERKpJiaOUvSsKoktUKeXOKStHoO1SXn2A/0?wx_fmt=png" style="width: 745px !important; height: 1393px !important;"></p><p style="margin-top: 25px; margin-bottom: 25px; text-align: center;"><br></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">实际堆喷中遇到的问题<br></span></strong></span></p></section></section></section><p style="text-align: center; margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.5em;"><strong><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">1. 使用seccomp被拦截</span></strong></p><p style="margin: 25px 8px; line-height: 1.5em;"><strong><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);"><br></span></strong></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">用的是seccomp这个syscall来进行堆喷，seccomp被拦截了，如下：</span></p><p style="margin: 25px 8px; line-height: 1.5em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FchqnDS7ibGibuDdHZESXteDRfR00Wdm7N1RuAASkaTukOqF5EoHF5PWj8WFG5abVOPGaZRic5NYNdQ/0?wx_fmt=png" style="width: 595px !important; height: 59px !important;"></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">在提示过后，查看android内核源码，发现并不需要任何权限，但是要在使用之前设置一个Admin的进程属性来绕过。</span></p><p class=""><br></p><p style="margin: 25px 8px; line-height: 1.5em;"><strong><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">2. 堆喷如何判断是否成功</span></strong></p><p class=""><br></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">调试漏洞时，选择自己能改内核代码的机器来调。printk就能直观显示是否成功。</span></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">还有相对高级的方法是，可以在喷的内容中做一些标记，比如deadbeef，这样喷上去之后在崩溃，crash寄存器中会有反馈。</span></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">建议优先用printk。</span></p><p class=""><br></p><p style="margin: 25px 8px; line-height: 1.5em;"><strong><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">3. 崩溃日志的疑问</span></strong></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);"><br></span></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">按漏洞的原理来看，崩溃时候的函数应该是顺着IOCTL_KGSL_MAP_USER_MEM这个ioctl的，但是为什么崩溃信息里为什么会是这个函数导致崩溃的呢？看这个崩溃信息，让我有点迷糊了，不知道准确的触发时机是什么时候了，是不是在我的机器上就是这个函数触发的崩溃？</span></p><p style="margin: 25px 8px; line-height: 1.5em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FchqnDS7ibGibuDdHZESXteDQPhJd2mAmRQwFhyBjQFSYKQr80AEVYbf5XjHu4y5Uey4UDnPXMkYdQ/0?wx_fmt=png" style="width: 754px !important; height: 246.277px !important;"></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">ShenDi大神的说法是这样的， “触发时机是有2～3处的，这取决于free的时机，你没法控制这个时机，但是如果你能喷堆成功，就能保证这2～3个时机都不会崩溃。”后来经我的验证，是因为我用的是5X的机器，而他用的是6P，崩溃信息确实不一样。</span></p><p class=""><br></p><p style="margin: 25px 8px; line-height: 1.5em;"><strong><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">4. 关于堆喷结构体sock_filter</span></strong></p><p class=""><br></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">对于sock_filter，如果不加修饰的随便定义这个结构体去喷，虽然它也会被kmalloc，只不过之后校验参数的时候
 
会失败，然后会被free掉，这个值得注意。因为如果seccomp失败的话，调用一次和调用一万次是没有区别的，kmalloc会永远落在同一个object上。</span></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);"><br></span></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">了解了以上这些，就可以开始尝试堆喷了，堆喷代码如下：</span></p><p style="margin: 25px 8px; line-height: 1.5em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FchqnDS7ibGibuDdHZESXteDX1zmDEhlW2TZSOE7I7kmaLWQq9PNSTb6sU1gcib59licy2kFcVUYwHdA/0?wx_fmt=png" style="width: 741px !important; height: 754px !important;"></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">内核print堆喷信息如下：</span></p><p style="margin: 25px 8px; line-height: 1.5em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FchqnDS7ibGibuDdHZESXteDxZ2yWKGrPpkhWnA7P2PUB5WoLk51PqFqT5TuNjiaYl1dnXPNaBRd0KQ/0?wx_fmt=png" style="width: 754px !important; height: 527.8px !important;"></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">经过不断的尝试，最后堆喷成功：</span></p><p style="margin: 25px 8px; line-height: 1.5em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FchqnDS7ibGibuDdHZESXteDOSzCLVlPVHjPe02SLudlhJ5f2y0EWYaxVJKNLpXZwkbZUmy7JjwA2w/0?wx_fmt=png" style="width: 750px !important; height: 903px !important;"></p><p style="margin-top: 25px; margin-bottom: 25px; text-align: center;"><br></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">总结<br></span></strong></span></p></section></section></section><p style="text-align: center; margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.5em;"><span style="font-size: 15px; letter-spacing: 2px; color: rgb(63, 63, 63);">折腾了很久，终于堆喷成功。多看代码，多尝试，多坚持。</span></p><p><br></p><p><br></p><section label="Copyright © 2014 playhudong All Rights Reserved." style="border-width: medium; border-color: currentcolor; -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; border-style: none; margin: 5px 0px 0px; padding: 10px 0px; background: rgba(0, 0, 0, 0) none repeat scroll 0% 0%;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8G9B6YFlthnv1h3cWDDXGAmK9wQfy6pod114tTuOSIFVeVd0vd1PEwicksgBGmxL0iaC0icX7B9EQzNg/640?wx_fmt=png" style="margin: 0px auto; display: block; visibility: visible !important; width: 160px !important; height: 8.44575px !important;"></section><p><br></p><p><br></p><p style="letter-spacing: 1px; margin: 25px 1em; text-align: center; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">本文由看雪论坛 Ericky 原创<br><br></span></p><p style="letter-spacing: 1px; margin: 25px 1em; text-align: center; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">转载请注明来自看雪社区</span></p><p style="text-align: center;"><br></p><p style="text-align: center; margin-top: 25px; margin-bottom: 25px;"><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1UG7KPNHN8HFWP586ic3Pf4F6hD1rnmHpScQgCs4x9dJWoHHNnoiamW5RMTq8alBq5UiahM3G1W9TK3RPXQHXWZUQ/640?wx_fmt=jpeg" style="visibility: visible !important; width: 770px !important; height: 381.992px !important;"></p><p style="text-align: center;"><br></p><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 16px; color: rgb(63, 63, 63);">热门阅读</span></p><ul style="list-style-type: disc;" class="list-paddingleft-2"><li><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284324&amp;idx=3&amp;sn=a3fda988453c3513cc19f8d9f18a2799&amp;chksm=b18141ae86f6c8b8e87afb4cc64dfcc463247dee1e76dc3b60ef258683a03f1587d5c9848668&amp;scene=21#wechat_redirect" target="_blank">议题征集 | 2017 安全开发者峰会</a></span></p></li><li><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284298&amp;idx=2&amp;sn=771546cd763617327ffd6a11a9d14e97&amp;chksm=b181418086f6c896fe7a64c473281613409dcaaf672de9f5b62605e3fb765bad4fe95a86df1f&amp;scene=21#wechat_redirect" target="_blank">Web 应用中最愚蠢的安全错误，前5名</a></span></p></li><li><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284361&amp;idx=1&amp;sn=4387782057503a16864581ab9337b78e&amp;chksm=b18141c386f6c8d5bc76dafbd713de485d63dd26b5f013a634f479c833c97471fa9915d66959&amp;scene=21#wechat_redirect" target="_blank">搭建一个Fake AP 接入点的教程</a></span></p></li><li><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284324&amp;idx=1&amp;sn=72487148429cc697d79becdc237779ce&amp;chksm=b18141ae86f6c8b8fee96bd9546afa740d3697d727bd7265d0d748d35221df0c013979579a13&amp;scene=21#wechat_redirect" target="_blank">嵌入式设备硬件PCB级逆向</a><br></span></p></li><li><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284255&amp;idx=1&amp;sn=a07808a74f61d543163a309214775b46&amp;chksm=b181405586f6c9438606b0c36e56e0c41b5b089e587b9dd991f59fffe72558259a752ddf981d&amp;scene=21#wechat_redirect" target="_blank">虚拟机保护技术浅谈</a></span></p></li></ul><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1503365665&src=3&ver=1&signature=OYewMZH60kmig22U24i7m7*yIRWwXpdLJI-Tjeo*GEAICPcVyP-61LcAEyxTaEQqli2GF0RNhrf*XV6u7a*Q3*gE0YbQkhFqP*ycY*XfcDYpVuHZreZETgPTfa4yGaE144zGtSlbQTppytFojv23nqIVONJg210qCFteyqoECrc=">微信地址</a> | <a href="http://bbs.pediy.com/thread-218194.htm">阅读原文</a>
{% endraw  %}

