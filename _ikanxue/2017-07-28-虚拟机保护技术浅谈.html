---
title: 虚拟机保护技术浅谈
author: 东方容克
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1502116456&src=3&ver=1&signature=fMd4ZeYncDjRuvdiU8EiAqzwJV-51HguOx4pnyGlqXjJ10eFEeoZU*4ykBfJ5DfCcbB*9QgBsAKzwmoYzWJII1mD-jrYiAFtAH1w6WTr8*CTq4WVeP5Dv2*wgQjvPS9-BboI*EjK7L68pnCTTOm94MPnHy*0J76a3O-1bRsnoOk=
date: '2017-07-28 00:00:00 +0000'

---

{% raw  %}
<p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 16px; color: rgb(63, 63, 63);"></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1UG7KPNHN8FTyvSKWacHOicuhRuJopUTZibC5Ijs4McricHicrbCPks5nnMCV7v2aXCezdSnCmcarnnz4xFN9PZfdg/0?wx_fmt=jpeg" style="width: 612px !important; height: 408px !important; visibility: visible !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">本文对《加密与解密》第3版的内容进行了一些总结、重新归纳整理，加入了自己的理解，希望对新手有所帮助。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"><br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 16px; color: rgb(63, 63, 63);"><strong><strong>▶ </strong>虚拟机概览</strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 16px; color: rgb(63, 63, 63);"><strong><br></strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">所谓虚拟机保护技术，是指将代码翻译为机器和人都无法识别的一串伪代码字节流；在具体执行时再对这些伪代码进行一一翻译解释，逐步还原为原始代码并执行。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">这段用于翻译伪代码并负责具体执行的子程序就叫作虚拟机VM（好似一个抽象的CPU）。它以一个函数的形式存在，函数的参数就是字节码的内存地址。<br>将虚拟机应用到商业中的保护壳现有三款:Vmprotect，themida和 execrypt。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"><br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 16px; color: rgb(63, 63, 63);"><strong><strong>▶ </strong>虚拟机架构</strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 16px; color: rgb(63, 63, 63);"><strong><br></strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">我们知道，代码中的指令多种多样，组织形式也千变万化；虚拟机不可能针对每一种具体情况都进行翻译处理。必须对所有可能遇到的指令先进行抽象归类，然后分解为若干简单的小指令，再交由各个专门的子程序（handler）去处理。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">学过编译原理的同学应该都知道三元式代码吧，也叫做3地址代码(three adress code)。即不论多么复杂的赋值公式，都可以分解为数个3地址代码式序列。（什么是3地址代码，1段3地址代码只完成1次运算，譬如1次二目运算、1次比较，或者1次分支跳转运算。）</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">与此类似，不论多么复杂的指令，都可以分解为一串不可再分割的原子指令序列。<br><br>虚拟机（CPU）的体系架构可分为3种，基于堆栈的(Stack based)，基于寄存器的(Register 
based)和3地址机器。我们只讲述基于堆栈的虚拟机架构(Stack 
based)；这种架构的虚拟机需要频繁操作堆栈，其使用的虚拟寄存器(虚拟的eax、ebx等等)保存在堆栈中；每个原子指令的handler都需要push、pop。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">现在的CPU都有大量的寄存器，堆栈一般只是在函数传递参数时使用（譬如PC机用的x86系列CPU）。但也有一些CPU只操作内存，没有堆栈，也没有寄存器。使用这种CPU的机器称之为3地址机器。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">基于堆栈的CPU或虚拟机没有临时变量、寄存器的概念，所有的东西都放入堆栈。由于指令中不需要指定操作数，所以其指令相对基于寄存器的要短。也因此相对简单，在嵌入式系统中运用较多。用于保护代码，我们也选择这种。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">举例，譬如指令add,基于堆栈的CPU首先从堆栈里Pop两个数，然后将两数相加，再把和Push到堆栈。Add指令只占用1个字节。而基于寄存器的CPU对应指令为
 add 
Reg1,Reg2，需要3个字节。请仔细想象一下没有寄存器的CPU，它的指令是怎样的，该会是多么简洁。当然，指令简洁带来的缺点就是效率低下。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">我们这里谈的虚拟机保护技术，就是把基于寄存器的CPU代码，改造成基于堆栈的CPU的伪代码。然后再由基于堆栈的虚拟机(CPU)对伪代码解释执行。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"><br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 16px; color: rgb(63, 63, 63);"><strong><strong>▶ </strong>指令系统</strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 16px; color: rgb(63, 63, 63);"><strong><br></strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">关键在于设计一个虚拟的基于堆栈的虚拟机(CPU)的指令系统。这个指令系统越简洁，复用性越高越好。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">还是以add 指令为例。X86系列CPU的add指令有许多格式，譬如：add reg,imm 、add reg,reg、add 
reg,mem、add mem,reg等等。而基于堆栈的虚拟机CPU则没有这么多花样，就一个单单的add指令，参数和返回都是在堆栈里。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">我们需要为我们的虚拟机CPU模拟实现这样的add命令：<span style="color: rgb(63, 63, 63); font-size: 14px;"><br></span></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"><span style="color: rgb(63, 63, 63); font-size: 14px;"></span></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FEUVDeibibRFVNQfC80W8vc1Pyjx9CsHAlfPfkGKavTM8gzb9UwNMLIogAk9Tsx2VP5s6ox3xW8Lbg/0?wx_fmt=png" style="width: 499px !important; height: 124px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">而原有的add命令的参数，我们需要翻译为 push 命令 。根据push 的对象不同，需要不同的实现：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FEUVDeibibRFVNQfC80W8vc1kHvYkdQ0J0aj62ZECsT1dh5UCPeXdYb9t08NW7epDDicm0VPUp3VVJw/0?wx_fmt=png" style="width: 666px !important; height: 218px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"></span><span style="font-size: 15px; color: rgb(63, 63, 63);">有Push指令了，也得有Pop指令：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FEUVDeibibRFVNQfC80W8vc1Y22wuZU0YkNVuYfmYZhIqticWPmnRQLJNZxicuEpHPCtjCC1LnkqU0YA/0?wx_fmt=png" style="width: 657px !important; height: 102px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">基于堆栈的虚拟机指令系统就是这样简单的：单字节的动作指令（譬如add、dec），以及各式各样的push、pop等堆栈操作指令。没有复杂的寄存器与内存操作。我们需要把x86的CPU指令翻译成虚拟机CPU的指令，譬如：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FEUVDeibibRFVNQfC80W8vc1K6smdBibmtZkOq1xfQ0EjfE18oKgGtT6DaLsO2icfnxcVK6z1Lt9ONsw/0?wx_fmt=png" style="width: 427px !important; height: 88px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">Call指令相对麻烦一点，因为Call的函数未必是虚拟机的伪代码了。所以碰到Call指令，就要退出虚拟机，交由真实的CPU去处理了。代码类似下面：<br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FEUVDeibibRFVNQfC80W8vc1atGfibFDU4t37vxDyyyLU1MzSktbYRmODXpXLPlH6P5GDyd0dj4O0fg/0?wx_fmt=png" style="width: 683px !important; height: 121px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FEUVDeibibRFVNQfC80W8vc19s025aFxhDnn4jonxOwnA0GoY0lyuYmpLTwyOpiaAvVbbR2kDiblicL7A/0?wx_fmt=png" style="width: 509px !important; height: 522px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"></span><span style="font-size: 15px; color: rgb(63, 63, 63);">其余，要注意标志位的处理、不可模拟指令，以及指令的优化。还有异常处理，这里就不展开了。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">VStartVM是虚拟机的入口，负责保存运行环境(各个寄存器的值)、以及初始化堆栈(虚拟机使用的变量全部在堆栈中)。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">Bytecode是伪代码；VMDispatcher对伪代码逐个阅读处理，然后分发给下面的各个子程序(Handler)。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">加壳程序先把已知的X86指令解释成了字节码，放在PE文件中，然后将原处代码删掉，改成类似的代码进入虚拟机执行循环。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FEUVDeibibRFVNQfC80W8vc1icPIAIWNV3APoH9CkiadQKRyoH086MQFFmdsezDTQicx9mr6ZqF1WLVQQ/0?wx_fmt=png" style="width: 770px !important; height: 441.897px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"></span><span style="font-size: 15px; color: rgb(63, 63, 63);">VStartVM初始化后，堆栈情形如下：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FEUVDeibibRFVNQfC80W8vc1C1TNWSxjqGbCQibuyjrMExlz3Kx9BP6bTHM66icbNqBJKyW903DJh4Lw/0?wx_fmt=png" style="width: 560px !important; height: 409px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">edi指向VMcontext;esi指向伪代码的地址；ebp指向真实堆栈的栈顶; 这三个寄存器在VM内不要再改了。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">VMContext是虚拟机VM使用的虚拟环境结构：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FEUVDeibibRFVNQfC80W8vc10MTmXe9sOwGLeYvgBOmHZt1244WcBXYWhOZQayrtz5NfqNFxicUlIHA/0?wx_fmt=png" style="width: 440px !important; height: 220px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"></span><span style="font-size: 15px; color: rgb(63, 63, 63);">VM之所以使用堆栈保存自己的寄存器结构，是考虑到多线程程序的兼容。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);">大家都知道脱壳时的堆栈平衡原理吧。同样的，虚拟机在执行翻译后的程序代码时，也不可以随便变动原来的堆栈地址。还需经常检查在堆栈中的VMcontext结构不被冲掉。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 15px; color: rgb(63, 63, 63);"></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8FEUVDeibibRFVNQfC80W8vc1XEsXCvcziakXjia5xhXiaJjmOxBXHbkEFmGX1ZoWBPUeqaIQZp1P1SJpQ/0?wx_fmt=png" style="width: 516px !important; height: 359px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em; text-align: justify;"><span style="font-size: 14px;"></span></p><p><br></p><section label="Copyright © 2014 playhudong All Rights Reserved." style="border-width: medium; border-color: currentcolor; -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; border-style: none; margin: 5px 0px 0px; padding: 10px 0px; background: rgba(0, 0, 0, 0) none repeat scroll 0% 0%;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8G9B6YFlthnv1h3cWDDXGAmK9wQfy6pod114tTuOSIFVeVd0vd1PEwicksgBGmxL0iaC0icX7B9EQzNg/640?wx_fmt=png" style="margin: 0px auto; display: block; visibility: visible !important; width: 160px !important; height: 8.44575px !important;"></section><p><br></p><p class=""><br></p><p style="letter-spacing: 1px; margin: 15px 1em; text-align: center; line-height: 1.75em;"><span style="font-size: 15px;">本文由看雪论坛 <span class="">东方荣克 原创，转载请注明来自看雪社区</span></span></p><p style="text-align: center;"><br></p><p style="text-align: justify; margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1UG7KPNHN8HFWP586ic3Pf4F6hD1rnmHpScQgCs4x9dJWoHHNnoiamW5RMTq8alBq5UiahM3G1W9TK3RPXQHXWZUQ/640?wx_fmt=jpeg" style="visibility: visible !important; width: 770px !important; height: 381.992px !important;"></p><p style="text-align: center;"><br></p><p style="letter-spacing: 1px; margin: 15px 1em; text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-size: 16px;">热门阅读</span></p><ul style="list-style-type: disc;" class="list-paddingleft-2"><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: justify; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284204&amp;idx=1&amp;sn=1f45d8c97686ee0f2403163959a80ff6&amp;chksm=b181402686f6c930101c1e214ebe45db3ed65f9ba0906b2885f4a23e29f56676687df90f8d41&amp;scene=21#wechat_redirect" target="_blank">浅谈macRansom</a></span></p></li><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: justify; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284229&amp;idx=2&amp;sn=61720f3a096b2e759adbdea8a96a189a&amp;chksm=b181404f86f6c959c89c32d3cc35be7546e0619e6f5ee61aec9dd1472daec95fb997d5c5e332&amp;scene=21#wechat_redirect" target="_blank">一个lpk.dll病毒的分析报告</a></span></p></li><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: justify; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284116&amp;idx=1&amp;sn=4ae9de8a41b6a92b9b1cda29129733c6&amp;chksm=b18140de86f6c9c86f058016383461ba1f7c517bb3cdb306544b9a26fb579f6ce730809dbfc2&amp;scene=21#wechat_redirect" target="_blank">【暴雷漏洞】CVE-2012-1889 个人漏洞分析报告</a></span></p></li><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: justify; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284102&amp;idx=1&amp;sn=881ed6e337462737148a5e905795ca13&amp;chksm=b18140cc86f6c9da359d9cd53a806d4ce3e2e4fe9daff7445cf1e34b612a40c73b27690f1cbe&amp;scene=21#wechat_redirect" target="_blank">Safengine Shielden 2.3.8.0 脱壳 ∷之∷ 修复IAT</a></span></p></li></ul><p style="text-align: center;"><br></p><p style="text-align: center; margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; background-color: rgb(178, 178, 178); color: rgb(255, 255, 255);">点击阅读原文/read，还有更多干货等着你~</span></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1502116456&src=3&ver=1&signature=fMd4ZeYncDjRuvdiU8EiAqzwJV-51HguOx4pnyGlqXjJ10eFEeoZU*4ykBfJ5DfCcbB*9QgBsAKzwmoYzWJII1mD-jrYiAFtAH1w6WTr8*CTq4WVeP5Dv2*wgQjvPS9-BboI*EjK7L68pnCTTOm94MPnHy*0J76a3O-1bRsnoOk=">微信地址</a> | <a href="http://bbs.pediy.com/thread-139586.htm">阅读原文</a>
{% endraw  %}

