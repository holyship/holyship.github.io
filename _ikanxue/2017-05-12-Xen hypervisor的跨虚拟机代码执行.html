---
title: Xen hypervisor的跨虚拟机代码执行
author: ghostway
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1494849877&src=3&ver=1&signature=FqhZ2eqkNX-xbZfPTDWJFyyUKemv954mf5Q*MuC9JH720SqIESAnz8-uzXmDzovZMdiRZ8GMhE0ZmV0qTfay6WbLQqVN9R81LxiMolMYb5HxJb7Or3u0svWfQJ8Rx1zLdXImq0REGvjHGIF0REVvg7Lowd03Bv-nwy88bR4sghM=
date: '2017-05-12 00:00:00 +0000'

---

{% raw  %}
<p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 18px; color: rgb(217, 150, 148);"><strong>前言</strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">2017-03-14，我给 Xen’s security teamp 报告了一个 Bug。该 Bug 允许位于paravirtualized（半虚拟化）Guest 中的一个拥有 root 权限的的攻击者跳出 hypervisor&nbsp; 的管理，完全控制宿主机的物理内存。Xen Project 在 2017-04-04<br>发布了一个公告和 Patch 补丁。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 18px;"><strong><span style="color: rgb(217, 150, 148);">背景知识</span></strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">在 x86-64 上，Xen PV(paravirtualized) guests 和 hypervisor 共享虚拟地址空间。粗略的内存布局如下：</span></p><p style="text-align: center;"><img src="/ikanxue/images/a966fe83a7bb16479ceb211a8e1fb3726446b0de.png" style="width: 441px !important; height: 492px !important; visibility: visible !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">Xen 允许 guest 内核执行 hypercall，即使用 Sytem V AMD64 AMI 来实现从 guest 内核到 hypervisor 的一个必备的系统调用。通常是使用指令 syscall 实现，最多 6 个参数，通过寄存器传递。就像正常内核的 syscall，Xen hypercall 通常直接<br>使用 guest 上的指针来作为参数。由于 hypervisor 共享它的地址空间，故它能理解直接传递过来的 guest-virtual 指针。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">就像所有内核一样，在需要解引用guest-virtual指针的时候，Xen必须确保它们并没有实际指向hypervisor-owned的内存区域。它实际上使用用户态的accessor（和Linux内核中的那些相似）来完成这些任务。</span></p><ul style="list-style-type: disc;" class="list-paddingleft-2"><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; background-color: rgb(255, 215, 213);">access_ok(addr,size) </span><span style="font-size: 15px;">：检查是否一个 guest-supplied 的虚拟地址可以安全访问，换句话说，它会检查访问内存区域不会修改到hypervisor内存。</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; background-color: rgb(255, 215, 213);">__copy_to_guest(hnd, ptr, nr)</span><span style="font-size: 15px;"> ：从 hypervisor 的 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">ptr</span> 地址拷贝 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">nr</span> 个字节到 guest地址 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">hnd</span> ，但是不检查 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">hnd</span> 是否有效。</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px; background-color: rgb(255, 215, 213);">copy_to_guest(hnd, ptr, nr) </span><span style="font-size: 15px;">：从hypervisor的 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">ptr</span> 地址拷贝 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">nr</span> 个字节到 guest 地址 hnd ，验证 hnd 有效性。</span></p></li></ul><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">在 Linux 内核中，宏<span style="font-size: 15px; background-color: rgb(255, 215, 213);"> access_ok() </span>检测地址范围 addr 到 addr+size-1 是否可以安全访问，使用任意的内存访问模式。然而，Xen 的 access_ok() 并不确保这些：</span></p><blockquote><p style="margin-top: 15px; margin-bottom: 15px; line-height: normal;"><span style="font-size: 14px;">/*<br>* Valid if in +ve half of 48‐bit address space, or above Xen‐reserved area.<br>* This is also valid for range checks (addr, addr+size). As long as the<br>* start address is outside the Xen‐reserved area then we will access a<br>* non‐canonical address (and thus fault) before ever reaching VIRT_START.<br>*/<br>#define __addr_ok(addr) \<br>(((unsigned long)(addr) &lt; (1UL&lt;&lt;47)) || \<br>((unsigned long)(addr) &gt;= HYPERVISOR_VIRT_END))<br>#define access_ok(addr, size) \<br>(__addr_ok(addr) || is_compat_arg_xlat_range(addr, size))</span><span style="font-size: 15px;"><br></span></p></blockquote><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">Xen 通常只是检查指针 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">addr</span> 位于地址空间或者内核空间，但不检查大小 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">size</span> 。如果实际的 Guest Memory 访问从地址addr附近开始，线性的处理，只要一个 guest memory 访问失败，则 bails out 是有意义的，因为大片的 non-canonical 地址空间正好充当了一个大的保护区。然而，如果一个 hypercall 想要访问一个起始于 64-bit offset 的 guest buffer，则它需要确保调用时 access_ok() 填入正确的偏移，检查整个 userspace buffer 是不安全的。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">Xen 提供了围绕 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">access_ok()&nbsp;</span> 的封装来检查 guest 中访问数组。如果想检查是否可以安全的访问一个数组（从下标 0 开始），可以使用 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">guest_handle_okay(hnd,nr)</span> 。然而，如果你想检查不从下标 0 开始的数组，应该使用 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">guest_handle_subrange_okay(hnd, first, last)</span> 。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">当我看到了 access_ok 的定义，发现其缺乏完整的安全性验证，所以，我开始查找调用它的地方，来看是否有不安全的使用行为。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="color: rgb(217, 150, 148); font-size: 18px;"><strong><span style="color: rgb(217, 150, 148);">Hypercall 的抢占机制(Preemption)</span></strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">当调度 Tick 发生，Xen 需要快速的从当前执行的 vCPU 切换到另一个虚拟机的vCPU。然而简单的中断 hypercall 的执行是不会起作用的（eg.hypercall 可能正拥有一个自旋锁），故 Xen（像其他操作系统）需要一些机制来延迟 vCPU 的切<br>换，直到它足够安全的来执行。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">在 Xen 里，hypercall 的抢占是通过使用 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">自愿性抢占(voluntary preemption)</span> 实现的：任何长时间运行的 hypercall 代码需要提前调用<span style="font-size: 15px; background-color: rgb(255, 215, 213);"> hypercall_preempt_check()</span> 来检查是否调度器想要调度到另一个 vCPU 上。如果该事件发生了，hypercall<br>代码退出到 guest，因此，以信号的方式通知调度器，抢占当前任务是安全的，调整了 hypercall argument 参数后（在guest register或者guest 内存），只要当前 vCPU 再次被调度，它将重新进入 hypercall 之后，执行剩余的工作。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">Hypercall 无法区分抢占之后的正常的 hypercall entry 和 hypercall re-entry。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">Xen 使用 Hypercall re-entry 的机制，因为 Xen 并不是每一个 vCPU 都有一个hypervisor 栈。它是针对每一个物理核有一个 hypervisor 栈。这意味着，别的操作系统，比如 Linux，可以简单的离开一个中断的 syscall 的状态，而 Xen 无法轻松的做到。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">这个设计意味着对于一些 hypercall，允许他们适当地 resume 它们的工作，额外的数据保存到 guest memory 中，而 guest momory 的数据有可能被修改 guest 精心修改而用来攻击 hypervisor。</span></p><p style="margin-top: 25px; margin-bottom: 25px; line-height: 2em;"><span style="font-size: 18px; color: rgb(217, 150, 148);"><strong>memory_exchange()</strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">hypercall <span style="font-size: 15px; background-color: rgb(255, 215, 213);">HYPERVISOR_memory_op(XENMEM_exchange, arg)</span> 调用函数 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">memory_exchange(arg)(source code: xen/common/memory.c)</span> 。该函数允许一个 guest 将它们拥有的的物理内存用来交换一些在物理地址连续性上有限制的新的物理内存。该功能对于想实现 DMA 功能的 guest 非常有用，因为 DMA 需要物理上连续的缓冲区。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: normal;"><span style="font-size: 15px;">该 hypercall 需要一个结构为 <span style="font-size: 15px; background-color: rgb(255, 215, 213);">struct xen_memory_exchage</span> 的参数，定义如下:<span style="font-size: 14px;"><br></span></span></p><blockquote><p style="margin-top: 15px; margin-bottom: 15px; line-height: normal;"><span style="font-size: 15px;"><span style="font-size: 14px;">truct xen_memory_reservation {<br>/* [...] */<br>XEN_GUEST_HANDLE(xen_pfn_t) extent_start; /* in: physical page list */<br>/* Number of extents, and size/alignment of each (2^extent_order pages). */<br>xen_ulong_t nr_extents;<br>unsigned int extent_order;<br>/* XENMEMF flags. */<br>unsigned int mem_flags;<br>/*<br>* Domain whose reservation is being changed.<br>* Unprivileged domains can specify only DOMID_SELF.<br>*/<br>domid_t domid;<br>};<br>struct xen_memory_exchange {<br>/*<br>* [IN] Details of memory extents to be exchanged (GMFN bases).<br>* Note that @in.address_bits is ignored and unused.<br>*/<br>struct xen_memory_reservation in;<br>/*<br>* [IN/OUT] Details of new memory extents.<br>* We require that:<br>* 1. @in.domid == @out.domid<br>* 2. @in.nr_extents &lt;&lt; @in.extent_order ==<br>* @out.nr_extents &lt;&lt; @out.extent_order<br>* 3. @in.extent_start and @out.extent_start lists must not overlap<br>* 4. @out.extent_start lists GPFN bases to be populated<br>* 5. @out.extent_start is overwritten with allocated GMFN bases<br>*/<br>struct xen_memory_reservation out;<br>/*<br>* [OUT] Number of input extents that were successfully exchanged:<br>* 1. The first @nr_exchanged input extents were successfully<br>* deallocated.<br>* 2. The corresponding first entries in the output extent list correctly<br>* indicate the GMFNs that were successfully exchanged.<br>* 3. All other input and output extents are untouched.<br>* 4. If not all input exents are exchanged then the return code of this<br>* command will be non‐zero.<br>* 5. THIS FIELD MUST BE INITIALISED TO ZERO BY THE CALLER!<br>*/<br>xen_ulong_t nr_exchanged;<br>};</span><br></span></p></blockquote><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">和该 Bug 相关的成员有: in.extent_start, in.nr_extents, out.extent_start, out.nr_extents 和 nr_exchangednr_exchanged 文档中默认总是被 guest 初始化为 0，这是因为，它不仅用来返回一个结果，同时 hypercall 的抢占中也会用到。当 memory_exchange() 被抢占后， nr_exchaged 存储它的进度，这样，当下一次执行 memory_exchage() 时，使用 nr_exchanged 来决定输入数组中 in.extent_start和out.extent_start 的哪个点应该被resume。原来的 memory_exchange() 并不检查用户空间的数组指针，在使用 __copy_from_guest_offset和__copy_to_guest_offset() 访问它们之前，而且不进行自身的任何检查，故，使用提供的hypervisor指针，可能导致Xen去读或者写hypervisor内存–一个非常严重的Bug。该问题在2012年被发现(XSA-29,CVE-2012-5513)，同时进行了如下修补（https://xenbits.xen.org/xsa/xsa29-4.1.patch）：</span></p><blockquote><p style="margin-top: 15px; margin-bottom: 15px; line-height: normal;"><span style="font-size: 14px;">diff ‐‐git a/xen/common/memory.c b/xen/common/memory.c<br>index 4e7c234..59379d3 100644<br>‐‐‐ a/xen/common/memory.c<br>+++ b/xen/common/memory.c<br>@@ ‐289,6 +289,13 @@ static long memory_exchange(XEN_GUEST_HANDLE(xen_memory_exchange_t)<br>arg)<br>goto fail_early;<br>}<br>+ if ( !guest_handle_okay(exch.in.extent_start, exch.in.nr_extents) ||<br>+ !guest_handle_okay(exch.out.extent_start, exch.out.nr_extents) )<br>+ {<br>+ rc = ‐EFAULT;<br>+ goto fail_early;<br>+ }<br>+<br>/* Only privileged guests can allocate multi‐page contiguous extents. */<br>if ( !multipage_allocation_permitted(current‐&gt;domain,<br>exch.in.extent_order) ||</span><span style="font-size: 15px;"><br></span></p></blockquote><p style="margin-top: 25px; margin-bottom: 25px; line-height: 2em;"><span style="color: rgb(217, 150, 148); font-size: 18px;"><strong><span style="color: rgb(217, 150, 148);">The Bug</span></strong></span></p><p style="line-height: normal;"><span style="font-size: 15px;">如下代码片段所示，64bit resumption 偏移 nr_exchanged ，可以被 guest 控制，由于Xen’s 的 hypercall resumption 机制，可以被 guest 用来从 out.extent_start 选择一个偏移用来写：</span><span style="font-size: 14px;"><br></span></p><p style="line-height: normal;"><span style="font-size: 14px;"><br></span></p><blockquote><p style="line-height: normal;"><span style="font-size: 14px;">static long memory_exchange(XEN_GUEST_HANDLE_PARAM(xen_memory_exchange_t) arg)<br>{<br>[...]<br>/* Various sanity checks. */<br>[...]<br>if ( !guest_handle_okay(exch.in.extent_start, exch.in.nr_extents) ||<br>!guest_handle_okay(exch.out.extent_start, exch.out.nr_extents) )<br>{<br>rc = ‐EFAULT;<br>goto fail_early;<br>} [<br>...]<br>for ( i = (exch.nr_exchanged &gt;&gt; in_chunk_order);<br>i &lt; (exch.in.nr_extents &gt;&gt; in_chunk_order);<br>i++ )<br>{<br>[...]<br>/* Assign each output page to the domain. */<br>for ( j = 0; (page = page_list_remove_head(&amp;out_chunk_list)); ++j )<br>{<br>[...]<br>if ( !paging_mode_translate(d) )<br>{<br>[...]<br>if ( __copy_to_guest_offset(exch.out.extent_start,<br>(i &lt;&lt; out_chunk_order) + j,<br>&amp;mfn, 1) )<br>rc = ‐EFAULT;<br>}<br>}[<br>...]<br>}[<br>...]<br>}</span></p></blockquote><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">然而， guest_handle_okay() 只检查了是否可以安全访问从下标 0 开始的 guest 数组 exch.out.extent_start 。 guest_handle_subrange_okay 才应该是正确的方式。因此，一个 attacker 可以攻击者可以通过如下条件来达到给任意地址写 8 个字节的数据的目的：</span></p><ul style="list-style-type: disc;" class="list-paddingleft-2"><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">exch.in.extent_order 和 exch.out.extent_order 为0（新页大小的块替换原来的页大小的块）。</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">exch.out.extent_start 和 exch.nr_exchanged ： exch.out.extent_start 指向用户空间内存，然而 exch.out.extent_start+8*exch.nr_exchanged 指向hypervisor内存中的目标地址，当exch.out.extent_start趋近与NULL时，可以这样计算:</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">exch.out.extent_start=target_add%8, exch.nr_exchanged=target_addr/8 。</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">exch.in.nr_extents 和 exch.out.nr_extents 为 exch.nr_exchanged+1 。</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">exch.in.extent_start 为 input_buffer‐8*exch.nr_exchanged(input_buffer是一个合理的指向物理页的guest_内核地址指针) 这个确保总是指向guest用户空间范围(通过了access_ok()检查)，因为 exch.out.extent_start 粗略地指向用户空间地址范围的起始地址，而且，guest内核地址范围和用户空间地址范围一样大。<br>写入到攻击者控制的地址中的值是一个PFN号。</span></p></li></ul><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><br></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="color: rgb(217, 150, 148); font-size: 18px;"><strong><span style="color: rgb(217, 150, 148);">利用该bug：获取页表的控制</span></strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">在一个忙碌的系统上，控制由内核写的页号是非常困难的。因此，出于稳定性的考虑，有必要将该 bug 视为一个 primitive，即循环地在一个固定的地址写 8 个字节的数据，同时大部分有效的位初始化为 0（由于有限的物理内存），同时少量的有效位初始化为随机值。对于我的 exploit，我决定将这个 primitive 视为写一个必须地随机字节和紧随 7 个垃圾字节的方式。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">事实证明，对于一个 x86-64PV guest，有这样一个 primitive，对于稳定的利用是非常有效的，因为：</span></p><ul style="list-style-type: disc;" class="list-paddingleft-2"><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">x86-64PV guest 知道所有它可以访问的物理页的页号。</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">x86-64PV guest 可以映射属于它们 domain 的页表（4个level的）为可读。Xem只阻止将它们映射为可写。</span></p></li><li><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">Xen 映射所有的物理内存为可写，在地址 0xffff830000000000。<br></span></p></li></ul><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">攻击的目标是将 level 3 页表（我称为“受害页表”）中的一个 entry 指向一个 guest 有写权限的页（我称为“假页表”）。这意味着，攻击者必须写入 8 个字节数据，同时要有假页表的物理页号和一些其它的 Flag，同时还要确保，之后的 8 个字节<br>的页表项保持禁用状态（eg.通过设置下一个entry的第一个字节为0）。最终，攻击者必须写8个控制地字节，之后地 7 个字节不用关心。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">因为所有相关页的物理页号和可写的映射的物理地址对于 guest 来说都是可知的，因此，找出写到哪和要写什么非常轻松，所以，唯一的问题，就是如何利用 primitive 来真正地写入数据。<br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">因为攻击者想使用 primivite 来写到一个可读地页面，故写入一个字节随机数据和7字节垃圾数据的方式可以轻松地转换为写入一个字节的控制数据和 7 个字节的垃圾数据，而写入一个字节的控制数据和 7 个字节垃圾数据的 primitive 可以转换为写入控制数据和 7 个字节垃圾数据的 primitive，通过写入字节到连续的地址，这才是真正的 primitive needed。<br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">到此时，攻击者可以控制一个实时的页表，来允许攻击者映射任意地物理地址到guest 的虚拟地址。也意味着攻击者可以从内存中可靠的读取和写入，包括代码和数据等，到 hypervisor 和该系统上所有其他的虚拟机中。</span></p><p style="margin-top: 25px; margin-bottom: 25px; line-height: 2em;"><span style="color: rgb(217, 150, 148); font-size: 18px;"><strong><span style="color: rgb(217, 150, 148);">在其他虚拟机中执行 shell 命令</span></strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">在此时，攻击者可以完全控制机器了，相当于拥有了 hypervisor 的特权级，同时通过搜索物理内存可以轻易地获取一些机密信息。但是一个实际主义的攻击者，考虑到更多的被检测到的风险，很可能不会注入代码到虚拟机中。<br></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">但是在别的 VM 中运行任意一个 shell 命令更低调一些。所以，我打算继续完善我的exploit 使其可以给所有的其他 PV 虚拟机注入一个 shell 命令。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">第一步，我打算在 hypervisor 上下文中，获取可靠的代码执行能力。通过读写物理内存的能力，一个相对 OS (或者 hypervisor )独立的以 kernel/hypervisor 权限调用任意地址的方式是使用非特权指令 SIDT 来定位 IDT 表，同时写入一个 DPL3 的 IDT entry，之后产生中断。Xen 支持 SMEP 和 SMAP，故不可能将 IDT Entry 指到 guest 内存中，但是使用读写页表项的能力，可以映射一个 guest 拥有的，位于 hypervisor上下文的 shellcode 页为 non‐user‐accessible ，这样可以绕过 SMEP。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">之后，在 hypervisor 上下文中，可以通过读写 IA32_LSTAR MSR 寄存起来 hook Syscall 入口点。Syscall 入口点，同时适用于来自 guest 用户空间的 syscall 和来自 guest 内核的 hypercall。通过映射一个攻击者控制的页面到 guest‐user‐accessible 内存，改变寄存器状态，调用 sysret，有可能将用户空间的执行转移到任意 guest 用户的 shellcode上，该操作独立于 hypervisor 和 guest 操作系统。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">我的 exploit 注入 shellcode 到所有 guest 用户空间每一个调用 write() Syscall 的进程。当 shellcode 运行时，它检查它是否它是否以 root 权限运行，同时是否在 guest 的文件系统不存在 lockfile 文件。如果这些条件被满足，调用 clone() syscall 来创建一个子进程来执行任意的 shell 命令。（注意，我的 exploit 并没有结束自身，故当attacking domain 之后关闭了，hoo k点将导致 hypervisor 崩溃）。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">如下是一个 Qube OS3.2 成功攻击的一个截图。该代码实在一个非特权的 domain&nbsp; “test1234”中执行的，截图显示，它成功注入代码到 dom0 和 firewallvm 虚拟机中：</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p><img src="/ikanxue/images/51c728f3e700aba6ccea9e579ee4350160045246.png" style="width: 671px !important; height: 325px !important;"></p><p style="margin-top: 25px; margin-bottom: 25px; line-height: 2em;"><span style="font-size: 15px;"></span><span style="font-size: 18px;"><strong><span style="color: rgb(217, 150, 148);">结论</span></strong></span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">我坚信导致该问题的根本原因是由于 accessok() 的低安全验证。当前版本的 access_ok() 是 2005 年提交的，两年后，发布了 Xen 和 XSA 的第一个版本。而且看起来老的代码比新的代码更可能包含多的相对直接的安全缺陷，因为当时提交时并没有太多考虑安全因素，如此老代码一直沿用至今。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">当基于这些设想的安全相关的代码被优化时，一定要留意防止这些设想被利用。 access_ok() 事实上常用来检测是否整个范围和 hypervisor 内存重复，这样将阻止该bug 的产生。不幸的是，2005 年， a commit with "x86_64 fixes/cleanups" 改变了 access_ok() 在 x86_64 上的行为，一直沿用到现在的版本。就我目前认为，唯一没有直接使 MEMOP_increase_revervation 和 MEMOP_decrease_reservation hypercall有漏洞的原因是因为 do_dom_mem_op() 的参数 nr_extents 是 32 位的—-一个相对脆弱的防御。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">然而，已经发现了好些 Xen 漏洞是只影响 PV guest 的，因为当处理 HVM guest 时，代码中的那些问题不是必须的，我坚信这个 bug 不是其中的一个。对于 PV guest 来说访问 guest 虚拟内存比 HVM guest 更直接：对于 PVguest，raw_copy_from_guest 调用 copy_from_user() ，只是简单的做了一次边界判断，之后便是有内存页 fixup 的一个memcpy，和正常操作系统执行用户态空间内存检查一致。对于 HVM guest， raw_copy_from_guest() 调用 copy_from_user_hvm() ，会做一个遍历 guest 页表的page-wise 的拷贝（因为内存区域可能物理上是不连续的，同时 hypervisor 并没有一个连续的虚拟映射），同时 guest frame 查找是对每一个页的，包括引用，映射 guest页到 hypervisor 内存和比如阻止 HVM guest 写只读页的各种检查等。故对于 HVM，处理 guest memory 的复杂性要高于 PV。</span></p><p style="margin-top: 15px; margin-bottom: 15px; line-height: 1.75em;"><span style="font-size: 15px;">对于安全研究员来说，我认为了解正常内核调用后来理解半虚拟化不是很难。如果你审计过内核代码，其实 hypercall entry(lstar_enter and int80_direct_trap in xen/arch/x86/x86_64/entry.S) ，基本的 hypercall(for x86 PV: listed in the pv_hypercall_table in xen/arch/x86/pv/hypercall.c) 设计处理和正常的<br>系统调用看起来差不多。<br><br></span></p><p style="line-height: 1.75em; margin-top: 15px; margin-bottom: 15px; text-align: center;"><span style="color: rgb(136, 136, 136);"><span style="font-size: 15px;">本文由 看雪翻译小组 ghostway 编译，来源</span><span style="font-family: arial; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: pre-wrap; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none; font-size: 15px; color: rgb(136, 136, 136);">Jann Horn, Project Zero</span><br></span></p><p style="line-height: 1.75em; margin-top: 15px; margin-bottom: 15px; text-align: center;"><span style="color: rgb(136, 136, 136);"></span></p><p style="text-align: center;"><span style="line-height: 28px; color: rgb(255, 76, 65); font-size: 15px; background-color: rgb(255, 255, 255);">戳👇 图片加入看雪翻译<span style="color: rgb(255, 76, 65); font-size: 15px; line-height: 28px; text-align: center; background-color: rgb(255, 255, 255);">小组</span>哦！</span></p><p style="text-align: center;"><span style="color: rgb(136, 136, 136); font-size: 14px; line-height: 28px; background-color: rgb(255, 255, 255);"></span></p><p style="text-align: center;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458280357&amp;idx=2&amp;sn=9a41f0328e6f5853340dd6e605353616&amp;chksm=b181512f86f6d839e20a9af0da2542ce2daa898161a5fbbb9f7fdeb9d82753caa881d0190002&amp;scene=21#wechat_redirect" target="_blank"><img src="/ikanxue/images/99f5d62e1f36b46338e6b298f23b2419d2081d0b.png" style="visibility: visible !important; width: 411px !important; height: 201px !important;"></a></p><p><br></p><p style="margin-top: 15px; margin-bottom: 15px; max-width: 100%; min-height: 1em; line-height: 1.75em; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(79, 138, 187); box-sizing: border-box !important; overflow-wrap: break-word !important;"><strong style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;">往期热门内容推荐</strong></span></p><hr style="max-width: 100%; line-height: 25.6px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><br style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;"></p><ul style="list-style-type: circle;" class="list-paddingleft-2"><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458282630&amp;idx=1&amp;sn=61fcbc708235dec5d7897a0d7c315756&amp;chksm=b1815a0c86f6d31a50ba1f9a39d876e28f2c71096100b28e961df185f7be94ec77b9199efd51&amp;scene=21#wechat_redirect" target="_blank" style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;">等你来挑战！| 看雪 CTF 2017 攻击篇</a></span></p></li><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458282621&amp;idx=1&amp;sn=15f5bc0fa2b0b34ae241668b23a3939b&amp;chksm=b1815af786f6d3e1fd4bad2c336d725ec600551a6477bbc4c6af93167074ac83873aeba89938&amp;scene=21#wechat_redirect" target="_blank" style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;">【终于等到你！】看雪 CTF 2017</a></span></p></li><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458282703&amp;idx=1&amp;sn=7ed476d577172ff4b4a93807dae2667c&amp;chksm=b1815a4586f6d35373f6c5d783fa99a7bb7cf2fc35da914761a9cf2d9943a09c1aefb9febfbf&amp;scene=21#wechat_redirect" target="_blank" style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;">春风十里，我在等你</span></a></p></li><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important; font-size: 15px;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458282782&amp;idx=2&amp;sn=da69736b13ced5d06f89dd966b208105&amp;chksm=b1815b9486f6d282d284bdc39a63806d5802dc130382888699f624ca1c5565b296906d0e0575&amp;scene=21#wechat_redirect" target="_blank">Headless Chrome入门</a><br></span></p></li><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458282703&amp;idx=3&amp;sn=bfa728ff73cd389cd9258ca32008c6e2&amp;chksm=b1815a4586f6d353468f3adf9545aab3ffdce4f4c3e0e47c967298eca045db0558e37865c3a7&amp;scene=21#wechat_redirect" target="_blank" style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458282766&amp;idx=1&amp;sn=085e5cf9a00e31ddc0ff43c858b3cb5b&amp;chksm=b1815b8486f6d29245021ddf2adb665c85c8709e1c4aeafb54fbf99d3a6db24c7c527e961638&amp;scene=21#wechat_redirect" target="_blank" style="font-size: 15px; text-decoration: none;"><span style="font-size: 15px;">使用最新的代码重用攻击绕过执行流保护（一）</span></a><br style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;"></p></li><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458282758&amp;idx=2&amp;sn=68099a77861c39f15d5646551a08a9cd&amp;chksm=b1815b8c86f6d29ab49792fb843073e16ca35c48656e26209f37baa4b11cbbe3efd5980576c4&amp;scene=21#wechat_redirect" target="_blank">菜鸟调试经典老游戏之富甲天下3</a><br style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></p></li><li><p style="margin-top: 10px; margin-bottom: 10px; max-width: 100%; min-height: 1em; line-height: normal; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;">......<br style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></p></li></ul><p style="margin-top: 15px; margin-bottom: 15px; max-width: 100%; min-height: 1em; line-height: 1.75em; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;">更多优秀文章，长按下方二维码，“<span style="max-width: 100%; color: rgb(0, 122, 170);">关注看雪学院公众号</span>”查看！</span></p><p style="margin-top: 15px; margin-bottom: 15px; max-width: 100%; min-height: 1em; line-height: 1.75em; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></p><p><img src="/ikanxue/images/ec0991a2106a71402e2ef66768cefbfc74037025.jpeg" style="width: 770px !important; height: 513.013px !important;"></p><p style="margin-top: 15px; margin-bottom: 15px; max-width: 100%; min-height: 1em; line-height: 1.75em; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span><span style="max-width: 100%; color: rgb(178, 178, 178); font-size: 14px; box-sizing: border-box !important; overflow-wrap: break-word !important;">看雪论坛：http://bbs.pediy.com/<br style="max-width: 100%; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></p><p style="margin-top: 15px; margin-bottom: 15px; max-width: 100%; min-height: 1em; line-height: 1.75em; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(178, 178, 178); font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;">微信公众号 ID：ikanxue</span></p><p style="margin-top: 15px; margin-bottom: 15px; max-width: 100%; min-height: 1em; line-height: 1.75em; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(178, 178, 178); font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;">微博：看雪安全</span></p><p style="max-width: 100%; min-height: 1em; box-sizing: border-box !important; overflow-wrap: break-word !important;"><span style="max-width: 100%; color: rgb(178, 178, 178); font-size: 15px; box-sizing: border-box !important; overflow-wrap: break-word !important;">投稿、合作：www.kanxue.com</span></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1494849877&src=3&ver=1&signature=FqhZ2eqkNX-xbZfPTDWJFyyUKemv954mf5Q*MuC9JH720SqIESAnz8-uzXmDzovZMdiRZ8GMhE0ZmV0qTfay6WbLQqVN9R81LxiMolMYb5HxJb7Or3u0svWfQJ8Rx1zLdXImq0REGvjHGIF0REVvg7Lowd03Bv-nwy88bR4sghM=">微信地址</a> | <a href="http://bbs.pediy.com/thread-217527.htm">阅读原文</a>
{% endraw  %}

