---
title: 从 Android 源码看 SO 的加载
author: Caln
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1502116456&src=3&ver=1&signature=fMd4ZeYncDjRuvdiU8EiAqzwJV-51HguOx4pnyGlqXjJ10eFEeoZU*4ykBfJ5DfCcbB*9QgBsAKzwmoYzWJII-UCUQe91DIDs-kmMMgnLkBjbWBRDkR0UWlVYaBCOe2hcWj0XlZG4FN44vFNi0PqaqrJiAaBZl9Hj9IG6zGiosI=
date: '2017-07-27 00:00:00 +0000'

---

{% raw  %}
<p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">做安卓逆向的时候常常会碰到写在
 Shared Object（即 [*.so] 文件，下文 SO）的加固逻辑，碰到 SO 的时候惯性分析方法是：静态找 JNI_Onload /
 .init / .init_array 这些在加载之初会被调用的代码段或者是指向被调用代码段的指针段。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">然而现在的加固基本上都会用各种方式抹掉函数关系、SHT 等导致直接静态分析 SO 时既不能从函数表里找到 JNI_Onload 也不能从 SECTION 里找到 .init，部分逆向人员在这种情况下走了弯路。</span></p><section label="Copyright Reserved by ipaiban.com." style="margin: 1em auto; padding: 0.5em 1em; white-space: normal; border-width: medium; border-color: currentcolor; -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; border-style: none; text-align: left;"><section class="color1" style="border-width: 2px; border-style: solid; border-color: rgb(0, 0, 0); -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; padding: 8px 12px; display: inline-block;"><p style="margin: 0px;">#1</p></section><section class="color wihudong" style="background: rgb(0, 0, 0) none repeat scroll 0% 0%; color: rgb(255, 255, 255); border-width: 2px; border-style: solid; border-color: rgb(0, 0, 0); -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; padding: 8px 12px; display: inline-block;"><p style="margin: 0px;">Source Code<br></p></section></section><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">Android
 作为开源的系统，既然可以拿到源码，那么就可以尝试分析加载 SO 时的流程，进而找到对应正确的下断位置来确定 JNI_Onload / 
.init 的偏移量。下文中所有源码均为 android-4.4.2_r1 版本，各个版本在细节上的实现可能存在差异。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">以&nbsp;[java.lang.Runtime
 -&gt; load()]&nbsp;为例子来说明（loadLiabrary() 最后和 load() 殊途同归，有兴趣的可以自行分析），对应的 
Android 源码在&nbsp;[java/lang/Runtime.java]，从 320 行开始。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8EJ0UgRFYoGaWeyJrIqywkVVoO9hrcKule9Hsk8ebVLYbIwOuPydCI5bDOn6QZ6h2YGmPIs1hzicicw/0?wx_fmt=png" style="width: 738px !important; height: 358.662px !important;"></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">可以看到&nbsp;load(String
 pathName)&nbsp;实际上是调用了&nbsp;load(String pathName, ClassLoader 
loader)，而后者又调用了&nbsp;doLoad(pathName, 
loader)，这里的函数调用没有什么实际的意义（仅指对逆向者没有实质的意义，下同）一直在传值。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">下面是&nbsp;doLoad(pathName, loader)&nbsp;的定义，源码还是在上面的 Runtime.java 里。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8EJ0UgRFYoGaWeyJrIqywkVHmxxpeCXlT2ZaNQfiab5VVbkvC9sa2QvqLcM6b4vibjsQ3Osn2QZgdgw/0?wx_fmt=png" style="width: 738px !important; height: 357.456px !important;"></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">主要是检测
 loader 的正确性，并带上 LD_LIBRARY_PATH 一起进入&nbsp;nativeLoad(name, loader, 
ldLibraryPath)，这里开始进入 native 层，nativeLoad 
的定义在&nbsp;vm/native/java_lang_Runtime.cpp # 64&nbsp;行，如下。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8EJ0UgRFYoGaWeyJrIqywkVtC3yjeoxb14vRibrGzSoGUrgdiaiat3EmYFnFkOvQOFLedznlAWdJuU7g/0?wx_fmt=png" style="width: 738px !important; height: 495.336px !important;"></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">还是传值
 + 检查，然后执行&nbsp;[bool success = dvmLoadNativeCode(fileName, classLoader, 
&amp;reason);]&nbsp;，看下 dvmLoadNativeCode(...) 的代码，位于&nbsp;vm/Native.cpp # 301 行。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1UG7KPNHN8EJ0UgRFYoGaWeyJrIqywkVKop4r4ORrQKpkek7H7td7wqnSU80Luzwd8X9vjQp00wvvbE0qH2ehQ/0?wx_fmt=jpeg" style="width: 738px !important; height: 2198.11px !important;"></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">做了一些常规的检查，不赘述了，可以看到&nbsp;[version
 = (*func)(gDvmJni.jniVm, NULL);]&nbsp;这里调用了 JNI_OnLoad，上一行是&nbsp;[ALOGI("[Calling
 JNI_OnLoad for \"%s\"]", pathName);]，记录一下方便逆向时确定位置。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">根据逆向经验 .init(_array) 段定义的内容是在 JNI_OnLoad 之前执行的，而 dlopen 是加载 SO 的函数可能会在这里执行 .init，看一下 dlopen 函数，它的定义在&nbsp;linker/dlfcn.cpp # 63 行。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8EJ0UgRFYoGaWeyJrIqywkVAmQh4lmTB0WgrucfLurkPriawpZHNYWNQYkpHibIVb8Mq8B4HNaBlOBQ/0?wx_fmt=png" style="width: 738px !important; height: 128.56px !important;"></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">其实还是调用了 do_dlopen，do_dlopen 的定义在&nbsp;linker/linker.cpp # 823 行，代码如下。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8EJ0UgRFYoGaWeyJrIqywkVkVUlibNgUviaNWuKdYxbaGzlict5p8x5axQ8vAR68NwNxI66ibD7xaKeGg/0?wx_fmt=png" style="width: 738px !important; height: 185.112px !important;"></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">做了一些检查，*是否符合调用 dlopen 的格式、*是否属于已经加在过的 SO，如果属于之前没有加在过的 SO 就执行&nbsp;[si-&gt;CallConstructors();]，看一下 CallConstructors() 的定义。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8EJ0UgRFYoGaWeyJrIqywkVlHCKXhq0OnSARRksWrXK7nz7h3NXvcYboQYFicHVMQuwAjgtS3Cyn0g/0?wx_fmt=png" style="width: 738px !important; height: 470.526px !important;"></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">重点是最后这的&nbsp;[CallFunction("DT_INIT",
 init_func);]&nbsp;和&nbsp;[CallArray("DT_INIT_ARRAY", init_array, 
init_array_count, false);]，很明显是执行&nbsp;.init(_array)&nbsp;定义的内容，这里不贴 CallArray 
的代码了，其实还是循环调用了 CallFunction，下面看看 CallFunction 的代码，linker/linker.cpp # 
1172 行。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8EJ0UgRFYoGaWeyJrIqywkVKiaJicSictC7SfGibpNg1RDzILYg6eJTicLwlTKB6kuVXgc5H4djBXnb7Zw/0?wx_fmt=png" style="width: 738px !important; height: 153.185px !important;"></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">看到这行代码&nbsp;[function();]，所以可以确定&nbsp;.init(_array)&nbsp;定义的内容最终在这执行。同样记录一下&nbsp;[TRACE("[
 Calling %s @ %p for '%s' ]", function_name, function, 
name);]&nbsp;方便逆向时确定位置。</span></p><section label="Copyright Reserved by ipaiban.com." style="margin: 1em auto; padding: 0.5em 1em; white-space: normal; border-width: medium; border-color: currentcolor; -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; border-style: none; text-align: left;"><section class="color1" style="border-width: 2px; border-style: solid; border-color: rgb(0, 0, 0); -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; padding: 8px 12px; display: inline-block;"><p style="margin: 0px;">#2<br></p></section><section class="color wihudong" style="background: rgb(0, 0, 0) none repeat scroll 0% 0%; color: rgb(255, 255, 255); border-width: 2px; border-style: solid; border-color: rgb(0, 0, 0); -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; padding: 8px 12px; display: inline-block;"><p style="margin: 0px;">Reverse Offset<br></p></section></section><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">找到具体调用的位置之后下面开始确定这两个位置在 ELF 中的便宜，以便动态调试时下断点，根据上面的分析：</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">1. JNI_OnLoad 的调用在 vm/Native.cpp 里，对应 /system/lib/libdvm.so。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">2. .init(_array) 的调用在 linker/linker.cpp 里，对应 /system/bin/linker。</span></p><p><br></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">下面拿
 JNI_OnLoad 做例子说明，adb pull 取出手机里的二进制文件 /system/lib/libdvm.so，拉入 
IDA，[Shift + F12] 显示所有的字符串，直接找&nbsp;"[Calling JNI_OnLoad for 
\"%s\"]"&nbsp;，找到后如图所示。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p style="text-align: left;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8EJ0UgRFYoGaWeyJrIqywkVdzauzo0IILzbON5geREeQ2uNibx3qib5YXh3QIP4e9NibH3IcInExM0rQ/0?wx_fmt=png" style="width: 770px !important; height: 440.616px !important;"></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;"></span><span style="font-size: 15px;">跳到
 DATA XREF 指向的位置&nbsp;[dvmLoadNativeCode(char const*,Object *,char **)+1C4 
]，汇编码如下，可以看到符合源代码中的调用情况，下图选中的&nbsp;[BLX R8]&nbsp;就是调用 JNI_OnLoad 的位置。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1UG7KPNHN8EJ0UgRFYoGaWeyJrIqywkVibvFPYTONF1RwMmqvFSYKI5AwQ9e8sK9AuibM5YuIQBCiciaNibicuRia9gHQ/0?wx_fmt=jpeg" style="color: rgb(0, 0, 0); font-family: -webkit-standard; width: 738px !important; height: 439.11px !important;"></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">可以看到偏移为 [libdvm.so + 0x53A08]，所以当载入一个 SO 时只需要在这个偏移量对应的位置下断即可，.inti(_array) 的处理方法也相同，不重复说明了。</span></p><section label="Copyright Reserved by ipaiban.com." style="margin: 1em auto; padding: 0.5em 1em; white-space: normal; border-width: medium; border-color: currentcolor; -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; border-style: none; text-align: left;"><section class="color1" style="border-width: 2px; border-style: solid; border-color: rgb(0, 0, 0); -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; padding: 8px 12px; display: inline-block;"><p style="margin: 0px;">#3</p></section><section class="color wihudong" style="background: rgb(0, 0, 0) none repeat scroll 0% 0%; color: rgb(255, 255, 255); border-width: 2px; border-style: solid; border-color: rgb(0, 0, 0); -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; padding: 8px 12px; display: inline-block;"><p style="margin: 0px;">结论<br></p></section></section><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">在本次分析的版本 4.4.2_r1 中，只需要在&nbsp;[/system/bin/linker + 0x274C]&nbsp;和[/system/lib/libdvm.so + 0x53A08]&nbsp;这两个位置下断，即可成功找到&nbsp;.inti / .init_array / JNI_OnLoad&nbsp;并实现断点，不需要符号表，SEGMENT啥的，具体效果可以参考我前两篇文章。</span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;"></span></p><section label="Copyright Reserved by ipaiban.com." style="margin: 1em auto; padding: 0.5em 1em; white-space: normal; border-width: medium; border-color: currentcolor; -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; border-style: none; text-align: left;"><section class="color1" style="border-width: 2px; border-style: solid; border-color: rgb(0, 0, 0); -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; padding: 8px 12px; display: inline-block;"><p style="margin: 0px;">#4</p></section><section class="color wihudong" style="background: rgb(0, 0, 0) none repeat scroll 0% 0%; color: rgb(255, 255, 255); border-width: 2px; border-style: solid; border-color: rgb(0, 0, 0); -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; padding: 8px 12px; display: inline-block;"><p style="margin: 0px;">Reference<br></p></section></section><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;">*&nbsp;<span style="color: rgb(111, 168, 220);">&nbsp;Android安全–linker加载so流程，在.init下断点</span></span></p><p style="margin: 15px 1em; text-align: left; letter-spacing: 1px; line-height: 1.75em;"><span style="font-size: 15px;"><span style="color: rgb(111, 168, 220);"><br></span></span></p><section label="Copyright © 2014 playhudong All Rights Reserved." style="border-width: medium; border-color: currentcolor; -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; border-style: none; margin: 5px 0px 0px; padding: 10px 0px; background: rgba(0, 0, 0, 0) none repeat scroll 0% 0%;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8G9B6YFlthnv1h3cWDDXGAmK9wQfy6pod114tTuOSIFVeVd0vd1PEwicksgBGmxL0iaC0icX7B9EQzNg/640?wx_fmt=png" style="margin: 0px auto; display: block; visibility: visible !important; width: 160px !important; height: 8.44575px !important;"></section><p class=""><br></p><p style="letter-spacing: 1px; margin: 15px 1em; text-align: center; line-height: 1.75em;"><span style="font-size: 15px;">本文由看雪论坛 <span class="">Caln 原创，转载请注明来自看雪社区</span></span></p><p style="text-align: center;"><br></p><p style="text-align: left;"><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1UG7KPNHN8HFWP586ic3Pf4F6hD1rnmHpScQgCs4x9dJWoHHNnoiamW5RMTq8alBq5UiahM3G1W9TK3RPXQHXWZUQ/640?wx_fmt=jpeg" style="visibility: visible !important; width: 770px !important; height: 381.992px !important;"></p><p style="text-align: center;"><br></p><p style="letter-spacing: 1px; margin: 15px 1em; text-align: left; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-size: 16px;">热门阅读</span></p><ul style="list-style-type: disc;" class=" list-paddingleft-2"><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284204&amp;idx=1&amp;sn=1f45d8c97686ee0f2403163959a80ff6&amp;chksm=b181402686f6c930101c1e214ebe45db3ed65f9ba0906b2885f4a23e29f56676687df90f8d41&amp;scene=21#wechat_redirect" target="_blank">浅谈macRansom</a></span></p></li><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284229&amp;idx=2&amp;sn=61720f3a096b2e759adbdea8a96a189a&amp;chksm=b181404f86f6c959c89c32d3cc35be7546e0619e6f5ee61aec9dd1472daec95fb997d5c5e332&amp;scene=21#wechat_redirect" target="_blank">一个lpk.dll病毒的分析报告</a></span></p></li><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284116&amp;idx=1&amp;sn=4ae9de8a41b6a92b9b1cda29129733c6&amp;chksm=b18140de86f6c9c86f058016383461ba1f7c517bb3cdb306544b9a26fb579f6ce730809dbfc2&amp;scene=21#wechat_redirect" target="_blank">【暴雷漏洞】CVE-2012-1889 个人漏洞分析报告</a></span></p></li><li><p style="letter-spacing: 1px; margin: 15px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284102&amp;idx=1&amp;sn=881ed6e337462737148a5e905795ca13&amp;chksm=b18140cc86f6c9da359d9cd53a806d4ce3e2e4fe9daff7445cf1e34b612a40c73b27690f1cbe&amp;scene=21#wechat_redirect" target="_blank">Safengine Shielden 2.3.8.0 脱壳 ∷之∷ 修复IAT</a></span></p></li></ul><p style="text-align: center;"><br></p><p style="text-align: center;"><span style="font-size: 15px; background-color: rgb(178, 178, 178); color: rgb(255, 255, 255);">点击阅读原文/read，还有更多干货等着你~</span></p><p><br></p><p><br></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1502116456&src=3&ver=1&signature=fMd4ZeYncDjRuvdiU8EiAqzwJV-51HguOx4pnyGlqXjJ10eFEeoZU*4ykBfJ5DfCcbB*9QgBsAKzwmoYzWJII-UCUQe91DIDs-kmMMgnLkBjbWBRDkR0UWlVYaBCOe2hcWj0XlZG4FN44vFNi0PqaqrJiAaBZl9Hj9IG6zGiosI=">微信地址</a> | <a href="http://bbs.pediy.com/thread-217656.htm">阅读原文</a>
{% endraw  %}

