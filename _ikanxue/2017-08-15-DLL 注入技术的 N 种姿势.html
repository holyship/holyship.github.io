---
title: DLL 注入技术的 N 种姿势
author: 木无聊偶
wechat_source: >-
  http://mp.weixin.qq.com/s?timestamp=1503365665&src=3&ver=1&signature=OYewMZH60kmig22U24i7m7*yIRWwXpdLJI-Tjeo*GEAICPcVyP-61LcAEyxTaEQqli2GF0RNhrf*XV6u7a*Q3xJKnOa*Rvp1cDcK0L2T4-Z9LLOTnde5EFMrmk3QBsnwoXzesZBUrN-pK69zpPkUY1MITkEQA3MXLqeWmnRk7jU=
date: '2017-08-15 00:00:00 +0000'

---

{% raw  %}
<p style="text-align: center;"><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1UG7KPNHN8FlTR3yHrcbloJRKOhBkDwEHicxJFj53hP9hNKI5Qtibv50ofBHDArFGYDvamXIeyLbHn16z6g0110w/0?wx_fmt=jpeg" style="width: 612px !important; height: 408px !important; visibility: visible !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">本文中我将介绍DLL注入的相关知识。不算太糟的是，DLL注入技术可以被正常软件用来添加/扩展其他程序，调试或逆向工程的功能性；该技术也常被恶意软件以多种方式利用。这意味着从安全角度来说，了解DLL注入的工作原理是十分必要的。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">不久前在为攻击方测试（目的是为了模拟不同类型的攻击行为）开发定制工具的时候，我编写了这个名为“injectAllTheThings”小工程的大部分代码。如果你想看一下利用DLL注入实施的攻击行为的若干示例，请参阅网址：</span><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;">https://attack.mitre.org/wiki/Technique/T1055</span><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">。如果你想学习DLL注入的相关知识，你会发现该工程也是有用的。当你想要查询这类信息/代码时，你会发现网上充斥着垃圾；我的代码可能也属于垃圾。我并不是程序员，我只是在需要时对代码进行修改。无论如何，我以一种便于阅读和理解的方式，将多种能在32位和64位环境下生效的DLL注入技术（事实上一共7种不同的技术），整合到了一个单独的Visual Studio工程之中。有些朋友对这些代码感兴趣，所以它也可能会吸引你。为了区分，每种技术有其独有的源文件。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">下图为工具的输出信息，其中显示了所有的选项和实现的技术。</span></p><p style="line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k321LUIpXPeCUS53EJ1aaciakhp1BFkxia4on3SATVL35QCl69S3uSg2rQg/0?wx_fmt=png" style="width: 770px !important; height: 218.825px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">网友@SubTee认为，DLL注入是多余的（如下图所示）；我倾向于同意TA的观点，<strong>然而DLL注入并不仅仅是加载DLL那么简单</strong>。</span></p><p style="text-align: center; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32lgXWNghACuw71cYw34HgczibsvcAdU2xWica4fR7yS0waJ7mpB09LCSA/0?wx_fmt=png" style="width: 534px !important; height: 403px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">你确实可以利用签名认证的微软二进制文件来加载DLL，但你无法附加到一个特定的进程来干预其内存内容。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">为什么大部分渗透测试师实际上不知道DLL注入是什么，或者它是如何工作的？因为Metasploit平台替他们包办的太多了，他们一直盲目地使用它。我认为，学习这种“奇特的”内存操作技术的最好地点，实际上是游戏黑客论坛。如果你正在进行攻击方测试，那么你就必须干这些“脏”活儿，同时研究这些技术；除非你乐意仅仅使用别人随意编写的工具。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">大部分时间，我们使用很复杂的技术开始一次攻击方测试；如果我们未被发现，则开始降低复杂度。基本上这就是我们开始向磁盘投放二进制文件和应用DLL注入技术的时间点。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">本文试图以一种简单而高阶的方式纵览DLL注入技术，同时为GitHub中的项目（网址为：<em><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;">https://github.com/fdiskyou/injectAllTheThings</span></em>）提供“文档”支持。</span></p><p style="margin: 25px 8px; line-height: 1.75em; text-align: center;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;"><br></span></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">简介<br></span></strong></span></p></section></section></section><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">DLL注入技术，一般来讲是向一个正在运行的进程插入/注入代码的过程。我们注入的代码以动态链接库（DLL）的形式存在。DLL文件在运行时将按需加载（类似于UNIX系统中的共享库）。本工程中，我将仅使用DLL文件，然而实际上，我们可以以其他的多种形式“注入“代码（正如恶意软件中所常见的，任意PE文件，shellcode代码/程序集等）。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">同时要记住，你需要合适的权限级别来操控其他进程的内存空间。但我不会在此讨论保护进程（相关网址：<em><span style="font-size: 12px; color: rgb(63, 63, 63); letter-spacing: normal;">https://www.microsoftpressstore.com/articles/article.aspx?p=2233328&amp;seqNum=2</span></em>）和权限级别（通过Vista系统介绍，相关网址：<em><span style="color: rgb(63, 63, 63); letter-spacing: normal; font-size: 12px;">https://msdn.microsoft.com/en-gb/library/windows/desktop/bb648648(v=vs.85).aspx</span></em>）；这属于完全不同的另一个主题。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">再次强调一下，正如我之前所说，DLL注入技术可以被用于合法正当的用途。比如，反病毒软件和端点安全解决方案使用这些技术来将其软件的代码嵌入/拦截系统中“所有”正在运行的进程，这使得它们可以在其运行过程中监控每一个进程，从而更好地保护我们。同样存在恶意的用途。一种经常被用到的通用技术是注入“lsass”进程来获取口令哈希值。我们之前都这么干过。很明显，恶意代码同样广泛应用了代码注入技术：不管是运行shellcode代码，运行PE文件，还是在另一个进程的内存空间中加载DLL文件以隐藏自身，等等。</span></p><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">基础知识<br></span></strong></span></p></section></section></section><p style="text-align: center; margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">对于每一种技术，我们都将用到微软Windows 
API，因为它为我们提供了大量的函数来附加和操纵其他进程。从微软Windows操作系统的第一个版本开始，DLL文件就是其基石。事实上，微软Windows
 
API中的所有函数都包含于DLL文件之中。其中，最重要的是“Kernel32.dll”（包含管理内存，进程和线程相关的函数），“User32.dll”（大部分是用户接口函数），和“GDI32.dll”（绘制图形和显示文本相关的函数）。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">你可能会有疑问，为什么会有这些API接口，为什么微软为我们提供如此丰富的函数集来操纵和修改其他进程的内存空间？主要原因是为了扩展应用程序的功能。比如，一个公司创建了一款应用程序，并且允许其他公司来扩展或增强这个应用程序；如此，这就有了一个合法正当的用途。除此之外，DLL文件还用于项目管理，内存保护，资源共享，等等。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">下图尝试说明了几乎每一种DLL注入技术的流程。</span></p><p style="line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32UH6xaww73sOhCCiaod0TVnSfJOxVZmQwde0BVZkwtse1ZsyOib6K7cdQ/0?wx_fmt=png" style="width: 565px !important; height: 515px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">如上所见，我认为DLL注入共四个步骤：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">1. 附加到目标/远程进程</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">2. 在目标/远程进程内分配内存</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">3. 将DLL文件路径，或者DLL文件，复制到目标/远程进程的内存空间</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">4. 控制进程运行DLL文件</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">所有这些步骤是通过调用一系列指定的API函数来完成的。每种技术需要进行特定的设置和选项配置。我认为，每种技术都有其优点和缺点。</span></p><p style="text-align: center; margin-top: 25px; margin-bottom: 25px;"><br></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">（1）技术介绍<br></span></strong></span></p></section></section></section><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">我们有多种方式可以控制进程运行我们的DLL文件。最普通的应该是“CreateRemoteThread()”和“NtCreateThreadEx()”函数；然而，不可能仅仅向这些函数传递一个DLL文件作为参数，我们必须提供一个包含执行起点的内存地址。为此，我们需要分配内存，使用“LoadLibrary()”加载我们的DLL文件，复制内存，等等。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">我称之为“injectAllTheThings”的工程（因为我只是单纯讨厌“注入器”这个名字，加上GitHub上已经有太多的垃圾“注入器”，而我不想再多一个了）包含7种不同的技术；我并不是其中任何一种技术的原创作者，而是提炼总结了这七种技术（是的，还有更多）。其中某些已经有很多文档资料描述（像“CreateRemoteThread()”），而另一些则属于未公开API函数（像“NtCreateThreadEx()”）。以下是所实现的技术的完整列表，其中每种都可以在32位和64位环境下生效。</span></p><ul style="list-style-type: square;" class="list-paddingleft-2"><li><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">CreateRemoteThread()</span></p></li><li><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">NtCreateThreadEx()</span></p></li><li><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">QueueUserAPC</span></p></li><li><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">SetWindowsHookEx()</span></p></li><li><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">RtlCreateUserThread()</span></p></li><li><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">利用SetThreadContext()找到的代码区域</span></p></li><li><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">反射DLL</span></p></li></ul><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">你可能通过其他的名字了解其中某些技术。以上并不是包含每一种DLL注入技术的完整列表；正如我所说的，还有更多技术，如果之后我在某个工程中需要对其接触学习的话我会将它们添加进来。到目前为止，这就是我在某些工程中所用到的技术列表；其中某些可以稳定利用，某些不可以。需要注意的是，不能够稳定利用的那些技术可能是由于我所编写代码的自身问题。</span></p><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">（2）LoadLibrary()<br></span></strong></span></p></section></section></section><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">正如MSDN中所述，“LoadLibrary()”函数“被用于向调用进程的地址空间加载指定模块，而该指定模块可能导致其他模块被加载”。函数原型与参数说明如下所示：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k327ljialibRannFHPJCOvLKMITeMv8ZNIbZKWmM9opKHBiacbNxAvE4OnMA/0?wx_fmt=png" style="width: 630px !important; height: 217px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">换言之，该函数只需要一个文件名作为其唯一的参数。即，我们只需要为我们的DLL文件路径分配内存，将执行起点设置为“LoadLibrary()”函数的地址，之后将路径的内存地址传递给函数作为参数。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">正如你所知道（或不知道）的，最大的问题是“LoadLibrary()”会向程序注册已加载的DLL模块；这意味着这种方法很容易被检测到，但令人惊奇的是很多端点安全解决方案仍检测不出。不管怎样，正如我之前所说，DLL注入也有一些合法正当的用途，因此我们还要注意的是，如果一个DLL文件已经用“LoadLibrary()”加载过了，则它不会再次执行。你可以试验一下，但我没有对任何一种技术试过。当然，使用反射DLL注入技术不会有这方面的问题，因为DLL模块并未被注册。不同于使用“LoadLibrary()”，反射DLL注入技术将整个DLL文件载入内存，然后通过确定DLL模块的入口点偏移来将其加载；这样可以按照需求更隐蔽的对其进行调用。取证人员仍然能够在内存中找到你的DLL，但会很艰难。Metasploit平台大量使用了这项技术，而且大部分端点解决方案也还乐意始终使用它。如果你想查找这方面的技术资料，或者你在攻防游戏中处于防守方，可以参阅以下网址：</span></p><ul style="list-style-type: square;" class="list-paddingleft-2"><li><p style="margin: 25px 8px; line-height: 1.75em;"><em><span style="color: rgb(63, 63, 63); letter-spacing: normal; font-size: 12px;">https://www.defcon.org/html/defcon-20/dc-20-speakers.html#King</span></em></p></li><li><p style="margin: 25px 8px; line-height: 1.75em;"><em><span style="color: rgb(63, 63, 63); letter-spacing: normal; font-size: 12px;">https://github.com/aking1012/dc20</span></em></p></li></ul><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">附注一下，如果你正在折腾你的端点安全软件，而它很好地利用了以上所有这些技术，你可能需要使用以下攻防反欺骗引擎来试试（注意，我只是尝试轻松的说法，以便你能理解）。某些反欺骗工具的反Rookit性能要比某些反病毒软件要先进得多。reddit网站上有一本书你肯定读过，叫“黑客游戏”，它的作者Nick Cano对其有非常深入的研究；只需了解一下他的工作，你就会理解我所谈论的内容。</span></p><p style="text-align: center; margin-top: 25px; margin-bottom: 25px;"><br></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">附加到目标/远程进程<br></span></strong></span></p></section></section></section><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">首先，我们需要获取我们想要交互的进程句柄；为此我们调用“OpenProcess()”API函数。函数原型如下：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k324v7fpOPOe1D6e0vUYlC4Zl08L2qial9sqx7E3eOxuQ66icSeykpgB9kA/0?wx_fmt=png" style="width: 534px !important; height: 92px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">如果你读过MSDN中相关的文档，那么你应该知道我们需要请求获取一系列特定的访问权限；访问权限的完整列表参阅网址：<em><span style="color: rgb(63, 63, 63); letter-spacing: normal; font-size: 12px;">https://msdn.microsoft.com/en-gb/library/windows/desktop/ms684880(v=vs.85).aspx。</span></em></span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">这些权限随微软Windows操作系统版本不同而不同；以下调用代码可用于几乎每一种技术之中：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32MWGFHNFsricOX1CtpND1AW3v8QcEQWsQW3ADIBO3Iw9FwaCT9E5zXJw/0?wx_fmt=png" style="width: 626px !important; height: 110px !important;"></p><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">在目标/远程进程空间分配内存<br></span></strong></span></p></section></section></section><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">我们调用“VirtualAllocEx()”函数为DLL路径分配内存。正如MSDN中所述，“VirtualAllocEx()”函数“保留，提交或改变指定进程虚拟地址空间中的一块内存区域的状态；函数通过置零来初始化内存。”函数原型如下：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k326IibeEaAweeZf4WEiauI0kTmIzKjsRDGusEgAUFDnbmiah0YmAnVASdlQ/0?wx_fmt=png" style="width: 574px !important; height: 127px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;"> 基本上，我们进行如下的调用操作：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32Isgw9trsPKRlAkMG1MIxAiaP7YeASMgADyIiaNlPcgVzq8GqGVvicoXGA/0?wx_fmt=png" style="width: 748px !important; height: 77px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">或者你可以更聪明一点地调用“GetFullPathName()”API函数；然后，我在整个工程中都没有调用这个API函数，仅仅是出于个人偏好或者是不够聪明。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">如果你想要为整个DLL文件分配空间，就必须进行如下操作：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32KFKfh3o0yJ5wZRS54ruCbCBfpQ6oFTzmeTO9kJxw2AyPL3gmg6xBeA/0?wx_fmt=png" style="width: 750px !important; height: 63px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;"><br></span></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">复制DLL文件路径到目标/远程进程的内存空间中<br></span></strong></span></p></section></section></section><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">现在，我们需要调用“WriteProcessMemory()”API函数，来将我们的DLL文件路径，或者整个DLL文件，复制到目标/远程进程中。函数原型如下所示：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32oMgibobVm1doQG1sqWS4soktVEI6BUrbATg87NvubmnyjTibeCdcaGtQ/0?wx_fmt=png" style="width: 688px !important; height: 125px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">一般的调用代码如下所示：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32pQTEunjia158XvlyQj0ibXZusbZRAj4cNUbPhibdqlE3dW7xjaiav5RXvA/0?wx_fmt=png" style="width: 681px !important; height: 29px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">如果我们想要像反射DLL注入技术所做的那样复制整个DLL文件，就需要更多的代码，因为在将其复制到目标/远程进程之前我们需要将其读入内存。具体代码如下所示：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32qduLqiaaicupC67mgFLQ8MWx4DtlxW1CezzrvjQeRSib1wKia3BZuA5RwQ/0?wx_fmt=png" style="width: 690px !important; height: 57px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">正如之前所述，通过使用反射DLL注入技术，以及将DLL文件复制到内存中，进程不会记录该DLL模块。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">但这样会有一点复杂，因为当DLL模块加载到内存中时我们需要获取其入口点；反射DLL工程的“LoadRemoteLibraryR()”函数部分为我们完成了这项工作。如有需要请参阅源码。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">需要注意的是，我们将注入的DLL文件需要使用适当的包含与选项来进行编译，这样它才能与ReflectiveDLLInjection方法相匹配。“InjectAllThings”工程中包含了一个名为“rdll_32.dll/rdll_64.dll”的DLL文件，可用于练习。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">&nbsp;</span></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">控制进程来运行DLL文件<br></span></strong></span></p></section></section></section><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.75em;"><strong><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">（1）CreateRemoteThread()</span></strong></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">可以说，“CreateRemoteThread()”是最传统和最流行，以及最多文档资料介绍的DLL注入技术。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">它包括以下几个步骤：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">1. 使用OpenProcess()函数打开目标进程</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">2. 通过调用GetProAddress()函数找到LoadLibrary()函数的地址</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">3. 通过调用VirtualAllocEx()函数在目标/远程进程地址空间中为DLL文件路径开辟内存空间</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">4. 调用WriteProcessMemory()函数在之前所分配的内存空间中写入DLL文件路径</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">5. 调用CreateRemoteThread()函数创建一个新的线程，新线程以DLL文件路径名称作为参数来调用LoadLibrary()函数</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">如果你看过MSDN中关于<span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;">“CreateRemoteThread()”</span>函数的文档，那么你应该知道，我们需要一个指针，“指向将由线程执行的，类型为<span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;">‘LPTHREAD_START_ROUTINE’</span>的应用程序定义函数，并且该指针代表远程进程中线程的起始地址”。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">这意味着要运行我们的DLL文件，我们只需要控制进程来做就好（译者注：由下文可知，应该是将“LoadLibrary()”函数作为线程的启动函数，来加载待注入的DLL文件）。很简单。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">以下代码即之前所列的全部基本步骤。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32HIwZJ4RcC5VMOcEtK7Q6vDdKEGRLvBP3Coic4Rc4jeARVp1NZgupU8Q/0?wx_fmt=png" style="width: 754px !important; height: 199.398px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">完整代码请参阅源文件“t_CreateRemoteThread.cpp”。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><strong><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">（2）NtCreateThreadEx()</span></strong></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">另一个选择是使用“NtCreateThreadEx()”函数；这是一个未公开的“ntdll.dll”中的函数，未来可能会消失或改变。这种技术相比而言实现更加复杂，因为我们需要一个结构体（具体如下所示）来向函数传递参数，以及另一个结构体用于从函数接收数据。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32gF9pudVPLg4G9ptTc8pXnyH65nbB15odT63gUeEaKvc0MaBqYichSLw/0?wx_fmt=png" style="width: 694px !important; height: 193px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">网址：<em><span style="color: rgb(63, 63, 63); letter-spacing: normal; font-size: 12px;">http://securityxploded.com/ntcreatethreadex.php </span></em>处的文章详细介绍了该函数调用。设置部分与“CreateRemoteThread()”非常类似；然而，相较于直接调用“CreateRemoteThread()”函数，我们使用如下代码来调用“NtCreateThreadEx()”。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k328aas1R5eRz3NyuKYc1V0X5ic5IkFtXiaiceWurgcyVIJoIwLO3OMPzkvQ/0?wx_fmt=png" style="width: 754px !important; height: 249.989px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">完整代码请参阅源文件“t_NtCreateThreadEx.cpp”。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><strong><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">（3）QueueUserAPC()</span></strong></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">除了之前介绍的方法还有一种选择，不用在目标/远程进程中创建一个新的线程，那就是“QueueUserAPC()”函数。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">根据MSDN中的文档介绍，该函数“向指定线程的APC队列中添加一个用户态的异步过程调用（APC）对象”。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">函数原型与参数说明如下所示。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32T3Gxg6N7ZicJJcAibT1OOME0ahJuq5R8rUAHNKOvcDD1PeMmaGoeFRPQ/0?wx_fmt=png" style="width: 704px !important; height: 191px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">因此，如果不想创建我们自己的线程，我们可以调用“QueueUserAPC()”函数来劫持目标/远程进程中一个已存在的线程；即，调用该函数将在指定线程的APC队列中添加一个异步过程调用。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">我们可以使用一个真实的APC回调函数，而不使用“LoadLibrary()”。事实上参数可以是指向我们想要注入的DLL文件名称的指针，具体代码如下所示。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32WDvd0zrF9WHwg2gYE8GMSVfV3J5xUx2QtEblKY8GoOcbsqQWKQ5icAA/0?wx_fmt=png" style="width: 721px !important; height: 31px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">如果你想试用这种技术，那么有一点你可能注意到了，即它与微软Windows操作系统执行APC的方式有关。没有能够查看APC队列的调度器，这意味着只有线程设置成可唤醒模式才能够检查队列。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">因此，我们基本上劫持每一个单独的线程，具体代码如下所示。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32xnorzmjJv8nlkHZe3YWyMRytTibqkiaq46yb76deshyIuzMrUHyZbHmA/0?wx_fmt=png" style="width: 754px !important; height: 385.588px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">这样做的理由主要是期望其中一个线程会被设为可唤醒模式。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">另外，使用“双脉冲星”（网址：<em><span style="color: rgb(63, 63, 63); letter-spacing: normal; font-size: 12px;">https://countercept.com/our-thinking/doublepulsar-usermode-analysis-generic-reflective-dll-loader/</span></em>，DOUBLEPULSAR 用户模式分析：通用反射DLL加载器）工具分析学习这项技术，是个很好的办法。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">完整代码请参阅源文件“t_QueueUserAPC.cpp”。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><strong><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">（4）SetWindowsHookEx()</span></strong></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">使用这项技术的首要工作是，我们需要理解在微软Windows操作系统中劫持的工作原理。本质上，劫持技术是拦截并干预事件的一种方式。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">正如你所猜想的那样，有很多种不同类型的劫持技术。最通用的一种可能是WH_KEYBOARD和WH_MOUSE消息拦截；没错，它们可被用于监控键盘与鼠标的输入。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">函数“SetWindowsHookEx()”将一个应用程序定义的拦截例程安装到一个拦截链表中。函数原型和参数定义如下所示。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32FyoYBeutUTl5KTcgMew4aDNemDT3OwpbvattwtSrFFKib55AFblsypw/0?wx_fmt=png" style="width: 753px !important; height: 310px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">MSDN中有一段很有趣的备注如下：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">“SetWindowsHookEx函数可被用于向另一个进程注入DLL文件。一个32位的DLL文件不能注入一个64位的进程，反之亦然。如果一个应用程序需要在其他进程中使用劫持技术，那么就要求一个32（64）位的应用程序调用SetWindowsHookEx函数来将一个32（64）位的DLL文件注入到一个32（64）位的进程中。32位和64位DLL文件的名称必须不同。”</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">记住以上内容。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">以下代码是实现的简要过程。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k322iaE9jeiamCFqTspenvNUQ2YswZ9vprgeGfxeIEeEA52dEu8D4uxib1zg/0?wx_fmt=png" style="width: 657px !important; height: 40px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">我们需要理解的是，每一个发生的事件都要遍历拦截链表，该链表包含一系列响应事件的例程。“SetWindowsHookEx()”函数的设置工作基本上就是如何将我们自己的拦截例程植入拦截链表中。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">以上代码用到了待安装的劫持消息类型（WH_KEYBOARD）例程指针，包含例程的DLL模块句柄，以及劫持所关联的线程标识号。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">为了获取例程指针，我们需要首先调用“LoadLibrary()”函数加载DLL文件，然后调用“SetWindowsHookEx()”函数，并等待我们所需的事件发生（本文中该事件是指按键）；一旦事件发生我们的DLL就会被执行。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">注意，正如我们在维基解密（网址：<em><span style="color: rgb(63, 63, 63); font-size: 12px; letter-spacing: normal;">https://wikileaks.org/ciav7p1/cms/page_6062133.html</span></em>）中所看到的，就连联邦调查局的人员也有可能用到“SetWindowsHookEx()”函数。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">完整代码请参阅源文件“t_SetWindowsHookEx.cpp”。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><strong><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">（5）RtlCreateUserThread()</span></strong></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">“RtlCreateUserThread()”是一个未公开的API函数。它的设置工作几乎和“CreateRemoteThread()”函数相同，相应的也和“NtCreateThreadEx()”函数相同。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">实际上，“RtlCreateUserThread()”调用“NtCreateThreadEx()”，这意味着“RtlCreateUserThread()”是“NtCreateThreadEx()”的一个小型封装函数；因此，这个函数并没有新的内容。然而，我们可能只是单纯地想使用“RtlCreateUserThread()”而不用“NtCreateThreadEx()”。哪怕之后发生变动，我们的“RtlCreateUserThread()”仍能正常工作。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">正如你所知道的，不同于其他工具，mimikatz工具和Metasploit平台都用到了“RtlCreateUserThread()”。如果你对此感兴趣，请参阅网址：<span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: normal;"><em><span style="color: rgb(63, 63, 63); font-size: 12px;">https://github.com/gentilkiwi/mimikatz/blob/d5676aa66cb3f01afc373b0a2f8fcc1a2822fd27/modules/kull_m_remotelib.c#L59</span></em></span> 和网址：<em><span style="color: rgb(63, 63, 63); letter-spacing: normal; font-size: 12px;">https://github.com/rapid7/meterpreter/blob/6d43284689240f4261cae44a47f0fb557c1dde27/source/common/arch/win/remote_thread.c</span></em>。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">因此，如果mimikatz工具和Metasploit平台都使用“RtlCreateUserThread()”函数，那么（是的，他们了解自己的处理对象）听从他们的“建议”，使用“RtlCreateUserThread()”；特别是你计划做一项相比于简单的“injectAllTheThings”工程来说更认真的项目。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">完整代码请参阅源文件“t_RtlCreateUserThread.cpp”。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><strong><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">（6）SetThreadContext()</span></strong></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">实际上这是一种非常酷的方法：通过在目标/远程进程中分配一块内存区域，向目标/远程进程注入一段特别构造的代码，这段代码的用途是加载DLL模块。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">以下是32位环境下的代码。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k3287cRvGotGeEiabDCGX46NKcw3A3ca5FlWmKH3rS8pt27MVpKmzicMvCA/0?wx_fmt=png" style="width: 659px !important; height: 160px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">对于64位环境，实际上我没有找到任何完整的工作代码，因此我简单写了我自己的代码，如下所示。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32X8zeSIIk7VXfT1t5s6VgzD8iccBNdJN0TxF8yS7FcicJvdNxuibIicBicdw/0?wx_fmt=png" style="width: 754px !important; height: 582.816px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">在我们想目标进程注入这段代码之前，以下占位符需要修改填充：</span></p><ul style="list-style-type: square;" class="list-paddingleft-2"><li><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">返回地址（代码桩执行完毕之后，线程恢复应回到的地址）</span></p></li><li><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">DLL路径名称</span></p></li><li><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">LoadLibrary()函数地址</span></p></li></ul><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">而这也是进行劫持，挂起，注入和恢复线程这一系列操作的时机。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">我们需要附加到目标/远程进程，之后当然是在目标/远程进程中分配内存。注意，我们需要以读写权限分配内存，以便操作DLL路径名称和用于加载DLL文件的封装代码。具体代码如下所示。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32huiaBeicDzicuQ4cWbGHeVgq61xslcmvnN0ezDUJPl2XWianEiauDYEf6nA/0?wx_fmt=png" style="width: 754px !important; height: 39.5423px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">之后，我们需要获取一个运行于目标/远程进程之上的线程上下文（即我们将要注入封装代码的目标线程）。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">我们调用函数“getThreadID()”来找到线程，你可以在文件“auxiliary.cpp”中找到该函数。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">有了线程标识号之后，我们需要设置线程上下文。具体代码如下所示。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32GNuPHlIE2MfhVNSQfKTK4ic6vlwvQu0PatzFg90DRWBdUzSJECyojTg/0?wx_fmt=png" style="width: 754px !important; height: 23.5625px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">然后，我们需要挂起线程来获取其上下文；一个线程的上下文是指其寄存器的状态，我们格外关注的是EIP/RIP寄存器（根据需要也可以称其为IP——instruction pointer，指令指针）。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">由于线程已被挂起，所以我们可以改变EIP/RIP寄存器的值，控制线程在不同的路径上（我们的代码区域）继续执行。具体代码如下所示。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32NEXAf6ahQic2KFxHK8tRa3r4347IeicIrLkyo6PFQ5KiaqLSog78vdCNA/0?wx_fmt=png" style="width: 754px !important; height: 167.94px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">因此，我们中断线程，获取上下文，并从上下文中提取EIP/RIP值；保存的旧值用于在注入代码执行完成时恢复线程的执行流程。新的EIP/RIP值设置为我们注入的代码位置。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">然后我们用返回地址，DLL路径名称地址和“LoadLibrary”函数地址填充所有的占位符。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">线程开始执行的时候，我们的DLL文件将被加载；而当注入代码执行完成时，执行流程将返回县城挂起点，并从此恢复线程的正常执行流程。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">如果你想要调试这种技术方法来学习练习，以下是操作流程。启动你想要注入的应用程序，在此我们以“notepad.exe”为例。使用“x64dbg”调试工具来运行“injectAllTheThings_64.exe”，如下图所示。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32oQt9vzicoIAuej7EKcYFdDMWuibfVXNfJlPjIqzC1jy713Bf88CJCHUQ/0?wx_fmt=png" style="width: 754px !important; height: 442.598px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">使用以下命令（根据你的实际环境来调整）。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32ticicFvyibl66v4icgbDFd0S09jXTRKW9FiaVS71wJV7ibPKHBxUOTHmReew/0?wx_fmt=png" style="width: 754px !important; height: 36.3276px !important;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;"><br></span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">在调用“WriteProcessMemory()”函数处设下断点，如下图所示。</span></p><p style="line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32oBu2NYDt1qBRQbPoEeroHwjicocpu6wicVXyIOy1rVdyLGWrwZNJzxoA/0?wx_fmt=png" style="width: 770px !important; height: 219.532px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">继续运行程序，当运行到断点处时，注意寄存器RDX中的内存地址，如图所示。如果你对为什么这里需要关注RDX有疑问，请去查阅x64环境下的调用约定；搞清楚再回来继续学习。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32UHK4awXVLgniay82aGVECJl9P4UmAQ2Jiazj9NiaibJCFvhr3iaXS6wD8GQ/0?wx_fmt=png" style="width: 754px !important; height: 223.428px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">单步步过（快捷键F8）调用“WriteProcessMemory()”函数的过程，开启x64dbg工具的另一个实例，并将其附加到“notepad.exe”进程通过快捷键“Ctrl+g”调到之前复制的地址（即RDX寄存器中的内存地址）处，你将看到我们的代码区域程序集，如下图所示。</span></p><p style="line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32eUyAY8VcgfOneK3kAJ8yZ10MOLrzshrwINKuJmxibqgodfwL7ibgLUrQ/0?wx_fmt=png" style="width: 770px !important; height: 525.271px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">很酷吧？现在在Shellcode代码起始处设下断点。转向“injectAllTheThings”调试进程，并运行程序。我们的断点被成功断下，如下图所示；现在我们可以步过代码，并分析这段代码的功能。</span></p><p style="line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32G1ygbbxkz7xTZbial8TwkZEQxfh7NOApVg5QPJg1Vtq4NZEb6uq484A/0?wx_fmt=png" style="width: 770px !important; height: 476.139px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">当我们调用“LoadLibrary()”函数时，我们的DLL文件成功加载，如下图所示。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32twicIq9JE5pMlYXx1bOxreN18Sfwne5SodIEkDZuDJAF58rTibb05ugg/0?wx_fmt=png" style="width: 754px !important; height: 485.491px !important;"></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">太棒了~</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">我们的Shellcode代码将返回到之前保存的RIP地址处，“notepad.exe”进程将恢复执行。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">完整代码请参阅源文件“t_suspendInjectResume.cpp”。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><strong><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">（7）反射DLL注入</span></strong></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">我将Stephen 
Fewer（这项技术的先驱）的代码也整合到了这个“injectAllTheThings”工程中，同时还构建了一个反射DLL文件用于这项技术。注意，我们要注入的DLL文件必须使用适当的包含和选项来进行编译，这样它才能与反射DLL注入技术相匹配。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">反射DLL注入技术通过将整个DLL文件复制到内存中的方式来生效，因此它避免了向进程注册DLL模块这一行为。所有的繁琐工作都已完成。要在DLL模块加载到内存时获取其入口点，我们只需要使用Stephen
 
Fewer的代码；他的工程中所包含的“LoadRemoteLibrary()”函数为我们完成这项工作。我们使用“GetReflectLoaderOffset()”函数来确定在我们进程内存中的偏移，然后我们将偏移加上目标/远程进程（即我们写入DLL模块的进程）的内存基址，将该结果作为执行起始点。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">太复杂？好吧，可能有点儿；以下是实现上述过程的4个主要步骤。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">1. 将DLL文件头部写入内存</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">2. 将每个区块写入内存（通过解析区块表）</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">3. 检查输入表，并加载任何引用的DLL文件</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">4. 调用DLLMain函数的入口点</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">相比于其他方法，这种技术有很好的隐蔽性，主要被用于Metasploit平台。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">如果你想要了解更多，请前往官方GitHub库；还想要阅读Stephen 
Fewer的文章的话，请参阅网址：<em><span style="color: rgb(63, 63, 63); letter-spacing: normal; font-size: 12px;">http://www.harmonysecurity.com/files/HS-P005_ReflectiveDllInjection.pdf</span></em>。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">还可以参阅“MemoryModule”项目的作者Joachim Bauch所写的“从内存中加载DLL文件”，以及一篇好文章“不调用LoadLibrary()函数‘手动’加载32位/64位DLL文件”。</span></p><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><section class="" style="box-sizing: border-box;"><section class="" style="margin-top: 10px; margin-bottom: 10px; text-align: center; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><section class="" style="padding: 3px; display: inline-block; border-bottom: 1px solid rgb(53, 56, 55); box-sizing: border-box;"><p style="margin: 0px; padding: 0px; box-sizing: border-box; background-color: rgba(1, 0, 0, 0);"><span style="color: rgb(63, 63, 63);"><strong><span style="letter-spacing: 2px; color: rgb(63, 63, 63); font-size: 16px;">代码<br></span></strong></span></p></section></section></section><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">还有一些模糊复杂的注入方法，因此我未来将对“injectAllTheThings”工程进行更新。其中某些最有趣的技术包括：</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">•“双脉冲星”工具所用到的技术</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">•网友@zerosum0x0所编写的工具，使用SetThreadContext()和NtContinue()实现的反射DLL注入，详细描述参见网址：<span style="color: rgb(63, 63, 63); letter-spacing: 2px; font-size: 12px;"><em><span style="color: rgb(63, 63, 63); letter-spacing: normal;">https://zerosum0x0.blogspot.co.uk/2017/07/threadcontinue-reflective-injection.html</span></em></span>，可用代码详见网址：<em><span style="color: rgb(63, 63, 63); letter-spacing: normal; font-size: 12px;">https://github.com/zerosum0x0/ThreadContinue</span></em>。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">以上我所描述的所有技术，都在一个单独的工程中实现了，我将其放在GitHub库中；其中还包括每种技术所需的DLL文件。为了便于理解，下表简单介绍了所实现的方法和具体用法。</span></p><p style="margin: 25px 8px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8GDVWMYbLoOB8vQ38eo2k32ZRLKOYGHud7K4xMd147DGicrRddYIML1xh0MheIjNCpf5SL9SkpM3sA/0?wx_fmt=png" style="width: 625px !important; height: 291px !important;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">需要说明的是，从安全角度出发，应该坚持使用injectAllTheThings_32.exe注入32位进程，或者injectAllTheThings_64.exe来注入64位进程；尽管你也可以使用injectAllTheThings_64.exe来注入32位进程。而实际上我并没有这样实现，但可能之后我会尝试一下，具体请参考以下网址：<em><span style="color: rgb(63, 63, 63); letter-spacing: normal; font-size: 12px;">http://blog.rewolf.pl/blog/?p=102</span></em>。参考网址中的技术基本上就是Metasploit平台上“smart_migrate”工具所用到的，详见网址：<em><span style="color: rgb(63, 63, 63); letter-spacing: normal; font-size: 12px;">https://github.com/rapid7/meterpreter/blob/5e24206d510a48db284d5f399a6951cd1b4c754b/source/common/arch/win/i386/base_inject.c。</span></em></span></p><p style="margin: 25px 8px; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63); letter-spacing: 2px;">整个工程的代码（包括DLL文件）都在GitHub库中。代码以32位/64位环境编译，包含或不包含调试信息都可以。</span></p><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><section label="Copyright © 2014 playhudong All Rights Reserved." style="border-width: medium; border-color: currentcolor; -moz-border-top-colors: none; -moz-border-right-colors: none; -moz-border-bottom-colors: none; -moz-border-left-colors: none; border-style: none; margin: 5px 0px 0px; padding: 10px 0px; background: rgba(0, 0, 0, 0) none repeat scroll 0% 0%;"><img src="http://mmbiz.qpic.cn/mmbiz_png/1UG7KPNHN8G9B6YFlthnv1h3cWDDXGAmK9wQfy6pod114tTuOSIFVeVd0vd1PEwicksgBGmxL0iaC0icX7B9EQzNg/640?wx_fmt=png" style="margin: 0px auto; display: block; visibility: visible !important; width: 160px !important; height: 8.44575px !important;"></section><p><br></p><p style="margin-top: 25px; margin-bottom: 25px;"><br></p><p style="letter-spacing: 1px; margin: 25px 1em; text-align: center; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">本文由看雪翻译小组 木无聊偶 编译，来源<span class="" style="">rui</span>@Shut Up and Hack<br><br></span></p><p style="letter-spacing: 1px; margin: 25px 1em; text-align: center; line-height: 1.75em;"><span style="font-size: 15px; color: rgb(63, 63, 63);">转载请注明来自看雪社区</span></p><p style="text-align: center;"><br></p><p style="text-align: center; margin-top: 25px; margin-bottom: 25px; line-height: 1.75em;"><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1UG7KPNHN8HFWP586ic3Pf4F6hD1rnmHpScQgCs4x9dJWoHHNnoiamW5RMTq8alBq5UiahM3G1W9TK3RPXQHXWZUQ/640?wx_fmt=jpeg" style="visibility: visible !important; width: 770px !important; height: 381.992px !important;"></p><p style="text-align: center;"><br></p><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 16px; color: rgb(63, 63, 63);">热门阅读</span></p><ul style="list-style-type: disc;" class="list-paddingleft-2"><li><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284324&amp;idx=3&amp;sn=a3fda988453c3513cc19f8d9f18a2799&amp;chksm=b18141ae86f6c8b8e87afb4cc64dfcc463247dee1e76dc3b60ef258683a03f1587d5c9848668&amp;scene=21#wechat_redirect" target="_blank">议题征集 | 2017 安全开发者峰会</a></span></p></li><li><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284479&amp;idx=1&amp;sn=81d51d5c61105694cf8fcd6718e331ae&amp;chksm=b181413586f6c8235f344750e023fb49fab7978386ecfa21264a31d92940f3df6ef6ecaeb5f7&amp;scene=21#wechat_redirect" target="_blank">实现CVE-2016-3842的堆喷</a></span></p></li><li><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284522&amp;idx=1&amp;sn=c0a69f214a5acdb3216089eb0f3a37e6&amp;chksm=b181416086f6c87644efb0d4e59dec5402b9dbce952a78577cd6ada74b7c51b5a4be35526a1d&amp;scene=21#wechat_redirect" target="_blank">恶意软件中的逃避技术，十八般武艺样样齐全</a></span></p></li><li><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284463&amp;idx=1&amp;sn=5d979393c455e7b2c28172102ec02633&amp;chksm=b181412586f6c833b99a3499456e31192e45c31e3dc03ac65d42be9f38a18f907ccf3ca5947b&amp;scene=21#wechat_redirect" target="_blank">BitDefender：由7z PPMD产生的远程栈溢出漏洞</a></span></p></li><li><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284420&amp;idx=1&amp;sn=45426c1de7e996bbf5a0847582dcc535&amp;chksm=b181410e86f6c8185d5a7dc016290147eea3d294fa7a73ddad11b554578e792cfff4ba553f1e&amp;scene=21#wechat_redirect" target="_blank">URSNIF 变种通过收集鼠标移动轨迹判断是否处于沙盒以绕过查杀</a></span></p></li><li><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458284405&amp;idx=1&amp;sn=4bbff4ca120e5d5b1e1ea02d244485c0&amp;chksm=b18141ff86f6c8e97c8fb6c539a607940b84144828e7131dac5747f08d164a20c87f0e5c47a4&amp;scene=21#wechat_redirect" target="_blank">凭借Scapy, radamsa工具和少量明文数据包对专有协议进行Fuzzing测试</a></span></p></li></ul><p style="letter-spacing: 1px; margin: 25px 1em; text-align: left; line-height: 1.75em;"><span style="font-size: 15px; text-decoration: none; color: rgb(63, 63, 63);"><br></span></p><hr/><a href="http://mp.weixin.qq.com/s?timestamp=1503365665&src=3&ver=1&signature=OYewMZH60kmig22U24i7m7*yIRWwXpdLJI-Tjeo*GEAICPcVyP-61LcAEyxTaEQqli2GF0RNhrf*XV6u7a*Q3xJKnOa*Rvp1cDcK0L2T4-Z9LLOTnde5EFMrmk3QBsnwoXzesZBUrN-pK69zpPkUY1MITkEQA3MXLqeWmnRk7jU=">微信地址</a> | <a href="http://bbs.pediy.com/thread-220405.htm">阅读原文</a>
{% endraw  %}

